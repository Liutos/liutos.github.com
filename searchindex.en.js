var relearn_searchindex = [
  {
    "breadcrumb": "小打小闹写点bug",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "实用 Prolog 编程",
    "uri": "/posts/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "无印",
    "uri": "/normal/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 本文演示如何用 Prolog 来实现经典的 Hello World 程序。\n搭建开发环境 为了可以运行 Prolog 程序，需要先安装一个 Prolog 语言的实现。这里我选择的是 SWI-Prolog，到这里下载对应平台的安装包，安装完毕后，运行命令swipl --version可以看到相应的输出\n➜ /tmp swipl --version SWI-Prolog version 9.0.4 for x86_64-darwin 接着再打开这个链接，给 VSCode 安装相应的插件，实现语法高亮，效果如下图所示\n运行 Prolog 程序 使用 VSCode 将下列代码保存到名为hello_world.pl的文件中\n:- initialization(main, main). main(_) :- writeln(\"Hello, world!\"). 然后运行命令swipl ./hello_world.pl即可输出Hello, world!到屏幕上，如下图所示\n展开说说 接下来对上述源文件hello_world.pl做一番讲解。\n源文件命名 Prolog 源文件的后缀名通常为.pl，因此上文中的文件名为hello_world.pl。\n程序入口 与 C 语言不同，Prolog 并没有规定程序启动的时候要调用哪一个函数，而是由开发者使用命令（Prolog 的术语为directive）:- initialization来指定的。可以将initialization视为一个两个参数的函数：\n第一个参数为Goal，表示要调用的函数的名字。在这里就是main； 第二个参数为When，表示在什么时候调用Goal。当它的值为main的时候（注意，这里的main是一个固定的模式，与作为参数Goal的函数的名字无关），就表示是在程序启动的时候调用。 因此，:- initialization(main, main).的意思，就是在程序启动的时候，调用名为main的函数。\n函数定义 在 Prolog 中，使用操作符:-来定义函数。它的左侧是函数的名字和参数列表，在上文的例子中，函数名为main，它有一个参数。由于这个参数在函数体中并未被用到，因此将其命名为_——这是 Prolog 中的匿名变量的意思，它可以避免触发编译器对于一个变量仅出现了一次的警告。而在:-的右侧直到英文句号（即.这个符号）的代码则属于函数体，在这里是writeln(\"Hello, world!\")。\n如果函数体中有多于一个语句，那么它们之间由英文逗号（即,这个符号）分隔。例如，将前文中的代码改写如下\n:- initialization(main, main). main(_) :- write(\"Hello, \"), writeln(\"world!\"). 可以看到，两个语句之间正是由,分隔。\n字符串 就像其它许多语言一样，SWI-Prolog 也支持以双引号的语法来表示一个字符串对象，因此上文中的\"Hello, world!\"是字符串类型，而不是一个 atom（atom 是 Prolog 中的一种数据类型，前文中的main就是一个 atom）。\n输出 函数write和writeln都可以用于将字符串输出到屏幕，区别在于后者会在最后输出一个换行符。",
    "description": "序言 本文演示如何用 Prolog 来实现经典的 Hello World 程序。\n搭建开发环境 为了可以运行 Prolog 程序，需要先安装一个 Prolog 语言的实现。这里我选择的是 SWI-Prolog，到这里下载对应平台的安装包，安装完毕后，运行命令swipl --version可以看到相应的输出\n➜ /tmp swipl --version SWI-Prolog version 9.0.4 for x86_64-darwin 接着再打开这个链接，给 VSCode 安装相应的插件，实现语法高亮，效果如下图所示\n运行 Prolog 程序 使用 VSCode 将下列代码保存到名为hello_world.pl的文件中\n:- initialization(main, main). main(_) :- writeln(\"Hello, world!\"). 然后运行命令swipl ./hello_world.pl即可输出Hello, world!到屏幕上，如下图所示\n展开说说 接下来对上述源文件hello_world.pl做一番讲解。\n源文件命名 Prolog 源文件的后缀名通常为.pl，因此上文中的文件名为hello_world.pl。\n程序入口 与 C 语言不同，Prolog 并没有规定程序启动的时候要调用哪一个函数，而是由开发者使用命令（Prolog 的术语为directive）:- initialization来指定的。可以将initialization视为一个两个参数的函数：",
    "tags": [],
    "title": "用 Prolog 开发 Hello World 程序",
    "uri": "/posts/hello_world/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 书接上回，在上一篇文章中，我们通过尝试用 Prolog 编写 Hello World 程序，了解了 Prolog 程序的基本结构和运行方式。本篇将会在hello_world.pl的基础上，实现一个简单的 HTTP 服务器。\n启动 HTTP 服务器 利用 SWI-Prolog 内置的库，很容易就可以启动一个 HTTP 服务器。只需要调用函数http_server即可\n:- initialization(main, main). :- use_module(library(http/http_server), [http_server/1]). main(_) :- http_server([port(8082)]), sleep(100000000). 将上述代码保存到文件http_server.pl中并运行便可以启动 HTTP 服务器\n由于在源文件中没有定义任何接口，因此任何请求都只会返回 404 的响应\n使用模块 在上文中出现的use_module也是一种命令（directive），它用于从模块中导入函数。例如，:- use_module(library(http/http_server), [http_server/1]).的意思，就是从模块http/http_server中导入一个参数个数为 1 的函数http_server到当前模块中，如此一来，就可以直接调用它。\n提供接口 正如前文所述，由于当前应用没有注册任何的路由规则，因此无论如何请求都只会返回 404 的响应。接下来我将给这个 HTTP 服务器添加一个非常简单的接口，来固定返回文本Hello, world!。要注册一个接口，需要用到来自于模块http/http_dispatch的函数http_handler，从它的文档可以看到，它需要三个参数：\n接口路径Path，如用一个原子来表示的路径/api/shorten； 负责实现接口业务逻辑的函数对象Closure； 描述接口属性的列表Options，如描述该接口的请求方法。 这样一个固定返回 Hello World 字符串的接口可能是下面这样子的\n:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_server), [http_server/1]). hello(_Request) :- format('Content-Type: text/html~n~n'), format('Hello, world!'). main(_) :- http_handler('/api/shorten', hello, [methods([get])]), http_server([port(8082)]), sleep(100000000). 用老办法启动服务后的测试结果如下\n接口路径 作为http_handler的第一个参数，'/api/shorten'看起来很像是其它主流语言中为人熟知的字符串，然而在 Prolog 中，它是一个原子（atom）。尽管引号内的内容看起来一样，但原子与字符串并不相等，如下图所示\n接口输出 从 SWI-Prolog 的文档可以知道，担任http_handler第二个参数的Closure必须负责输出至少Content-Type和数据体部分。此外，尽管hello的写法看起来是将响应的内容输出到了标准输出（颇有上古时期的 CGI 脚本的风格），但其实format输出的目的地已经被框架所替换，可以换成下面的代码来更好地感受这一点\n:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_server), [http_server/1]). hello(_Request) :- current_output(Stream), format(Stream, 'Content-Type: text/html~n~n', []), format(Stream, 'Hello, world!', []). main(_) :- http_handler('/api/shorten', hello, [methods([get])]), http_server([port(8082)]), sleep(100000000). 而请求结果则是相同的。",
    "description": "序言 书接上回，在上一篇文章中，我们通过尝试用 Prolog 编写 Hello World 程序，了解了 Prolog 程序的基本结构和运行方式。本篇将会在hello_world.pl的基础上，实现一个简单的 HTTP 服务器。\n启动 HTTP 服务器 利用 SWI-Prolog 内置的库，很容易就可以启动一个 HTTP 服务器。只需要调用函数http_server即可\n:- initialization(main, main). :- use_module(library(http/http_server), [http_server/1]). main(_) :- http_server([port(8082)]), sleep(100000000). 将上述代码保存到文件http_server.pl中并运行便可以启动 HTTP 服务器\n由于在源文件中没有定义任何接口，因此任何请求都只会返回 404 的响应\n使用模块 在上文中出现的use_module也是一种命令（directive），它用于从模块中导入函数。例如，:- use_module(library(http/http_server), [http_server/1]).的意思，就是从模块http/http_server中导入一个参数个数为 1 的函数http_server到当前模块中，如此一来，就可以直接调用它。\n提供接口 正如前文所述，由于当前应用没有注册任何的路由规则，因此无论如何请求都只会返回 404 的响应。接下来我将给这个 HTTP 服务器添加一个非常简单的接口，来固定返回文本Hello, world!。要注册一个接口，需要用到来自于模块http/http_dispatch的函数http_handler，从它的文档可以看到，它需要三个参数：\n接口路径Path，如用一个原子来表示的路径/api/shorten； 负责实现接口业务逻辑的函数对象Closure； 描述接口属性的列表Options，如描述该接口的请求方法。 这样一个固定返回 Hello World 字符串的接口可能是下面这样子的",
    "tags": [],
    "title": "用 Prolog 提供 HTTP 服务_server",
    "uri": "/posts/http_server/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 在前一篇文章中，HTTP 服务提供了唯一一个接口/api/shorten，但它并非真的会生成短链，而是返回固定的字符串。本文将会对这个接口进行升级，使其可以接收原始 URL 作为参数，并返回一个与其对应的短链的 ID。\n提取参数 要想生成短链，首先必须能够接收到用户输入的原始 URL，而这可以使用函数http_parameters/2实现。假设现在要给接口/api/shorten支持一个参数url，要求其以表单的形式输入，并将该输入回显回去，那么代码可以是下面这样的\n:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). echo(Request) :- http_parameters(Request, [ url(Url, []) ]), format('Content-Type: text/html~n~n'), format('url is ~s', [Url]). main(_) :- http_handler('/api/shorten', echo, [methods([post])]), http_server([port(8082)]), sleep(100000000). 可以使用下列命令来测试它\ncurl -X POST -d 'url=https://example.com' -v 'http://localhost:8082/api/shorten' 存储 URL 若是在主流的编程语言中，想要在程序的运行过程暂时维护一些键值关系，通常会使用哈希表，如 JavaScript 中的对象，或 Python 中的字典。在 Prolog 中，有着与之类似的东西，那边是动态谓词。\n:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). echo(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: text/html~n~n'), format('bind url ~s to id ~d', [Url, Id]). main(_) :- http_handler('/api/shorten', echo, [methods([post])]), http_server([port(8082)]), sleep(100000000). 这里出现了一个新的指令dynamic，它的作用是声明一个谓词是动态的。这样一来，在程序运行的过程中，就可以使用函数asserta来定义新的“事实”——就像是在往一个关系型数据库的表中不停地插入新的行一样。\n为了可以获取不重复的数值来作为每一个短链的 ID，这里采用的策略是先用函数get_time将当前时间存储到变量TimeStamp中，然后将其截断为整数来作为 ID 使用。\n参数的方向 如果你想要知道为什么get_time(TimeStamp)这样的代码的作用是将当前时间戳存储到变量TimeStamp中，那么你需要先理解 Prolog 代码的运行方式。通过 REPL 可以更容易地理解，例如，在swipl中输入下列代码\nget_time(TimeStamp). 可以理解为你是在想 Prolog 发问，询问它get_time(TimeStamp)这个“查询”是否成立，以及如果成立的话，变量TimeStamp的值是什么。因此，在此时此刻，Prolog 会告诉我们这个查询成立，并且是在当变量TimeStamp的值为1740758262.052527的时候成立。\n你也可以输入一个具体的数值来询问 Prolog，但我想如果不是有预知能力的话，应当不会有人可以让带着具体数值的get_time成立\n不仅是本文中才出现的get_time，在上一篇文章中出现的函数current_output同样也可以为参数“绑定”一个值。这样的函数的文档中，通常会为其参数加上一个减号（-）的前缀\n函数与谓词 尽管到目前为止，我都是用“函数”来称呼main、write、writeln等标识符的，但其实在 Prolog 的术语中，它们叫做“谓词”。谓词会返回真和假，表示一组参数关系成立或不成立。例如，length/2就是一个用来判断列表长度是否为给定的数值的谓词，可以在swipl的 REPL 中像下面这样使用\n而前文中出现的truncate/1则不是一个谓词，它是一个函数。函数无法作为 Prolog 实现的“目标”（Goal），因此不能作为查询在 REPL 中提交\n要获取“函数”的返回值，需要使用is/2，它的左边是变量（如前文中的Id），右边则是一个函数调用的表达式（如前文中的truncate(TimeStamp)）。",
    "description": "序言 在前一篇文章中，HTTP 服务提供了唯一一个接口/api/shorten，但它并非真的会生成短链，而是返回固定的字符串。本文将会对这个接口进行升级，使其可以接收原始 URL 作为参数，并返回一个与其对应的短链的 ID。\n提取参数 要想生成短链，首先必须能够接收到用户输入的原始 URL，而这可以使用函数http_parameters/2实现。假设现在要给接口/api/shorten支持一个参数url，要求其以表单的形式输入，并将该输入回显回去，那么代码可以是下面这样的\n:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). echo(Request) :- http_parameters(Request, [ url(Url, []) ]), format('Content-Type: text/html~n~n'), format('url is ~s', [Url]). main(_) :- http_handler('/api/shorten', echo, [methods([post])]), http_server([port(8082)]), sleep(100000000). 可以使用下列命令来测试它\ncurl -X POST -d 'url=https://example.com' -v 'http://localhost:8082/api/shorten' 存储 URL 若是在主流的编程语言中，想要在程序的运行过程暂时维护一些键值关系，通常会使用哈希表，如 JavaScript 中的对象，或 Python 中的字典。在 Prolog 中，有着与之类似的东西，那边是动态谓词。\n:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). echo(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: text/html~n~n'), format('bind url ~s to id ~d', [Url, Id]). main(_) :- http_handler('/api/shorten', echo, [methods([post])]), http_server([port(8082)]), sleep(100000000). 这里出现了一个新的指令dynamic，它的作用是声明一个谓词是动态的。这样一来，在程序运行的过程中，就可以使用函数asserta来定义新的“事实”——就像是在往一个关系型数据库的表中不停地插入新的行一样。",
    "tags": [],
    "title": "用 Prolog 提供短链服务",
    "uri": "/posts/shorten_url/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 在上一篇文章中，HTTP 服务已经可以将入参中的原始 URL 存储起来，并将其与一个唯一的 ID 绑定在一起。在本文中，将会新增一个接口，实现将数值 ID 转换为原始 URL，并通过重定向返回给调用者。\n重定向到原始 URL 现有的接口/api/shorten的返回值并不利于使用，为此接下来会修改为返回Content-Type: application/json类型的数据。此外，还会有一个新接口/api/lengthen，它接受一个参数id，从内存中找出与这个 ID 绑定的原始 URL，并通过 302 的状态码返回。\n:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), url_to_id(Url, Id), http_redirect(moved, Url, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: application/json~n~n'), format('{\"id\": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 启动 HTTP 服务后，先请求接口/api/shorten，获得一个短链的 ID，再访问新接口即可重定向到原始 URL。\nID 无效怎么办 如果我捏造一个不存在的 ID 来输入，那么url_to_id(Url, Id)就无法成立，会导致接口触发异常、返回 500 的状态码。为了处理这种情况，可以定义一个新的谓词reply_by_id，它接受一个参数Id，并且只有在下列两种情况下才成立：\n入参Id可以使url_to_id(Url, Id)成立，此时返回 301 的状态码。或者； 直接返回 400 的状态码。 改写后的代码如下\n:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_404/2, http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). % 辅助函数。 reply_by_id(Id, Request) :- url_to_id(Url, Id), http_redirect(moved, Url, Request). reply_by_id(_, Request) :- http_404([], Request). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), reply_by_id(Id, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: application/json~n~n'), format('{\"id\": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 这下子如果输入一个未曾返回过的 ID，则接口将返回 404 状态码。\nIF 语句 按照上文的谓词reply_by_id的定义，Prolog 程序在运行时首先会尝试该谓词的第一种情况，即\nreply_by_id(Id, Request) :- url_to_id(Url, Id), http_redirect(moved, Url, Request). 如果输入的Id未曾生成过，那么查询url_to_id(Url, Id)无法成立，整个查询reply_by_id(Id, Request)的结果也会为假。接着，Prolog 会尝试谓词的第二个分支，即\nreply_by_id(_, Request) :- http_404([], Request). 显然，这个分支总是可以成立，最终调用方收到了 404 的响应。这种非此即彼的场景，在传统语言中可以用if-else之类的语法结构来表达，在 Prolog 中其实也有等价的东西，就是谓词-\u003e/2。借助它，谓词reply_by_id可以改写为以下形式\nreply_by_id(Id, Request) :- ( url_to_id(Url, Id) -\u003e http_redirect(moved, Url, Request) ; http_404([], Request)). 它的效果是相同的。",
    "description": "序言 在上一篇文章中，HTTP 服务已经可以将入参中的原始 URL 存储起来，并将其与一个唯一的 ID 绑定在一起。在本文中，将会新增一个接口，实现将数值 ID 转换为原始 URL，并通过重定向返回给调用者。\n重定向到原始 URL 现有的接口/api/shorten的返回值并不利于使用，为此接下来会修改为返回Content-Type: application/json类型的数据。此外，还会有一个新接口/api/lengthen，它接受一个参数id，从内存中找出与这个 ID 绑定的原始 URL，并通过 302 的状态码返回。\n:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), url_to_id(Url, Id), http_redirect(moved, Url, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: application/json~n~n'), format('{\"id\": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 启动 HTTP 服务后，先请求接口/api/shorten，获得一个短链的 ID，再访问新接口即可重定向到原始 URL。",
    "tags": [],
    "title": "提供短链访问能力",
    "uri": "/posts/lengthen_url/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 在前两篇文章中，URL 以及短链的 ID 都是存储在内存中的，程序重启后，已经绑定好的 URL 和 ID 就都丢失了。本章介绍如何将短链的信息存储到文件中，并在程序启动时加载进内存中。\n写入文件 在之前的文章中，url_to_id是一个动态谓词，可以将其简单地理解为一个既可以根据Url查询出Id、也可以根据Id查询出Url的双向哈希表。为了可以实现将短链信息存储到文件中，将会把url_to_id修改为一个预先定义好的谓词。\nurl_to_id仍然接受Url和Id两个参数，但这两个参数在实际使用时，不会同时都有值、总有一个是变量：\n如果Url是字符串、Id是整数，那么实现的是将新的 URL 存储起来的功能； 如果Url是变量、Id是整数，那么它会实例化Url，这样实现的是根据 ID 查找原始 URL 的功能。 用于存储短链信息的文件格式为 CSV，第一列为 ID，第二列为原始 URL，而两者之间通过逗号分隔。这样的一个短链服务的代码可能是下面这样子的\n:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_404/2, http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). :- use_module(library(lists), [nth0/3]). :- use_module(library(readutil), [read_file_to_string/3]). find_url_by_id(_, [], _) :- fail. find_url_by_id(Id, [Line|Lines], Url) :- split_string(Line, \",\", \"\", SubStrings), % 将一行内容按照逗号切割，放到 SubStrings 中。 nth0(0, SubStrings, IdString), % 取出第一列的数据，放到 IdString 中。 ( format(string(IdString), \"~d\", [Id]) % 检查将 Id 转换为字符串的话，是否与 IdString 相同。 -\u003e nth0(1, SubStrings, Url) % 如果相同，说明第二列的数据就是所需要的链接，放入变量 Url。 ; find_url_by_id(Id, Lines, Url)). % 否则，递归处理 Lines，直至为空、查询失败。 % 读写文件来管理短链。 url_to_id(Url, Id) :- string(Url), integer(Id), open(\"/tmp/url.csv\", append, Stream), format(string(Line), '~d,~s~n', [Id, Url]), write(Stream, Line), close(Stream). url_to_id(Url, Id) :- read_file_to_string(\"/tmp/url.csv\", String, []), split_string(String, \"\\n\", \"\", Lines), find_url_by_id(Id, Lines, Url). % 辅助函数。 reply_by_id(Id, Request) :- ( url_to_id(Url, Id) -\u003e http_redirect(moved, Url, Request) ; http_404([], Request)). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), reply_by_id(Id, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, [string]) % 因为 url_to_id 中有类型要求。 ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), url_to_id(Url, Id), format('Content-Type: application/json~n~n'), format('{\"id\": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 确保文件流关闭 在url_to_id的定义中，并没有机制可以确保close一定会被调用来关闭文件流。要实现类似 Python 中的with open、或者 Common Lisp 中的with-open-file的效果的话，可以用setup_call_cleanup。因此，url_to_id的第一个分支可以修改为\nurl_to_id(Url, Id) :- string(Url), integer(Id), setup_call_cleanup( open(\"/tmp/url.csv\", append, Stream), ( format(string(Line), '~d,~s~n', [Id, Url]), write(Stream, Line) ), close(Stream) ). 分隔源文件 到目前为止，这个 HTTP 服务的源文件已经有 60 行左右了，而且其中的谓词url_to_id也是一个相对独立的功能——它与处理 HTTP 请求并没有太大关系，因此很适合将其剥离到另一个源文件中。新的文件结构将会是这样\n/ |- http_server.pl `- url_to_id.pl 其中，在文件url_to_id.pl中，使用指令:- module定义出一个模块，并将其中的谓词url_to_id/2暴露出来、供http_server.pl使用，后者则使用指令:- use_module来加载这个自定义模块。最终url_to_id.pl和http_server.pl的内容分别如下\n:- module(url_to_id, [url_to_id/2]). :- use_module(library(lists), [nth0/3]). :- use_module(library(readutil), [read_file_to_string/3]). find_url_by_id(_, [], _) :- fail. find_url_by_id(Id, [Line|Lines], Url) :- split_string(Line, \",\", \"\", SubStrings), % 将一行内容按照逗号切割，放到 SubStrings 中。 nth0(0, SubStrings, IdString), % 取出第一列的数据，放到 IdString 中。 ( format(string(IdString), \"~d\", [Id]) % 检查将 Id 转换为字符串的话，是否与 IdString 相同。 -\u003e nth0(1, SubStrings, Url) % 如果相同，说明第二列的数据就是所需要的链接，放入变量 Url。 ; find_url_by_id(Id, Lines, Url)). % 否则，递归处理 Lines，直至为空、查询失败。 % 读写文件来管理短链。 url_to_id(Url, Id) :- string(Url), integer(Id), setup_call_cleanup( open(\"/tmp/url.csv\", append, Stream), ( format(string(Line), '~d,~s~n', [Id, Url]), write(Stream, Line) ), close(Stream) ). url_to_id(Url, Id) :- read_file_to_string(\"/tmp/url.csv\", String, []), split_string(String, \"\\n\", \"\", Lines), find_url_by_id(Id, Lines, Url). :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_404/2, http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). :- use_module(url_to_id, [url_to_id/2]). % 辅助函数。 reply_by_id(Id, Request) :- ( url_to_id(Url, Id) -\u003e http_redirect(moved, Url, Request) ; http_404([], Request)). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), reply_by_id(Id, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, [string]) % 因为 url_to_id 中有类型要求。 ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), url_to_id(Url, Id), format('Content-Type: application/json~n~n'), format('{\"id\": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000).",
    "description": "序言 在前两篇文章中，URL 以及短链的 ID 都是存储在内存中的，程序重启后，已经绑定好的 URL 和 ID 就都丢失了。本章介绍如何将短链的信息存储到文件中，并在程序启动时加载进内存中。\n写入文件 在之前的文章中，url_to_id是一个动态谓词，可以将其简单地理解为一个既可以根据Url查询出Id、也可以根据Id查询出Url的双向哈希表。为了可以实现将短链信息存储到文件中，将会把url_to_id修改为一个预先定义好的谓词。\nurl_to_id仍然接受Url和Id两个参数，但这两个参数在实际使用时，不会同时都有值、总有一个是变量：\n如果Url是字符串、Id是整数，那么实现的是将新的 URL 存储起来的功能； 如果Url是变量、Id是整数，那么它会实例化Url，这样实现的是根据 ID 查找原始 URL 的功能。 用于存储短链信息的文件格式为 CSV，第一列为 ID，第二列为原始 URL，而两者之间通过逗号分隔。这样的一个短链服务的代码可能是下面这样子的\n:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_404/2, http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). :- use_module(library(lists), [nth0/3]). :- use_module(library(readutil), [read_file_to_string/3]). find_url_by_id(_, [], _) :- fail. find_url_by_id(Id, [Line|Lines], Url) :- split_string(Line, \",\", \"\", SubStrings), % 将一行内容按照逗号切割，放到 SubStrings 中。 nth0(0, SubStrings, IdString), % 取出第一列的数据，放到 IdString 中。 ( format(string(IdString), \"~d\", [Id]) % 检查将 Id 转换为字符串的话，是否与 IdString 相同。 -\u003e nth0(1, SubStrings, Url) % 如果相同，说明第二列的数据就是所需要的链接，放入变量 Url。 ; find_url_by_id(Id, Lines, Url)). % 否则，递归处理 Lines，直至为空、查询失败。 % 读写文件来管理短链。 url_to_id(Url, Id) :- string(Url), integer(Id), open(\"/tmp/url.csv\", append, Stream), format(string(Line), '~d,~s~n', [Id, Url]), write(Stream, Line), close(Stream). url_to_id(Url, Id) :- read_file_to_string(\"/tmp/url.csv\", String, []), split_string(String, \"\\n\", \"\", Lines), find_url_by_id(Id, Lines, Url). % 辅助函数。 reply_by_id(Id, Request) :- ( url_to_id(Url, Id) -\u003e http_redirect(moved, Url, Request) ; http_404([], Request)). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), reply_by_id(Id, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, [string]) % 因为 url_to_id 中有类型要求。 ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), url_to_id(Url, Id), format('Content-Type: application/json~n~n'), format('{\"id\": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 确保文件流关闭 在url_to_id的定义中，并没有机制可以确保close一定会被调用来关闭文件流。要实现类似 Python 中的with open、或者 Common Lisp 中的with-open-file的效果的话，可以用setup_call_cleanup。因此，url_to_id的第一个分支可以修改为",
    "tags": [],
    "title": "存储 URL 到文件",
    "uri": "/posts/file_storage/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 如果无法读写数据库，那么一门编程语言的实用性将会大打折扣。好在，SWI-Prolog 对这方面也提供了支持，接下来就这方面进行讲解。\n连接 MySQL 查阅 SWI-Prolog 的文档可以看到，如果要读取 MySQL，可以使用这几个谓词：\nodbc_driver_connect，用来连接数据库； odbc_query，执行查询的 SQL，获取结果； odbc_disconnect，断开数据库连接。 一段查询 MySQL 版本号信息的示例代码如下\n:- use_module(library(odbc), [odbc_disconnect/1, odbc_driver_connect/3, odbc_query/3]). :- initialization(main, main). main(_) :- Dsn = \"DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten\", odbc_driver_connect(Dsn, Connection, []), Sql = \"SELECT VERSION()\", odbc_query(Connection, Sql, row(Version)), odbc_disconnect(Connection), format(\"Version is ~s~n\", [Version]). 效果如下图所示\nMySQL ODBC 驱动 MySQL 的 ODBC 驱动文件需要自己安装。先到这里下载\n安装完毕后，通过iODBC Administrator64可以看到驱动的具体文件路径\n这样就获得了驱动文件的具体路径，可以用到Dsn中了。\n读写 MySQL 假设用于存储短链信息的表名为t_short_url，其表结构如下\nCREATE TABLE `t_short_url` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `url` VARCHAR(256) NOT NULL COMMENT '短链对应的原始链接', `ctime` TIMESTAMP DEFAULT CURRENT_TIMESTAMP, `mtime` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE INDEX `ux__url` (`url`) ) AUTO_INCREMENT=1000001; 那么可以像下面这样子改写谓词url_to_id，使其从基于文件变成基于 MySQL 来存储短链信息。\n:- module(url_to_id, [url_to_id/2]). :- use_module(library(odbc), [odbc_disconnect/1, odbc_driver_connect/3, odbc_query/3]). % 读写文件来管理短链。 url_to_id(Url, Id) :- string(Url), var(Id), % Id 不再需要由外部实例化，因此这里要求其为变量。 % 连接数据库。 Dsn = \"DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten\", odbc_driver_connect(Dsn, Connection, []), % 用参数化来构造 INSERT 语句。 odbc_prepare(Connection, 'INSERT INTO `test`.`t_short_url` SET `url` = ?', [default], Statement), odbc_execute(Statement, [Url]), % 获取新行的 id 列的值。 odbc_query(Connection, 'SELECT LAST_INSERT_ID()', row(Id)), % 断开连接。 odbc_disconnect(Connection). url_to_id(Url, Id) :- var(Url), integer(Id), % 连接数据库。 Dsn = \"DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten\", odbc_driver_connect(Dsn, Connection, []), % 在输入安全的情况下直接拼接 SQL 字符串。 format(string(Sql), 'SELECT `url` FROM `test`.`t_short_url` WHERE `id` = ~d', [Id]), % 获取给定 ID 的行的原始 URL。 odbc_query(Connection, Sql, row(Url)), % 断开连接。 odbc_disconnect(Connection). 可以单独测试这个模块的效果，如下图所示\n而在调用谓词url_to_id的位置，则不再需要事先计算好Id的值了，将下列代码删除\n% 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), 然后 HTTP 服务便可以照常运作了。",
    "description": "序言 如果无法读写数据库，那么一门编程语言的实用性将会大打折扣。好在，SWI-Prolog 对这方面也提供了支持，接下来就这方面进行讲解。\n连接 MySQL 查阅 SWI-Prolog 的文档可以看到，如果要读取 MySQL，可以使用这几个谓词：\nodbc_driver_connect，用来连接数据库； odbc_query，执行查询的 SQL，获取结果； odbc_disconnect，断开数据库连接。 一段查询 MySQL 版本号信息的示例代码如下\n:- use_module(library(odbc), [odbc_disconnect/1, odbc_driver_connect/3, odbc_query/3]). :- initialization(main, main). main(_) :- Dsn = \"DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten\", odbc_driver_connect(Dsn, Connection, []), Sql = \"SELECT VERSION()\", odbc_query(Connection, Sql, row(Version)), odbc_disconnect(Connection), format(\"Version is ~s~n\", [Version]). 效果如下图所示\nMySQL ODBC 驱动 MySQL 的 ODBC 驱动文件需要自己安装。先到这里下载\n安装完毕后，通过iODBC Administrator64可以看到驱动的具体文件路径",
    "tags": [],
    "title": "存储 URL 到 MySQL",
    "uri": "/posts/mysql_storage/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  实用 Prolog 编程",
    "content": "序言 在前一篇文章中，连接数据库的配置是写在代码中的，在谓词url_to_id中重复出现了两次。在本文中，会将配置从源文件中剥离出来，改为在程序启动的时候从 JSON 格式的配置文件中读取。\n配置文件及其解析 新增一个配置文件config.json，其内容如下：\n{ \"mysql\": { \"dsn\": \"DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten\" } } 接着新增一个源文件config.pl，它负责实现一个用于解析 JSON 文件的模块\n:- module(config, [current_dsn/1, parse/1]). :- dynamic current_dsn/1. % 声明一个动态谓词，用于存储解析好的 ODBC DSN 字符串。 :- use_module(library(http/json), [atom_json_dict/3]). :- use_module(library(readutil), [read_file_to_string/3]). parse(ConfigPath) :- read_file_to_string(ConfigPath, String, []), % 按照 JSON 格式反序列化为字典类型的数据。 atom_json_dict(String, JSONDict, []), % 将 DSN 字符串存储在谓词中，这样外部就可以通过 current_dsn/1 获取。 asserta(current_dsn(JSONDict.mysql.dsn)). 使用效果如下图所示\n现在可以改写源文件http_server.pl和url_to_id.pl了，前者在谓词main中调用parse/1来解析配置文件，后者调用current_dsn/1来获取 DSN 以连接数据库。\n字典类型 在parse中调用atom_json_dict得到的JSONDict是一个字典类型的对象，可以用write来查看它的内容\n图中如_1518、_1510这样的项在 SWI-Prolog 中叫做Tag，可以将其视为系统随机生成的类型名，而如mysql、dsn这样的位于冒号左侧的就是字典的键、右侧的就是对应的值。这个语法也可以用于输入字典字面量\n命令行选项 尽管在前文中，ODBC DSN 已经被放到了配置文件中，但是配置文件的路径仍然是写在源文件中的（节选如下）\nmain(_) :- % 解析配置文件。 parse(\"./config.json\"), 一个更好的做法是将配置文件的路径通过命令行选项传给程序，为此这里用到了谓词opt_arguments来解析命令行选项。新增一个模块cli_parser.pl来负责解析命令行选项\n:- module(cli_parser, [extract_config_path/2, parse_argv/1]). :- use_module(library(optparse), [opt_arguments/3]). extract_config_path([], _) :- fail. extract_config_path([config_path(ConfigPath) | _], ConfigPath). extract_config_path([_ | Opts], ConfigPath) :- extract_config_path(Opts, ConfigPath). parse_argv(Opts) :- OptsSpec = [ [ opt(config_path), % opt_arguments 要求每个命令行选项都必须指定 opt。 shortflags([c]), % 短的选项名称，使用时为 -c。 type(atom) % 传入的值为字符串，因此必须指定类型为 atom。 ] ], opt_arguments(OptsSpec, Opts, _). 要测试这个模块，可以在启动swipl时输入两个连字符--，然后再跟着要被解析的命令行选项，如-c '/Users/liutos/Projects/shorten/tutorials/config.json'。这样一来，--之后的部分都将可以被opt_arguments处理到，如下图所示\n最后在谓词main中调用这两个新的功能即可\nmain(_) :- % 解析命令行选项。 parse_argv(Opts), % 取出配置文件路径。 extract_config_path(Opts, ConfigPath), % 解析配置文件。 parse(ConfigPath), http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000).",
    "description": "序言 在前一篇文章中，连接数据库的配置是写在代码中的，在谓词url_to_id中重复出现了两次。在本文中，会将配置从源文件中剥离出来，改为在程序启动的时候从 JSON 格式的配置文件中读取。\n配置文件及其解析 新增一个配置文件config.json，其内容如下：\n{ \"mysql\": { \"dsn\": \"DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten\" } } 接着新增一个源文件config.pl，它负责实现一个用于解析 JSON 文件的模块\n:- module(config, [current_dsn/1, parse/1]). :- dynamic current_dsn/1. % 声明一个动态谓词，用于存储解析好的 ODBC DSN 字符串。 :- use_module(library(http/json), [atom_json_dict/3]). :- use_module(library(readutil), [read_file_to_string/3]). parse(ConfigPath) :- read_file_to_string(ConfigPath, String, []), % 按照 JSON 格式反序列化为字典类型的数据。 atom_json_dict(String, JSONDict, []), % 将 DSN 字符串存储在谓词中，这样外部就可以通过 current_dsn/1 获取。 asserta(current_dsn(JSONDict.mysql.dsn)). 使用效果如下图所示\n现在可以改写源文件http_server.pl和url_to_id.pl了，前者在谓词main中调用parse/1来解析配置文件，后者调用current_dsn/1来获取 DSN 以连接数据库。\n字典类型 在parse中调用atom_json_dict得到的JSONDict是一个字典类型的对象，可以用write来查看它的内容",
    "tags": [],
    "title": "读取 JSON 配置文件",
    "uri": "/posts/json_config/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug \u003e  无印",
    "content": "黑客与画家 虽然程序员多数时候都在与字符打交道，但偶尔也会像建筑或制造业的工程师一样，画一些图，比如：\n为了表达多个系统如何协作以实现业务需求，会画时序图； 为了表达存储到数据库中的业务实体间的关系，会画ER图； 为了表达复杂的业务实体在整个生存期中状态的变化，会画状态图。 除此之外，还有流程图、甘特图、火焰图，等等。\n尽管软件开发过程中产出的这些图不一定逼真、漂亮，或严谨，但凭着图上不同的形状、颜色，以及布局，也可以做到一图胜千言的效果。\n图很有用，画图的工具也同样举足轻重。如果是本地的桌面应用，多数人可能会选择用Windows平台的Visio或macOS平台的OmniGraffle；若说到作图网站，则可能会选择ProcessOn或Draw.io。\n但比起用鼠标拖拖拉拉，我更喜欢用代码来画图。\n用代码画图？ 用代码画图大致上可以分为两类：\n用具体的编程语言控制某种绘图的API画出想要的图形，比如OpenGL、HTML5中的Canvas； 用DSL描述想要画的图，然后用程序根据DSL生成图片。 我所说的用代码画图指的是上述的第二类。\n百闻不如一见，以最容易上手的DOT语言为例，将下列内容保存在名为hello.dot的文件中\ndigraph G { Hello -\u003e World } 然后在shell中运行如下命令\ndot -Tpng hello.dot -o hello.png 便得到了相应的PNG文件\n更多的栗子 下面就带各位读者走马观花地看看不同的图可以用哪些工具来绘制。\n流程图 说到程序员画的图，最出名的当属流程图了。依稀记得在高中的时候，某一册的数学课本中讲到了算法（也许是辗转相除法），并且给出了图示，那应当就是我第一次见到流程图。上大学后也有一段时间痴迷于寻找能够绘制流程图的DSL，不过一直未果。直到遇到Boostnote后，才知道的确有这样的DSL，那便是flowchart.js。\nflowchart.js是一个JS编写的、用来绘制流程图的库。比如下面这张图\n便是依据下列的DSL生成的\nst=\u003estart: Start op=\u003eoperation: Your Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop flowchart.js生成的是SVG格式的图片文件，但SVG文件不方便嵌入到Markdown或Confluence的文档中，因此我会把它转换为PNG格式。折腾了一番后，发现在Mac上最靠谱的方法，是将SVG文件嵌入一个HTML文档，再用浏览器打开这个HTML，然后复制图片到预览程序上保存下来。\n遗憾的是，不管是Emacs还是VSCode，似乎都没有辅助编辑flowchart.js的DSL的插件。\n有限状态机 有限状态机的示意图也是很常见的图形，尤其是在讲解编译器的书的语法分析章节中。在Graphviz项目官网的Gallery板块中，便有一个有限状态机的例子\n它由如下的DOT代码描述\ndigraph finite_state_machine { rankdir=LR; size=\"8,5\" node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8; node [shape = circle]; LR_0 -\u003e LR_2 [ label = \"SS(B)\" ]; LR_0 -\u003e LR_1 [ label = \"SS(S)\" ]; LR_1 -\u003e LR_3 [ label = \"S($end)\" ]; LR_2 -\u003e LR_6 [ label = \"SS(b)\" ]; LR_2 -\u003e LR_5 [ label = \"SS(a)\" ]; LR_2 -\u003e LR_4 [ label = \"S(A)\" ]; LR_5 -\u003e LR_7 [ label = \"S(b)\" ]; LR_5 -\u003e LR_5 [ label = \"S(a)\" ]; LR_6 -\u003e LR_6 [ label = \"S(b)\" ]; LR_6 -\u003e LR_5 [ label = \"S(a)\" ]; LR_7 -\u003e LR_8 [ label = \"S(b)\" ]; LR_7 -\u003e LR_5 [ label = \"S(a)\" ]; LR_8 -\u003e LR_6 [ label = \"S(b)\" ]; LR_8 -\u003e LR_5 [ label = \"S(a)\" ]; } 不少工具将DOT语言作为中间媒介来实现绘图的功能。\n与flowchart.js不同，Emacs和VSCode都可以很好地支持DOT代码的编辑和预览。Emacs上有dot-mode，VSCode则有Graphviz (dot) language support for Visual Studio Code这个插件。\n时序图 我画得最多的当属时序图。在旧文《时序图绘制工具走马观花》中，提到了三个工具：\nWebSequenceDiagrams，一个在线绘制时序图的网站； sdedit，一个本地的命令行兼GUI绘图工具； SequenceDiagram，也是一个网站。 当时倾向于使用sdedit。时过境迁，如今的WebSequenceDiagrams变得更好看了，而我也选择了PlantUML作为绘制时序图的主力工具。下面这张图是PlantUML官网给出的例子\n它依据如下的代码生成\n@startuml 用户 -\u003e 认证中心: 登录操作 认证中心 -\u003e 缓存: 存放(key=token+ip,value=token)token 用户 \u003c- 认证中心 : 认证成功返回token 用户 -\u003e 认证中心: 下次访问头部携带token认证 认证中心 \u003c- 缓存: key=token+ip获取token 其他服务 \u003c- 认证中心: 存在且校验成功则跳转到用户请求的其他服务 其他服务 -\u003e 用户: 信息 @enduml Emacs的plantuml-mode，以及VSCode的PlantUML插件都可以为PlantUML的DSL提供语法高亮。\n下载了PlantUML的jar包后，在Emacs中添加如下的配置，就可以不依赖远程服务器来生成PNG格式的图片了\n(setq plantuml-default-exec-mode 'jar) (setq plantuml-jar-path \"/path/to/plantuml.jar\") UML用例图 在《架构整洁之道》一书中，作者提出了一个软件架构模式，其中有一层便是用例。看完这本书后，我越发地喜欢作者这一套架构模式，渐渐开始在设计文档中给出需求的典型用例——尽管是文字描述。再后来，才知道原来UML中已经有一类专门用于描述用例的图形方法——用例图。\n用于画用例图的依然是PlantUML。下列这张图\n便是依据如下的源代码生成的\n@startuml left to right direction actor 员工 as yg actor 顾客 as gk actor 餐厅员工 as ctyg actor A2 as a2 actor 送餐员 as scy rectangle cos { note \"没注册工资\\n支付的采用\\n送餐时收费\" as mzc usecase 查看菜单 as ckcd usecase 注册 as zc usecase 登录 as dl usecase 订餐 as dc usecase \"预约/覆盖预约\" as yy usecase 备餐 as bc usecase 请求送餐 as qqsc usecase 记录送餐 as jlsc usecase 打印送餐说明 as dyscsm usecase 记录收费 as jlsf zc .\u003e dl : \u003c\u003cextends\u003e\u003e dl .\u003e dc : \u003c\u003cextends\u003e\u003e } actor A1 as a1 note bottom of a1 : 已注册工资支付 yg \u003c|-- gk gk \u003c|-- ctyg ctyg \u003c|-- a2 ctyg \u003c|-- scy yg -- ckcd yg ---- zc yg --- dl gk -- dc gk ---- yy ctyg -- bc ctyg --- qqsc scy -- jlsc scy --- dyscsm scy -- mzc jlsf -- mzc @enduml 比较遗憾的是，PlantUML自动排版的结果显得不那么整齐，左下角有一个明显的三角形空白区域——这也是DSL大法的一个缺点，即无法完美地控制最终的排列效果。\nUML类图 最开始接触UML的时候，学习的便是类图——尽管接触得最早，画得却最少。比起类图，ER图反而画得更多一点。\n如果要画类图，首选的工具是mermaid。跟PlantUML一样，mermaid也是一个大而全的东西，除了画UML类图，也可以画流程图、时序图，以及UML状态图等。下面这张图\n便是mermaid-cli依据如下的源代码生成的\nclassDiagram Image \u003c|-- BMP Image \u003c|-- GIF Image \u003c|-- JPEG Image: +setImpl() Image: +parseFile() ImageImpl \u003c|-- WinImpl ImageImpl \u003c|-- LinuxImpl ImageImpl: +doPaint() Image ..\u003e ImageImpl Emacs用户可以安装mermaid-mode，VSCode用户则可以使用Mermaid Preview这个插件，来辅助编辑mermaid的源文件。\n方才提到的mermaid-cli是一个命令行程序，用于在本地根据mermaid的源文件产生PNG格式的图片，安装也很简单\nnpm install -g mermaid.cli 总结 还有许多的图可以用DSL来绘制，感兴趣的读者可以到mermaid或PlantUML的官网了解一番，这里不再一一举例。\n用DSL来绘图有一些优点：\n不需要借助鼠标工具，纯键盘党的福音； 源代码为纯文本，生成器跨多平台，可以在多个平台甚至网页上编辑和查看，不受单一软件厂商的约束； 方便修改，改完不需要来回调整各个图形的位置。 但也有一些缺点：\n不直观，生成图片前不好猜测最终的效果； 无法准确地控制图中所有元素的排列和位置，有时候得不到想要的效果； 需要学习不同的DSL，学习成本比可视化工具要高。 就像软件开发中没有银弹一样，画图工具也没有万金油，关键还是要因地制宜地选择最合适的工具来解决眼前的问题。",
    "description": "黑客与画家 虽然程序员多数时候都在与字符打交道，但偶尔也会像建筑或制造业的工程师一样，画一些图，比如：\n为了表达多个系统如何协作以实现业务需求，会画时序图； 为了表达存储到数据库中的业务实体间的关系，会画ER图； 为了表达复杂的业务实体在整个生存期中状态的变化，会画状态图。 除此之外，还有流程图、甘特图、火焰图，等等。\n尽管软件开发过程中产出的这些图不一定逼真、漂亮，或严谨，但凭着图上不同的形状、颜色，以及布局，也可以做到一图胜千言的效果。\n图很有用，画图的工具也同样举足轻重。如果是本地的桌面应用，多数人可能会选择用Windows平台的Visio或macOS平台的OmniGraffle；若说到作图网站，则可能会选择ProcessOn或Draw.io。\n但比起用鼠标拖拖拉拉，我更喜欢用代码来画图。\n用代码画图？ 用代码画图大致上可以分为两类：\n用具体的编程语言控制某种绘图的API画出想要的图形，比如OpenGL、HTML5中的Canvas； 用DSL描述想要画的图，然后用程序根据DSL生成图片。 我所说的用代码画图指的是上述的第二类。\n百闻不如一见，以最容易上手的DOT语言为例，将下列内容保存在名为hello.dot的文件中\ndigraph G { Hello -\u003e World } 然后在shell中运行如下命令\ndot -Tpng hello.dot -o hello.png 便得到了相应的PNG文件\n更多的栗子 下面就带各位读者走马观花地看看不同的图可以用哪些工具来绘制。\n流程图 说到程序员画的图，最出名的当属流程图了。依稀记得在高中的时候，某一册的数学课本中讲到了算法（也许是辗转相除法），并且给出了图示，那应当就是我第一次见到流程图。上大学后也有一段时间痴迷于寻找能够绘制流程图的DSL，不过一直未果。直到遇到Boostnote后，才知道的确有这样的DSL，那便是flowchart.js。\nflowchart.js是一个JS编写的、用来绘制流程图的库。比如下面这张图\n便是依据下列的DSL生成的\nst=\u003estart: Start op=\u003eoperation: Your Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop flowchart.js生成的是SVG格式的图片文件，但SVG文件不方便嵌入到Markdown或Confluence的文档中，因此我会把它转换为PNG格式。折腾了一番后，发现在Mac上最靠谱的方法，是将SVG文件嵌入一个HTML文档，再用浏览器打开这个HTML，然后复制图片到预览程序上保存下来。",
    "tags": [],
    "title": "程序员特有的画图方式——语绘工具小入门",
    "uri": "/normal/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%89%B9%E6%9C%89%E7%9A%84%E7%94%BB%E5%9B%BE%E6%96%B9%E5%BC%8F%E8%AF%AD%E7%BB%98%E5%B7%A5%E5%85%B7%E5%B0%8F%E5%85%A5%E9%97%A8/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "小打小闹写点bug",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
