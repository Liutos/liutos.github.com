<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">







<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://liutos.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

<script data-ad-client="ca-pub-4199841931601311" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta name="description" content="记录编程生涯的大大小小的事情">
<meta name="keywords" content="emacs,lisp,programming">
<meta property="og:type" content="website">
<meta property="og:title" content="小打小闹写点bug">
<meta property="og:url" content="https://liutos.github.io/page/2/index.html">
<meta property="og:site_name" content="小打小闹写点bug">
<meta property="og:description" content="记录编程生涯的大大小小的事情">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小打小闹写点bug">
<meta name="twitter:description" content="记录编程生涯的大大小小的事情">

<link rel="canonical" href="https://liutos.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>小打小闹写点bug</title>
  
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-94082039-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-94082039-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext');loadCss('//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小打小闹写点bug</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">乍听之下，不无道理；仔细揣摩，胡说八道</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Liutos" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2021/10/06/直观地了解自己每天在吃上面的开销/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/06/直观地了解自己每天在吃上面的开销/" class="post-title-link" itemprop="url">直观地了解自己每天在吃上面的开销</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-06 22:45:06" itemprop="dateCreated datePublished" datetime="2021-10-06T22:45:06+08:00">2021-10-06</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/10/06/直观地了解自己每天在吃上面的开销/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/10/06/直观地了解自己每天在吃上面的开销/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>众所周知，</del>我用<code>Emacs</code>的<code>ledger-mode</code>来记账（参见以前的文章<a href="https://liutos.github.io/2020/03/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%AE%B0%E8%B4%A6%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94ledger%E4%B8%8Eledger-mode/">《程序员的记账工具——ledger与ledger-mode》</a>）。作为一个出色的命令行报表工具，<code>ledger</code>的命令<code>balance</code>和<code>register</code>足以涵盖大部分的使用场景：</p>
<ul>
<li><code>balance</code>可以生成所有帐号的余额的报表，用于每天与各个账户中的真实余额进行比较；</li>
<li><code>register</code>可以生成给定帐号的交易明细，用于在余额不一致时与真实账户的流水一条条核对；</li>
</ul>
<p>美中不足的是，<code>ledger</code>的报表不够直观，因为它们是冷冰冰的文字信息，而不是振奋人心的统计图形。好在，正如<code>ledger</code>不存储数据，而只是一份份<code>.ledger</code>文件中的交易记录的搬运工一样，<code>gnuplot</code>也是这样的工具——它不存储数据，它只负责将存储在文本文件的数据以图形的形态呈现出来。</p>
<h1 id="如何运用gnuplot"><a href="#如何运用gnuplot" class="headerlink" title="如何运用gnuplot"></a>如何运用<code>gnuplot</code></h1><p><code>gnuplot</code>是很容易使用的。以最简单的情况为例，首先将如下内容保存到文件<code>/tmp/data.csv</code>中</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br><span class="line">0 0</span><br><span class="line">1 1</span><br></pre></td></tr></tbody></table></figure>
<p>然后在命令行中启动<code>gnuplot</code>，进入它的 REPL 中，并执行如下命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot "/tmp/data.csv"</span><br></pre></td></tr></tbody></table></figure>
<p>即可得到这三组数据的展示</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20211006/gnuplot绘图效果初识.jpg" alt=""></p>
<p>三组数据分别是坐标为<code>(-1, -1)</code>、<code>(0, 0)</code>，以及<code>(1, 1)</code>的点。</p>
<p>因此要让<code>gnuplot</code>绘制开销的图形，首先就是从账本中提取出要绘制的数据，再决定如何用<code>gnuplot</code>绘制即可。</p>
<h2 id="用ledger提取开销记录"><a href="#用ledger提取开销记录" class="headerlink" title="用ledger提取开销记录"></a>用<code>ledger</code>提取开销记录</h2><p>尽管<code>ledger</code>的子命令<code>register</code>可以打印出给定帐号的交易明细，但此处更适合使用<code>csv</code>子命令。例如，下列的命令可以将最早的10条、吃的方面的支出记录，都以 CSV 格式打印出来</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  Accounting ledger --anon --head 10 -f 2021.ledger csv 'Expense:Food'</span><br><span class="line">"2019/09/10","","32034acc","efe2a5b9:c720f278:58a3cd91:0dc07b7b","A","20","",""</span><br><span class="line">"2019/09/11","","a61b6164","5d45e249:fe84ca06:778d1855:daf61ede","A","5","",""</span><br><span class="line">"2019/09/11","","674ec19f","5d018df1:ebf020db:29d43aba:d0c84127","A","15","",""</span><br><span class="line">"2019/09/11","","e55ff018","370ca545:7d3aa2d0:86f5f330:1379261b","A","20","",""</span><br><span class="line">"2019/09/12","","f6aa675c","08315491:4c8f1ee7:5eeaddf3:f879914e","A","10.5","",""</span><br><span class="line">"2019/09/12","","139b790f","a137e4ee:9bc8ee49:7d7ccd8b:472d6007","A","23.9","",""</span><br><span class="line">"2019/09/12","","b24b716d","de348971:5364622c:b2144d94:01e74ff3","A","148","",""</span><br><span class="line">"2019/09/13","","e7c066fa","b418a3b2:a3e21e87:a32ee8ac:8716a847","A","3","",""</span><br><span class="line">"2019/09/13","","9eb044fe","702a13e9:3de7f1bd:9b20a278:1d20668d","A","24","",""</span><br><span class="line">"2019/09/13","","ba301270","d2b7eeb3:381f9473:54f86a33:391a8662","A","36","",""</span><br></pre></td></tr></tbody></table></figure>
<p><code>--anon</code>选项可以将交易明细中的敏感信息（如收款方、帐号）等匿名处理。</p>
<p>尽管<code>ledger</code>打印出的内容有很多列，但只有第一列的日期，以及第六列的金额是我所需要的。同时，由于一天中可能会有多次吃的方面的开销，因此同一天的交易也会有多笔，在绘图之前，需要将同一天之中的开销累加起来，只留下一个数字。这两个需求，都可以用<code>csvsql</code>来满足。</p>
<h2 id="用csvsql聚合数据"><a href="#用csvsql聚合数据" class="headerlink" title="用csvsql聚合数据"></a>用<code>csvsql</code>聚合数据</h2><p>以前文中的10条记录为例，用如下的命令可以将它们按天聚合在一起</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledger --anon --head 10 -f 2021.ledger csv 'Expense:Food' | csvsql -H --query 'SELECT `a`, SUM(`f`) FROM `expense` GROUP BY `a` ORDER BY `a` ASC' --tables 'expense'</span><br></pre></td></tr></tbody></table></figure>
<p>其中：</p>
<ul>
<li>选项<code>-H</code>让<code>csvsql</code>知道从管道中输入的数据没有标题行。后续处理时，<code>csvsql</code>会默认使用<code>a</code>、<code>b</code>、<code>c</code>等作为列名；</li>
<li>选项<code>--query</code>用于提交要执行的 SQL 语句；</li>
<li>选项<code>--tables</code>用于指定表的名字，这样在<code>--query</code>中才能用 SQL 对其进行处理；</li>
</ul>
<p>结果如下</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Accounting ledger --anon --head 10 -f 2021.ledger csv 'Expense:Food' | csvsql -H --query 'SELECT `a`, SUM(`f`) FROM `expense` GROUP BY `a` ORDER BY `a` ASC' --tables 'expense'</span><br><span class="line">a,SUM(`f`)</span><br><span class="line">2019-09-10,20</span><br><span class="line">2019-09-11,40</span><br><span class="line">2019-09-12,182.4</span><br><span class="line">2019-09-13,63</span><br></pre></td></tr></tbody></table></figure>
<h2 id="用gnuplot读取数据并绘图"><a href="#用gnuplot读取数据并绘图" class="headerlink" title="用gnuplot读取数据并绘图"></a>用<code>gnuplot</code>读取数据并绘图</h2><p>用重定向将<code>csvsql</code>的输出结果保存到文件<code>/tmp/data.csv</code>中，然后就可以用<code>gnuplot</code>将它们画出来</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  Accounting ledger --anon --head 10 -f 2021.ledger csv 'Expense:Food' | csvsql -H --query 'SELECT `a`, SUM(`f`) FROM `expense` GROUP BY `a` ORDER BY `a` ASC' --tables 'expense' | tail -n '+2' &gt; /tmp/data.csv</span><br><span class="line">➜  Accounting cat /tmp/plot_expense.gplot</span><br><span class="line">set format x '%y-%m-%d'</span><br><span class="line">set style data boxes</span><br><span class="line">set terminal png font '/System/Library/Fonts/Hiragino Sans GB.ttc'</span><br><span class="line">set title '吃的开销'</span><br><span class="line">set output '/tmp/xyz.png'</span><br><span class="line">set timefmt '%Y-%m-%d'</span><br><span class="line">set xdata time</span><br><span class="line">set xlabel '日期'</span><br><span class="line">set xrange ['2019-09-10':'2019-09-13']</span><br><span class="line">set ylabel '金额(¥)'</span><br><span class="line">set yrange [0:200]</span><br><span class="line">set datafile separator comma</span><br><span class="line">plot '/tmp/data.csv' using 1:2</span><br><span class="line">➜  Accounting gnuplot /tmp/plot_expense.gplot</span><br></pre></td></tr></tbody></table></figure>
<p>生成的图片文件<code>/tmp/xyz.png</code>如下</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20211006/xyz_bak.png" alt=""></p>
<p>在脚本文件<code>/tmp/plot_expense.gplot</code>中用到的命令都可以通过<code>gnuplot</code>的<a href="http://www.gnuplot.info/docs_5.4/Gnuplot_5_4.pdf" target="_blank" rel="noopener">在线手册</a>查阅到：</p>
<ul>
<li><code>set format</code>命令用于设置坐标轴的刻度的格式。<code>set format x "%y-%m-%d"</code>意味着设置 X 轴的刻度为形如<code>19-09-10</code>的格式；</li>
<li><code>set style data</code>命令设置数据的绘制风格。<code>set style data box</code>表示采用空心柱状图；</li>
<li><code>set terminal</code>命令用于告诉<code>gnuplot</code>该生成什么样的输出。<code>set terminal png font '/System/Library/Fonts/Hiragino Sans GB.ttc'</code>表示输出结果为 PNG 格式的图片，并且采用给定的字体；</li>
<li><code>set title</code>命令控制输出结果顶部中间位置的标题文案；</li>
<li><code>set output</code>命令用于将原本输出到屏幕上的内容重定向到文件中；</li>
<li><code>set timefmt</code>命令用于指定输入的日期时间数据的格式。<code>set timefmt '%Y-%m-%d'</code>意味着输入的日期时间数据的为形如<code>2019-09-10</code>的格式；</li>
<li><code>set xdata</code>命令控制<code>gnuplot</code>如何理解属于 X 轴的数据。<code>set xdata time</code>表示 X 轴上的均为时间型数据；</li>
<li><code>set xlabel</code>命令控制 X 轴的含义的文案。<code>set ylabel</code>与其类似，只是作用在 Y 轴上；</li>
<li><code>set xrange</code>命令控制<code>gnuplot</code>所绘制的图形中 X 轴上的展示范围；</li>
<li><code>set datafile separator</code>命令控制<code>gnuplot</code>读取数据文件时各列间的分隔符，<code>comma</code>表示分隔符为逗号。</li>
</ul>
<h2 id="想要按周统计怎么办"><a href="#想要按周统计怎么办" class="headerlink" title="想要按周统计怎么办"></a>想要按周统计怎么办</h2><p>假设我要查看的是2021年每一周在吃的方面的总开支，那么需要在<code>csvsql</code>中将数据按所处的是第几周进行聚合</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  Accounting ledger -b '2021-01-01' -f 2021.ledger csv 'Expense:Food' | csvsql -H --query 'SELECT strftime("%W", `a`) AS `week`, SUM(`f`) FROM `expense` GROUP BY `week` ORDER BY `a` ASC' --tables 'expense' | tail -n '+2' &gt; /tmp/expense_dow.csv</span><br><span class="line">➜  Accounting head /tmp/expense_dow.csv</span><br><span class="line">00,633.6</span><br><span class="line">01,437.3</span><br><span class="line">02,337.5</span><br><span class="line">03,428.4</span><br><span class="line">04,191.5</span><br><span class="line">05,330.4</span><br><span class="line">06,154.6</span><br><span class="line">07,621.4</span><br><span class="line">08,485.6</span><br><span class="line">09,375.73</span><br></pre></td></tr></tbody></table></figure>
<p>同时也需要调整<code>gnuplot</code>的脚本</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set terminal png font '/System/Library/Fonts/Hiragino Sans GB.ttc'</span><br><span class="line">set title '吃的开销'</span><br><span class="line">set output '/tmp/xyz2.png'</span><br><span class="line">set xlabel '第几周'</span><br><span class="line">set xrange [0:54]</span><br><span class="line">set ylabel '金额(¥)'</span><br><span class="line">set yrange [0:1000]</span><br><span class="line">set datafile separator comma</span><br><span class="line">plot '/tmp/expense_dow.csv' using 1:2 with lines</span><br></pre></td></tr></tbody></table></figure>
<p>结果如下</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20211006/xyz2.png" alt=""></p>
<h2 id="想要同时查看两年的图形怎么办"><a href="#想要同时查看两年的图形怎么办" class="headerlink" title="想要同时查看两年的图形怎么办"></a>想要同时查看两年的图形怎么办</h2><p><code>gnuplot</code>支持同时绘制多条曲线，只要使用数据文件中不同的列作为纵坐标即可。假设我要对比的是2020年和2021年，那么先分别统计两年的开支到不同的文件中</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Accounting ledger -b '2020-01-01' -e '2021-01-01' -f 2021.ledger csv 'Expense:Food' | csvsql -H --query 'SELECT strftime("%W", `a`) AS `week`, SUM(`f`) FROM `expense` GROUP BY `week` ORDER BY `a` ASC' --tables 'expense' | tail -n '+2' &gt; /tmp/expense_2020.csv</span><br><span class="line">➜  Accounting ledger -b '2021-01-01' -f 2021.ledger csv 'Expense:Food' | csvsql -H --query 'SELECT strftime("%W", `a`) AS `week`, SUM(`f`) FROM `expense` GROUP BY `week` ORDER BY `a` ASC' --tables 'expense' | tail -n '+2' &gt; /tmp/expense_2021.csv</span><br></pre></td></tr></tbody></table></figure>
<p>再将处于同一周的数据合并在一起</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Accounting csvjoin -H -c a /tmp/expense_2020.csv /tmp/expense_2021.csv | tail -n '+2' &gt; /tmp/expense_2years.csv</span><br></pre></td></tr></tbody></table></figure>
<p>最后，再让<code>gnuplot</code>一次性绘制两条折线</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set terminal png font '/System/Library/Fonts/Hiragino Sans GB.ttc'</span><br><span class="line">set title '吃的开销'</span><br><span class="line">set output '/tmp/xyz2years.png'</span><br><span class="line">set xlabel '第几周'</span><br><span class="line">set xrange [0:54]</span><br><span class="line">set ylabel '金额(¥)'</span><br><span class="line">set yrange [0:1000]</span><br><span class="line">set datafile separator comma</span><br><span class="line">plot '/tmp/expense_2years.csv' using 1:2 with lines title "2020", '/tmp/expense_2years.csv' using 1:3 with lines title "2021"</span><br></pre></td></tr></tbody></table></figure>
<p>结果如下</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20211006/xyz2years.png" alt=""></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实仍然是非常不直观的，因为最终生成的是一张静态的图片，并不能做到将鼠标挪到曲线上时就给出所在位置的纵坐标的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2021/09/04/git-log很好，你也可以写一个/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/04/git-log很好，你也可以写一个/" class="post-title-link" itemprop="url">git-log很好，你也可以写一个</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-04 17:29:17" itemprop="dateCreated datePublished" datetime="2021-09-04T17:29:17+08:00">2021-09-04</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/09/04/git-log很好，你也可以写一个/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/09/04/git-log很好，你也可以写一个/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>作为一个天天都在用的工具，各位同行想必都非常熟悉 Git 的基本用法，例如：</p>
<ul>
<li>用<code>git-blame</code>找出某一行 bug 是哪一位同事引入的，由他背锅；</li>
<li>用<code>git-merge</code>把别人的代码合进自己完美无瑕的分支中，然后发现单元测试无法跑通；</li>
<li>用<code>git-push -f</code>把团队里其他人的提交通通覆盖掉。</li>
</ul>
<p>除此之外，Git 其实还是一个带版本功能的键值数据库：</p>
<ul>
<li>所有提交的内容都存储在目录<code>.git/objects/</code>下；</li>
<li>有存储文件内容的<code>blob</code>对象、存储文件元数据的<code>tree</code>对象，还有存储提交记录的<code>commit</code>对象等；</li>
<li>Git 提供了键值风格的读写命令<code>git-cat-file</code>和<code>git-hash-object</code>。</li>
</ul>
<p>读过我以前的文章<a href="https://liutos.github.io/2019/12/21/%E5%BD%93%E6%88%91%E4%BB%ACgit-merge%E7%9A%84%E6%97%B6%E5%80%99%E5%88%B0%E5%BA%95%E5%9C%A8merge%E4%BB%80%E4%B9%88/">《当我们git merge的时候到底在merge什么》</a>的朋友们应该都知道，如果一次合并不是<code>fast-forward</code>的，那么会产生一个新的<code>commit</code>类型的对象，并且它有两个父级<code>commit</code>对象。以知名的 Go 语言 Web 框架<code>gin</code>的仓库为例，它的哈希值为<code>e38955615a14e567811e390c87afe705df957f3a</code>的提交是一次合并产生的，这个提交的内容中有两行<code>parent</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  gin git:(master) git cat-file -p 'e38955615a14e567811e390c87afe705df957f3a'</span><br><span class="line">tree 93e5046e502847a6355ed26223a902b4de2de7c7</span><br><span class="line">parent ad087650e9881c93a19fd8db75a86968aa998cac</span><br><span class="line">parent ce26751a5a3ed13e9a6aa010d9a7fa767de91b8c</span><br><span class="line">author Javier Provecho Fernandez &lt;javiertitan@gmail.com&gt; 1499534953 +0200</span><br><span class="line">committer Javier Provecho Fernandez &lt;javiertitan@gmail.com&gt; 1499535020 +0200</span><br><span class="line"></span><br><span class="line">Merge pull request #520 from 178inaba/travis-import_path</span><br></pre></td></tr></tbody></table></figure>
<p>通过一个提交的<code>parent</code>属性，所有的提交对象组成了一个有向无环图。但聪明的你应该发现了，<code>git-log</code>的输出结果是线性的，所以 Git 用到了某种图的遍历算法。</p>
<p>查阅<code>man git-log</code>，可以在<code>Commit Ordering</code>一节中看到</p>
<blockquote>
<p>By default, the commits are shown in reverse chronological order.</p>
</blockquote>
<p>聪明的你想必已经知道该如何实现这个图的遍历算法了。</p>
<h1 id="自己动手写一个git-log"><a href="#自己动手写一个git-log" class="headerlink" title="自己动手写一个git-log"></a>自己动手写一个<code>git-log</code></h1><h2 id="解析commit对象"><a href="#解析commit对象" class="headerlink" title="解析commit对象"></a>解析<code>commit</code>对象</h2><p>要想以正确的顺序打印<code>commit</code>对象的信息，得先解析它。我们不需要从零开始自己打开文件、读取字节流，以及解压文件内容，只需要像上文那样调用<code>git-cat-file</code>即可。<code>git-cat-file</code>打印的内容中，有一些是需要提取备用的：</p>
<ul>
<li>以<code>parent</code>开头的行。这一行的哈希值要用于定位到有向无环图中的一个节点；</li>
<li>以<code>committer</code>开头的行。这一行的 UNIX 时间戳将会作为决定谁是“下一个节点”的排序依据。</li>
</ul>
<p>可以随手写一个 Python 中的类来解析一个<code>commit</code>对象</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitObject</span>:</span></span><br><span class="line">    <span class="string">"""一个Git中的commit类型的对象解析后的结果。"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *, commit_id: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.commit_id = commit_id</span><br><span class="line"></span><br><span class="line">        file_content = self._cat_file(commit_id)</span><br><span class="line">        self.parents = self._parse_parents(file_content)</span><br><span class="line">        self.timestamp = self._parse_commit_timestamp(file_content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cat_file</span><span class="params">(self, commit_id: str)</span> -&gt; str:</span></span><br><span class="line">        cmd = [<span class="string">'git'</span>, <span class="string">'cat-file'</span>, <span class="string">'-p'</span>, commit_id]</span><br><span class="line">        <span class="keyword">return</span> subprocess.check_output(cmd).decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse_commit_timestamp</span><span class="params">(self, file_content: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""解析出提交的UNIX时间戳。"""</span></span><br><span class="line">        lines = file_content.split(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">'committer '</span>):</span><br><span class="line">                m = re.search(<span class="string">'committer .+ &lt;[^ ]+&gt; ([0-9]+)'</span>, line.strip())</span><br><span class="line">                <span class="keyword">return</span> int(m.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse_parents</span><span class="params">(self, file_content: str)</span> -&gt; List[str]:</span></span><br><span class="line">        lines = file_content.split(<span class="string">'\n'</span>)</span><br><span class="line">        parents: List[str] = []</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> line.startswith(<span class="string">'parent '</span>):</span><br><span class="line">                m = re.search(<span class="string">'parent (.*)'</span>, line.strip())</span><br><span class="line">                parent_id = m.group(<span class="number">1</span>)</span><br><span class="line">                parents.append(parent_id)</span><br><span class="line">        <span class="keyword">return</span> parents</span><br></pre></td></tr></tbody></table></figure>
<h2 id="遍历commit组成的有向无环图——大根堆"><a href="#遍历commit组成的有向无环图——大根堆" class="headerlink" title="遍历commit组成的有向无环图——大根堆"></a>遍历<code>commit</code>组成的有向无环图——大根堆</h2><p>恭喜你，你学过的数据结构可以派上用场了。</p>
<p>假设用上面的类<code>CommitObject</code>解析了<code>gin</code>中哈希值为<code>e38955615a14e567811e390c87afe705df957f3a</code>的提交，那么它的<code>parents</code>属性中会有两个字符串：</p>
<ul>
<li><code>ad087650e9881c93a19fd8db75a86968aa998cac</code>；</li>
<li><code>ce26751a5a3ed13e9a6aa010d9a7fa767de91b8c</code>。</li>
</ul>
<p>其中：</p>
<ul>
<li>哈希值为<code>ad087650e9881c93a19fd8db75a86968aa998cac</code>的提交的时间为<code>Sat Jul 8 12:31:44</code>；</li>
<li>哈希值为<code>ce26751a5a3ed13e9a6aa010d9a7fa767de91b8c</code>的提交时间为<code>Jan 28 02:32:44</code>。</li>
</ul>
<p>显然，按照反转的时间先后顺序（<code>reverse chronological</code>）打印日志的话，下一个打印的节点应当是是<code>ad087650e9881c93a19fd8db75a86968aa998cac</code>——用<code>git-log</code>命令可以确认这一点。</p>
<p>打印完<code>ad087650e9881c93a19fd8db75a86968aa998cac</code>之后，又要从它的父级提交和<code>ce26751a5a3ed13e9a6aa010d9a7fa767de91b8c</code>中，挑选出下一个要打印的提交对象。显然，这是一个循环往复的过程：</p>
<ol>
<li>从待打印的<code>commit</code>对象中，找出提交时间戳最大的一个；</li>
<li>打印它的消息；</li>
<li>将<code>commit</code>的所有父级提交加入到待打印的对象池中，回到第1个步骤；</li>
</ol>
<p>这个过程一直持续到没有待打印的<code>commit</code>对象为止，而所有待打印的<code>commit</code>对象组成了一个优先级队列——可以用一个大根堆来实现。</p>
<p>然而，我并不打算在这短短的演示当中真的去实现一个堆数据结构——我用插入排序来代替它。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGitLogPrinter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *, commit_id: str, n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.commits: List[CommitObject] = []</span><br><span class="line">        self.times = n</span><br><span class="line"></span><br><span class="line">        commit = CommitObject(commit_id=commit_id)</span><br><span class="line">        self._enqueue(commit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(self.commits) &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; self.times:</span><br><span class="line">            commit = self.commits.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> parent_id <span class="keyword">in</span> commit.parents:</span><br><span class="line">                parent = CommitObject(commit_id=parent_id)</span><br><span class="line">                self._enqueue(parent)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'{} {}'</span>.format(commit.commit_id, commit.timestamp))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_enqueue</span><span class="params">(self, commit: CommitObject)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> comm <span class="keyword">in</span> self.commits:</span><br><span class="line">            <span class="keyword">if</span> commit.commit_id == comm.commit_id:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 插入排序，先找到一个待插入的下标，然后将从i到最后一个元素都往尾部移动，再将新节点插入下标i的位置。</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(self.commits):</span><br><span class="line">            <span class="keyword">if</span> commit.timestamp &gt; self.commits[i].timestamp:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        self.commits = self.commits[<span class="number">0</span>:i] + [commit] + self.commits[i:]</span><br></pre></td></tr></tbody></table></figure>
<p>最后再提供一个启动函数就可以体验一番了</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--commit-id', required=True)</span></span><br><span class="line"><span class="meta">@click.option('-n', default=20)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">(commit_id: str, n: int)</span>:</span></span><br><span class="line">    MyGitLogPrinter(commit_id=commit_id, n=n).run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="真假美猴王对比"><a href="#真假美猴王对比" class="headerlink" title="真假美猴王对比"></a>真假美猴王对比</h2><p>为了看看上面的代码所打印出来的<code>commit</code>对象的顺序是否正确，我先将它的输出内容重定向到一个文件中</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  gin git:(master) python3 ~/SourceCode/python/my_git_log/my_git_log.py --commit-id 'e38955615a14e567811e390c87afe705df957f3a' -n 20 &gt; /tmp/my_git_log.txt</span><br></pre></td></tr></tbody></table></figure>
<p>再用<code>git-log</code>以同样的格式打印出来</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  gin git:(master) git log --pretty='format:%H %ct' 'e38955615a14e567811e390c87afe705df957f3a' -n 20 &gt; /tmp/git_log.txt</span><br></pre></td></tr></tbody></table></figure>
<p>最后让<code>diff</code>命令告诉我们这两个文件是否有差异</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  gin git:(master) diff /tmp/git_log.txt /tmp/my_git_log.txt</span><br><span class="line">20c20</span><br><span class="line">&lt; 2521d8246d9813d65700650b29e278a08823e3ae 1499266911</span><br><span class="line">\ No newline at end of file</span><br><span class="line">---</span><br><span class="line"><span class="meta">&gt;</span> 2521d8246d9813d65700650b29e278a08823e3ae 1499266911</span><br></pre></td></tr></tbody></table></figure>
<p>可以说是一模一样了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2021/08/12/这方面Python还是比Lisp略逊一筹/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/这方面Python还是比Lisp略逊一筹/" class="post-title-link" itemprop="url">这方面Python还是比Lisp略逊一筹</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-12 23:08:37" itemprop="dateCreated datePublished" datetime="2021-08-12T23:08:37+08:00">2021-08-12</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/08/12/这方面Python还是比Lisp略逊一筹/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/08/12/这方面Python还是比Lisp略逊一筹/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>众所周知，Python 支持向函数传递关键字参数。比如 Python 的内置函数<code>max</code>就接受名为<code>key</code>的关键字参数，以决定如何获取比较两个参数时的依据</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max({<span class="string">'v'</span>: <span class="number">1</span>}, {<span class="string">'v'</span>: <span class="number">3</span>}, {<span class="string">'v'</span>: <span class="number">2</span>}, key=<span class="keyword">lambda</span> o: o[<span class="string">'v'</span>])  <span class="comment"># 返回值为{'v': 3}</span></span><br></pre></td></tr></tbody></table></figure>
<p>自定义一个运用了关键字参数特性的函数当然也不在话下。例如模仿一下 Common Lisp 中的函数<code>string-equal</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_equal</span><span class="params">(string1, string2, *, start1=None, end1=None, start2=None, end2=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> start1:</span><br><span class="line">        start1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> end1:</span><br><span class="line">        end1 = len(string1) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> start2:</span><br><span class="line">        start2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> end2:</span><br><span class="line">        end2 = len(string2) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> string1[start1:end1 + <span class="number">1</span>] == string2[start2:end2 + <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>再以关键字参数的形式向它传参</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_equal(<span class="string">"Hello, world!"</span>, <span class="string">"ello"</span>, start1=<span class="number">1</span>, end1=<span class="number">4</span>)  <span class="comment"># 返回值为True</span></span><br></pre></td></tr></tbody></table></figure>
<p><del>秉承 Python 之禅中的<code>There should be one-- and preferably only one --obvious way to do it.</code>理念，</del> 我甚至可以花里胡哨地、用关键字参数的语法向<code>string1</code>和<code>string2</code>传参</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string_equal(string1=<span class="string">'Goodbye, world!'</span>, string2=<span class="string">'ello'</span>)  <span class="comment"># 返回值为False</span></span><br></pre></td></tr></tbody></table></figure>
<p>但瑜不掩瑕，Python 的关键字参数也有其不足。</p>
<h1 id="Python-的不足"><a href="#Python-的不足" class="headerlink" title="Python 的不足"></a>Python 的不足</h1><p>Python 的关键字参数特性的缺点在于，同一个参数无法同时以：</p>
<ol>
<li>具有自身的参数名，以及；</li>
<li>可以从<code>**kwargs</code>中取得，</li>
</ol>
<p>两种形态存在于参数列表中。</p>
<p>举个例子，我们都知道 Python 有一个知名的第三方库叫做 requests，提供了<del>用于开发爬虫牢底坐穿的</del>发起 HTTP 请求的功能。它的类<code>requests.Session</code>的实例方法<code>request</code>有着让人忍不住运用 Long Parameter List 对其重构的、长达 16 个参数的参数列表。（你可以移步<a href="https://docs.python-requests.org/en/latest/api/#requests.Session.request" target="_blank" rel="noopener"><code>request</code>方法的文档</a>观摩）</p>
<p>为了便于使用，requests 的作者贴心地提供了<code>requests.request</code>，这样只需要一次简单的函数调用即可</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.request(<span class="string">'GET'</span>, <span class="string">'http://example.com'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><code>requests.request</code>函数支持与<code>requests.Session#request</code>（请允许我借用 Ruby 对于实例方法的写法）相同的参数列表，这一切都是通过在参数列表中声明<code>**kwargs</code>变量，并在函数体中用相同的语法向后者传参来实现的。（你可以移步<a href="https://docs.python-requests.org/en/latest/_modules/requests/api/#request" target="_blank" rel="noopener">request 函数的源代码</a>观摩）</p>
<p>这样的缺陷在于，<code>requests.request</code>函数的参数列表丢失了大量的信息。要想知道使用者能往<code>kwargs</code>中传入什么参数，必须：</p>
<ol>
<li>先知道<code>requests.request</code>是如何往<code>requests.Session#request</code>中传参的——将<code>kwargs</code>完全展开传入是最简单的情况；</li>
<li>再查看<code>requests.Session#request</code>的参数列表中排除掉<code>method</code>和<code>url</code>的部分剩下哪些参数。</li>
</ol>
<p>如果想在<code>requests.request</code>的参数列表中使用参数自身的名字（例如<code>params</code>、<code>data</code>、<code>json</code>等），那么调用<code>requests.Session#request</code>则变得繁琐起来，不得不写成</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> sessions.Session() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">return</span> session.request(method=method, url=url, params=params, data=data, json=data, **kwargs)</span><br></pre></td></tr></tbody></table></figure>
<p>的形式——果然人类的本质是复读机。</p>
<p>一个优雅的解决方案，可以参考隔壁的 Common Lisp。</p>
<h1 id="Common-Lisp-的优越性"><a href="#Common-Lisp-的优越性" class="headerlink" title="Common Lisp 的优越性"></a>Common Lisp 的优越性</h1><p>Common Lisp 第一次面世是在1984年，比 Python 的1991年要足足早了7年。但据悉，Python 的关键字参数特性借鉴自 Modula-3，而不是<del>万物起源的</del> Lisp。Common Lisp 中的关键字参数特性与 Python 有诸多不同。例如，根据 Python 官方手册中的说法，<code>**kwargs</code>中只有多出来的关键字参数</p>
<blockquote>
<p>If the form “**identifier” is present, it is initialized to a new ordered mapping receiving any excess keyword arguments</p>
</blockquote>
<p>而在 Common Lisp 中，与<code>**kwargs</code>对应的是<code>&amp;rest args</code>，它必须放置在关键字参数之前（即左边），并且根据 CLHS 中<a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/03_dac.htm" target="_blank" rel="noopener">《A specifier for a rest parameter》</a>的说法，<code>args</code>中含有所有未经处理的参数——也包含了位于其后的关键字参数</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobar (<span class="name">&amp;rest</span> args <span class="symbol">&amp;key</span> k1 k2)</span><br><span class="line">  (<span class="name">list</span> args k1 k2))</span><br><span class="line"></span><br><span class="line">(<span class="name">foobar</span> <span class="symbol">:k1</span> <span class="number">1</span> <span class="symbol">:k2</span> <span class="number">3</span>)  <span class="comment">;; 返回值为((:K1 1 :K2 3) 1 3)</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果我还有另一个函数与<code>foobar</code>有着相似的参数列表，那么也可以轻松将所有参数传递给它</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobaz (<span class="name">a</span> <span class="symbol">&amp;rest</span> args <span class="symbol">&amp;key</span> k1 k2)</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> k1 k2))</span><br><span class="line">  (<span class="name">cons</span> a</span><br><span class="line">        (<span class="name">apply</span> #'foobar args)))</span><br><span class="line"></span><br><span class="line">(<span class="name">foobaz</span> <span class="number">1</span> <span class="symbol">:k1</span> <span class="number">2</span> <span class="symbol">:k2</span> <span class="number">3</span>)  <span class="comment">;; 返回值为(1 (:K1 2 :K2 3) 2 3)</span></span><br></pre></td></tr></tbody></table></figure>
<p>甚至于，即使在<code>foobaz</code>中支持的关键字参数比<code>foobar</code>要多，也能轻松地处理，因为 Common Lisp 支持向被调用的函数传入一个特殊的关键字参数<code>:allow-other-keys</code>即可</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobaz (<span class="name">a</span> <span class="symbol">&amp;rest</span> args <span class="symbol">&amp;key</span> k1 k2 my-key)</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> k1 k2))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"my-key is ~S~%"</span> my-key)</span><br><span class="line">  (<span class="name">cons</span> a</span><br><span class="line">        (<span class="name">apply</span> #'foobar <span class="symbol">:allow-other-keys</span> <span class="literal">t</span> args)))</span><br><span class="line"></span><br><span class="line">(<span class="name">foobaz</span> <span class="number">1</span> <span class="symbol">:k1</span> <span class="number">2</span> <span class="symbol">:k2</span> <span class="number">3</span> <span class="symbol">:my-key</span> <span class="number">4</span>)  <span class="comment">;; 打印my-key is 4，并返回(1 (:ALLOW-OTHER-KEYS T :K1 2 :K2 3 :MY-KEY 4) 2 3)</span></span><br></pre></td></tr></tbody></table></figure>
<p>回到 HTTP 客户端的例子。在 Common Lisp 中我一般用<a href="https://edicl.github.io/drakma/" target="_blank" rel="noopener">drakma</a>这个第三方库来发起 HTTP 请求，它导出了一个<code>http-request</code>函数，用法与<code>requests.request</code>差不多</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">drakma</span><span class="symbol">:http-request</span> <span class="string">"http://example.com"</span> <span class="symbol">:method</span> <span class="symbol">:get</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>如果我想要基于它来封装一个便捷地发出 GET 请求的函数<code>http-get</code>的话，可以这样写</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> http-get (<span class="name">uri</span> <span class="symbol">&amp;rest</span> args)</span><br><span class="line">  (<span class="name">apply</span> #'drakma<span class="symbol">:http-request</span> uri <span class="symbol">:method</span> <span class="symbol">:get</span> args))</span><br></pre></td></tr></tbody></table></figure>
<p>如果我希望在<code>http-get</code>的参数列表中直接暴露出一部分<code>http-request</code>支持的关键字参数的话，可以这样写</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> http-get (<span class="name">uri</span> <span class="symbol">&amp;rest</span> args <span class="symbol">&amp;key</span> content)</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> content))</span><br><span class="line">  (<span class="name">apply</span> #'drakma<span class="symbol">:http-request</span> uri <span class="symbol">:method</span> <span class="symbol">:get</span> args))</span><br></pre></td></tr></tbody></table></figure>
<p>更进一步，如果我想在<code>http-get</code>中支持解析<code>Content-Type</code>为<code>application/json</code>的响应结果的话，还可以这样写</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">ql</span><span class="symbol">:quickload</span> 'jonathan)</span><br><span class="line">(<span class="name">ql</span><span class="symbol">:quickload</span> 'str)</span><br><span class="line">(<span class="name">defun</span> http-get (<span class="name">uri</span> <span class="symbol">&amp;rest</span> args <span class="symbol">&amp;key</span> content (<span class="name">decode-json</span> <span class="literal">t</span>))</span><br><span class="line">  <span class="comment">;; http-request并不支持decode-json这个参数，但依然可以将整个args传给它。</span></span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> content))</span><br><span class="line">  (<span class="name">multiple-value-bind</span> (<span class="name">bytes</span> code headers)</span><br><span class="line">      (<span class="name">apply</span> #'drakma<span class="symbol">:http-request</span> uri</span><br><span class="line">             <span class="symbol">:allow-other-keys</span> <span class="literal">t</span></span><br><span class="line">             <span class="symbol">:method</span> <span class="symbol">:get</span></span><br><span class="line">             args)</span><br><span class="line">    (<span class="name">declare</span> (<span class="name">ignorable</span> code))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">content-type</span> (<span class="name">cdr</span> (<span class="name">assoc</span> <span class="symbol">:content-type</span> headers)))</span><br><span class="line">          (<span class="name">text</span> (<span class="name">flexi-streams</span><span class="symbol">:octets-to-string</span> bytes)))</span><br><span class="line">      (<span class="name">if</span> (<span class="name">and</span> decode-json</span><br><span class="line">               (<span class="name">str</span><span class="symbol">:starts-with-p</span> <span class="string">"application/json"</span> content-type))</span><br><span class="line">          (<span class="name">jonathan</span><span class="symbol">:parse</span> text)</span><br><span class="line">          text))))</span><br></pre></td></tr></tbody></table></figure>
<p>不愧是<del>Dio</del> Common Lisp，轻易就做到了我们做不到的事情。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>曾几何时，Python 程序员还会津津乐道于 Python 之禅中的<code>There should be one-- and preferably only one --obvious way to do it.</code>，但其实 Python 光是在定义一个函数的参数方面就有五花八门的写法了。甚至在写这篇文章的过程中，我才知道原来 Python 的参数列表中可以通过写上<code>/</code>来使其左侧的参数都成为 positional-only 的参数。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(a, b)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">(a, /, b)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">foo2(a=<span class="number">1</span>, b=<span class="number">2</span>)  <span class="comment"># 会抛出异常，因为a只能按位置来传参。</span></span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2021/08/02/屠龙术——如何运用整洁架构/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/02/屠龙术——如何运用整洁架构/" class="post-title-link" itemprop="url">屠龙术——如何运用整洁架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-08-02 23:13:45 / 修改时间：23:13:46" itemprop="dateCreated datePublished" datetime="2021-08-02T23:13:45+08:00">2021-08-02</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/08/02/屠龙术——如何运用整洁架构/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/08/02/屠龙术——如何运用整洁架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>或许是为了显摆，也或许是虚心学习，总之我在去年年初花了大约两个月读完了<a href="https://book.douban.com/subject/30333919/" target="_blank" rel="noopener">《架构整洁之道》</a>。但读过后也仅仅就是读了而已，尽管书中描绘了一个名为整洁架构的软件架构，但我并没有理解并应用到实际的开发中去。书中的诸多理念最终都蛰伏在了我的脑海深处。</p>
<p>今年年初的时候我换了工作。新的单位给每人都配备了办公用的电脑，从此我也不用背着2公斤重的MacBook Pro通勤了。美中不足的地方是，我和<a href="https://github.com/Liutos/cuckoo" target="_blank" rel="noopener">cuckoo</a>之间的联系被斩断了，因为<code>cuckoo</code>是个单机程序，要在私人电脑和办公电脑上各装一份太不方便了。于是乎，我决定开两个新的项目，将<code>cuckoo</code>拆分为客户端和服务端两部分。</p>
<p>正好，这给了我在实际的项目中践行整洁架构的机会。</p>
<h2 id="什么是整洁架构"><a href="#什么是整洁架构" class="headerlink" title="什么是整洁架构"></a>什么是整洁架构</h2><p>不像数学领域的概念往往有一个精确的定义，书中甚至没有道出整洁架构是什么。相对的，只有一副引人入胜的架构示意图（图片摘自作者博客的<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">这篇文章</a>）</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210802/整洁架构.jpg" alt=""></p>
<p>在作者的<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">文章</a>中，对图中的四个层次给出了响应的解释：</p>
<!-- 对Entities的解释：Entities封装了企业范围内的业务规则。如果你没有经营一个企业，仅仅是开发一款应用，那么Entities就是应用的业务对象，它们封装了应用内最通用、上层的规则。 -->
<!-- TODO: 将几个层的名字都用一对反引号包裹起来。 -->
<ul>
<li>Entities封装了企业范围内的业务规则。如果你没有经营一个企业，仅仅是开发一款应用，那么Entities就是应用的业务对象，它们封装了应用内最通用、上层的规则。</li>
</ul>
<!-- 对Use Cases的解释：Use Cases包含了与应用相关的业务规则。它封装并实现了系统的所有用例。 -->
<ul>
<li>Use Cases包含了与应用相关的业务规则。它封装并实现了系统的所有用例。</li>
</ul>
<!-- 衍生出来的问题：何谓用例（Use Cases）？ -->
<!-- 对Interface Adapters的解释：这一层负责将最方便entities和use cases的数据转换为最方便外部系统使用的格式。在这一层以内都是抽象的，对外界诸如MVC、GUI、数据库等均是无感知的。此外，这一层也负责与外部服务通信。（可以举fledgling的repository目录下的例子） -->
<ul>
<li>这一层负责将最方便entities和use cases的数据转换为最方便外部系统使用的格式。在这一层以内都是抽象的，对外界诸如MVC、GUI、数据库等均是无感知的。此外，这一层也负责与外部服务通信。</li>
<li><code>Frameworks &amp; Drivers</code>，顾名思义，这一层包含了与框架相关的代码，或者像C语言中的<code>main</code>函数这样的入口函数代码；</li>
</ul>
<!-- 有多少层不要紧，关键在于必须遵循依赖规则：在源代码层面，总是外层的依赖于内层的。例如，nest中use_case目录下总是依赖于entity目录、infra和repository依赖于entity目录、cli和web依赖于app、infra，以及repository等“内层”目录。 -->
<h1 id="如何应用整洁架构"><a href="#如何应用整洁架构" class="headerlink" title="如何应用整洁架构"></a>如何应用整洁架构</h1><!-- 这里给出我的实践心得：实践整洁架构的项目的简介、目录结构的划分、语言特性的运用、设计模式的运用、SOLID原则的体现、与MVC相比更为清晰的边界。除了这些通用的，还有一些具体的编码细节：参数的传递方式、抽象方法对比NotImplementedError、返回值对比传入Presenter、更新资源的用例的输入定义、为什么不要防御性编程、无法隐藏的I/O、类方法对比实例方法、避免循环依赖 -->
<h2 id="实际项目的例子"><a href="#实际项目的例子" class="headerlink" title="实际项目的例子"></a>实际项目的例子</h2><p>前文提到，为了满足新需求，我需要将<a href="https://github.com/Liutos/cuckoo" target="_blank" rel="noopener">cuckoo</a>改造为C/S模型。但比起缓缓地将cuckoo拆解为两部分，我更乐于大刀阔斧地从头开发开发这两个程序，于是便诞生了：</p>
<ul>
<li>服务端程序为<a href="https://github.com/Liutos/nest" target="_blank" rel="noopener">nest</a>，负责管理任务、计划等实体对象，并提供基于HTTP协议的API；</li>
<li>客户端程序为<a href="https://github.com/Liutos/fledgling" target="_blank" rel="noopener">fledgling</a>，负责与<code>nest</code>通信，并在客户机上触发通知（如macOS的右上角弹出通知）。</li>
</ul>
<p>它们都是我依照自己对整洁架构的理解来编写的。</p>
<h2 id="从架构理念到具体决策"><a href="#从架构理念到具体决策" class="headerlink" title="从架构理念到具体决策"></a>从架构理念到具体决策</h2><p>正如<a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">REST</a>仅仅是一种软件结构风格而不是具体的设计指南一样，整洁架构也并没有规定示意图中的分层结构该如何运用一门语言的特性来实现，这需要开发者自己去摸索。下文我给出自己在<code>nest</code>和<code>fledgling</code>项目中的做法。</p>
<h3 id="如何安排代码目录结构"><a href="#如何安排代码目录结构" class="headerlink" title="如何安排代码目录结构"></a>如何安排代码目录结构</h3><p>在程序的代码结构中，最接近于架构示意图的分层架构的，当属代码仓库的目录结构了。模仿整洁架构中的四层结构，我在<code>nest</code>中也安排了相似的目录结构</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜  nest git:(master) tree -I '__pycache__' -d ./nest</span><br><span class="line">./nest</span><br><span class="line">├── app</span><br><span class="line">│&nbsp;&nbsp; ├── entity</span><br><span class="line">│&nbsp;&nbsp; └── use_case</span><br><span class="line">├── cli</span><br><span class="line">│&nbsp;&nbsp; ├── command</span><br><span class="line">│&nbsp;&nbsp; └── config</span><br><span class="line">├── infra</span><br><span class="line">├── repository</span><br><span class="line">│&nbsp;&nbsp; └── DDL</span><br><span class="line">└── web</span><br><span class="line">    ├── config</span><br><span class="line">    ├── controller</span><br><span class="line">    └── presenter</span><br><span class="line"></span><br><span class="line">13 directories</span><br></pre></td></tr></tbody></table></figure>
<h4 id="nest-app-entity-目录"><a href="#nest-app-entity-目录" class="headerlink" title="nest/app/entity/目录"></a><code>nest/app/entity/</code>目录</h4><p><code>nest/app/entity/</code>目录下的各个文件分别定义了系统中的各个实体类型</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜  nest git:(master) ls nest/app/entity</span><br><span class="line">__pycache__    certificate.py location.py    plan.py        task.py        user.py</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<ul>
<li><code>task.py</code>中定义了类<code>Task</code>，表示一个任务；</li>
<li><code>plan.py</code>中定义了类<code>Plan</code>，表示任务的一次触发计划，等等。</li>
</ul>
<p><code>entity/</code>目录下的各个文件中，还定义了管理各种实体对象生命期的仓库对象，例如：</p>
<ul>
<li><code>task.py</code>中定义了类<code>ITaskRepository</code>，它负责增（<code>add</code>方法）删（<code>clear</code>、<code>remove</code>方法）查（<code>find</code>、<code>find_by_id</code>方法）改（同样是<code>add</code>方法）任务对象；</li>
<li><code>plan.py</code>中定义了类<code>IPlanRepository</code>，同样能够增（<code>add</code>方法）删（<code>clear</code>、<code>remove</code>方法）查（<code>find_as_queue</code>、<code>find_by_id</code>、<code>find_by_task_id</code>方法）改（同样是<code>add</code>方法）计划对象，等等。</li>
</ul>
<p>实体类型都是充血模型，它们实现了系统核心的业务规则，例如：</p>
<ul>
<li>类<code>Plan</code>有方法<code>is_repeated</code>用于检查是否为重复性任务；</li>
<li>有方法<code>is_visible</code>用于检查该计划在当前时间是否可见；</li>
<li>有方法<code>rebirth</code>用于生成一个新的、下一次触发的计划，等等。</li>
</ul>
<p>这个目录下的内容相当于整洁架构中的<code>Entities</code>层。</p>
<h4 id="nest-app-use-case-目录"><a href="#nest-app-use-case-目录" class="headerlink" title="nest/app/use_case/目录"></a><code>nest/app/use_case/</code>目录</h4><p><code>nest/app/use_case/</code>目录下的各个文件分别定义了系统所提供的功能</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜  nest git:(master) ls nest/app/use_case</span><br><span class="line">__init__.py        authenticate.py    change_task.py     create_plan.py     delete_plan.py     get_location.py    get_task.py        list_plan.py       login.py           registration.py</span><br><span class="line">__pycache__        change_plan.py     create_location.py create_task.py     delete_task.py     get_plan.py        list_location.py   list_task.py       pop_plan.py</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<ul>
<li><code>authenticate.py</code>定义了系统如何认证发送当前请求的用户；</li>
<li><code>change_task.py</code>定义了系统如何修改一个任务对象，等等。</li>
</ul>
<p>每一个处于该目录下的文件，只会依赖<code>nest/app/entity/</code>中的代码，并且它们都是抽象的。例如，<code>authenticate.py</code>中的类<code>AuthenticateUseCase</code>的构造方法中，要求其：</p>
<ul>
<li>参数<code>certificate_repository</code>必须是类<code>ICertificateRepository</code>或其子类的实例；</li>
<li>参数<code>params</code>必须是类<code>IParams</code>或其子类的实例。</li>
</ul>
<p>然而<code>ICertificateRepository</code>和<code>IParams</code>其实都是抽象基类<code>ABC</code>的子类，并且它们都有被装饰器<code>abstractmethod</code>装饰的抽象方法，因此并不能直接实例化。</p>
<p>该目录相当于整洁架构中的<code>Use Cases</code>层。</p>
<h4 id="其它目录"><a href="#其它目录" class="headerlink" title="其它目录"></a>其它目录</h4><p>顾名思义，<code>cli</code>和<code>web</code>目录分别是与命令行程序、基于HTTP的API相关的代码，它们实现了处理来自命令行和HTTP协议的输入，以及打印到终端和返回HTTP响应的功能。<code>repository</code>目录下的各个文件实现了<code>entity</code>目录中各个抽象的仓库类的具体子类</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv) ➜  nest git:(master) ls nest/repository</span><br><span class="line">DDL             __init__.py     __pycache__     certificate.py  db_operation.py location.py     plan.py         task.py         user.py</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<ul>
<li><code>certificate.py</code>中实现了<code>entity/</code>目录下的同名文件中的抽象类<code>ICertificateRepository</code>——一个基于内存的子类<code>MemoryCertificateRepository</code>，以及一个基于Redis的子类<code>RedisCertificateRepository</code>；</li>
<li><code>location.py</code>中实现了<code>entity/</code>目录下的同名文件中的抽象类<code>ILocationRepository</code>——基于MySQL的子类<code>DatabaseLocationRepository</code>，等等。</li>
</ul>
<p>需要注意的是，除了<code>app</code>外的这些目录，并不能与整洁架构示意图中的外面两层严格对应起来。例如，尽管<code>cli</code>和<code>web</code>的名字一下子就让人认为它们处于<code>Frameworks &amp; Drivers</code>层，但<code>web/presenter/</code>目录下的内容其实与框架并无联系。反倒是从命名上看处于<code>Interface Adapters</code>层的<code>web/controller/</code>目录，其中的代码依赖于<code>Flask</code>框架。</p>
<h3 id="如何往Use-Cases层传入数据"><a href="#如何往Use-Cases层传入数据" class="headerlink" title="如何往Use Cases层传入数据"></a>如何往<code>Use Cases</code>层传入数据</h3><p>在鲍勃大叔的文章中，提到了关于如何在层之间传递数据的原则</p>
<blockquote>
<p>Typically the data that crosses the boundaries is simple data structures. You can use basic structs or simple Data Transfer objects if you like.  Or the data can simply be arguments in function calls. Or you can pack  it into a hashmap, or construct it into an object.</p>
</blockquote>
<p>在<code>nest/app/use_case/</code>目录下的所有用例采用的都是这里提到的<code>construct it into an object</code>的方式。以<code>create_task.py</code>为例：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IParams</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_brief</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_keywords</span><span class="params">(self)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_user_id</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>用内置模块<code>abc</code>中的抽象基类<code>ABC</code>、装饰器<code>abstractmethod</code>，以及类<code>CreateTaskUseCase</code>中的<code>assert</code>一起模拟类似Java中的<code>interface</code>的效果；</li>
<li>用方法而不是成员变量来获取不同的输入参数：<ul>
<li><code>get_brief</code>获取任务的简述；</li>
<li><code>get_keywords</code>获取关键字列表；</li>
<li><code>get_user_id</code>获取创建该任务的用户的ID。</li>
</ul>
</li>
</ul>
<p>聪明的盲生已经发现了华点：明明只需要在类<code>CreateTaskUseCase</code>的构造方法中定义<code>brief</code>、<code>keywords</code>，以及<code>user_id</code>三个参数即可，为什么要用方法这么麻烦呢？答案是因为方法更灵活。</p>
<p>当你采用构造方法参数的方案时，本质上是立了一个假设：</p>
<ol>
<li><del>在所有惯性系中，物理定律有相同的表达形式</del>先完成所有参数的获取；</li>
<li>再执行用例中的业务逻辑。</li>
</ol>
<p>如果是一个基于HTTP协议的API，那么这个假设是成立的——用户在客户端发送的HTTP请求到达服务端后，便无法再补充参数了。但有一种场景，用户能够在用例执行业务逻辑的过程中，持续地与应用交互，那便是命令行程序。</p>
<p>我在<code>fledgling</code>项目中给了一个用户在用例执行过程中，交互式地输入的例子。在文件<code>fledgling/app/use_case/delete_task.py</code>中，实现了删除指定任务的用例。它要求输入两个参数</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IParams</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_confirmation</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""获取用户是否要删除该任务的确认。"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_task_id</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>在文件<code>fledgling/cli/command/delete_task.py</code>中实现了<code>IParams</code>类的命令行形态。当没有从命令行参数中获取到任务的ID时，便会使用第三方库<code>PyInquirer</code>询问用户输入任务ID，并进一步确认</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Params</span><span class="params">(IParams)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *, task_id: Optional[int])</span>:</span></span><br><span class="line">        self.task_id = task_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_confirmation</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> self.task_id:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        questions = [</span><br><span class="line">            {</span><br><span class="line">                <span class="string">'message'</span>: <span class="string">'确定删除该任务'</span>,</span><br><span class="line">                <span class="string">'name'</span>: <span class="string">'confirmation'</span>,</span><br><span class="line">                <span class="string">'type'</span>: <span class="string">'confirm'</span>,</span><br><span class="line">            }</span><br><span class="line">        ]</span><br><span class="line">        answers = prompt(questions)</span><br><span class="line">        <span class="keyword">return</span> answers[<span class="string">'confirmation'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_task_id</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.task_id:</span><br><span class="line">            <span class="keyword">return</span> self.task_id</span><br><span class="line">        questions = [</span><br><span class="line">            {</span><br><span class="line">                <span class="string">'message'</span>: <span class="string">'输入要删除的任务的ID'</span>,</span><br><span class="line">                <span class="string">'name'</span>: <span class="string">'task_id'</span>,</span><br><span class="line">                <span class="string">'type'</span>: <span class="string">'input'</span>,</span><br><span class="line">            }</span><br><span class="line">        ]</span><br><span class="line">        answers = prompt(questions)</span><br><span class="line">        <span class="keyword">return</span> answers[<span class="string">'task_id'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>而这一切<del>煮不在乎</del><code>DeleteTaskUseCase</code>并不会感知到，它独立于用户界面。</p>
<h3 id="在哪一层维护业务规则"><a href="#在哪一层维护业务规则" class="headerlink" title="在哪一层维护业务规则"></a>在哪一层维护业务规则</h3><p>在《架构整洁之道》第20章中，鲍勃大叔给出了业务规则的定义</p>
<blockquote>
<p>Strictly speaking, business rules are rules or procedures that make or save<br>the business money. Very strictly speaking, these rules would make or save the business money, irrespective of whether they were implemented on a computer. They would make or save money even if they were executed manually.</p>
</blockquote>
<p>业务规则往往不是独立存在的，它们需要作用在一些数据上</p>
<blockquote>
<p>Critical Business Rules usually require some data to work with. For example, our loan requires a loan balance, an interest rate, and a payment schedule.</p>
</blockquote>
<p>而整洁架构中的实体就是包含了一部分业务规则及其操作的数据的对象。以<code>nest</code>中的计划实体为例，在类<code>Plan</code>中包含了几种业务规则——尽管这些规则不能为我赚钱或者省钱：</p>
<ul>
<li>一个计划的持续时长（如果有的话）不会是负的秒数——由<code>duration</code>的setter保障；</li>
<li>周期性计划必须指定周期——由<code>new</code>方法维护；</li>
<li>一个计划是重复的，当且仅当它有指定重复类型——由<code>is_repeated</code>方法维护；</li>
<li>一个计划是可见的，当且仅当它：<ul>
<li>要么没有指定可见的小时，要么当且时间处于指定的小时中，并且；</li>
<li>要么没有指定星期几可见，要么今天是指定的<code>weekday</code>——由<code>is_visible</code>方法维护。</li>
</ul>
</li>
</ul>
<p>但在整洁架构的示意图中，<code>Use Cases</code>层也是有维护规则的，它维护的是应用的业务规则（<code>Application Business Rules</code>）。与<code>Entities</code>层所维护的业务规则不同，<code>Use Cases</code>层的业务规则取决于应用提供的功能。例如，在<code>nest</code>项目修改一个计划的用例<code>ChangePlanUseCase</code>类的方法<code>run</code>中，会：</p>
<ol>
<li>检查指定的计划是否存在——显然，实体没法检查自己是否存在；</li>
<li>检查计划是否能被修改；</li>
<li>检查新的地点的ID是否指向真实存在的地点对象——显然，<code>Plan</code>对象不会去检查<code>Location</code>存在与否；</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件nest/app/use_case/change_plan.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangePlanUseCase</span>:</span></span><br><span class="line">    <span class="comment"># 省略__init__的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 省略一些无关要紧的代码</span></span><br><span class="line">        params = self.params</span><br><span class="line">        plan_id = params.get_plan_id()</span><br><span class="line">        plan = self.plan_repository.find_by_id(plan_id)</span><br><span class="line">        <span class="keyword">if</span> plan <span class="keyword">is</span> <span class="keyword">None</span>:  <span class="comment"># 上面第1点</span></span><br><span class="line">            <span class="keyword">raise</span> PlanNotFoundError(plan_id=plan_id)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> plan.is_changeable():  <span class="comment"># 上面第2点</span></span><br><span class="line">            <span class="keyword">raise</span> UnchangeableError()</span><br><span class="line"></span><br><span class="line">        found, location_id = params.get_location_id()</span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line">            <span class="keyword">if</span> location_id:</span><br><span class="line">                location = self.location_repository.get(id_=location_id)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> location:  <span class="comment"># 上面第3点</span></span><br><span class="line">                    <span class="keyword">raise</span> LocationNotFoundError(location_id=location_id)</span><br><span class="line">            plan.location_id = location_id</span><br></pre></td></tr></tbody></table></figure>
<p>聪明的你一定发现了：<code>is_changeable</code>为什么不作为<code>Enterpries Business Rules</code>，在<code>Plan</code>对象内自行检查呢？答案是因为这样写更简单。</p>
<p>试想一下，如果要让<code>Plan</code>自己禁止在<code>is_changeable</code>为<code>False</code>时被修改，那么必须：</p>
<ul>
<li>先为所有可修改的属性设置setter；</li>
<li>在每一个setter中都调用<code>is_changeable</code>进行检查。</li>
</ul>
<p>之所以要这么做，是因为一个实体对象（在这里是指<code>Plan</code>的实例对象）是外部的时间流动是无感知的。它不知道外层（此处是<code>Use Cases</code>层）会<strong>先</strong>调用哪一个方法，<strong>后</strong>调用哪一个方法。因此，要想保持“终止状态的计划不能修改”，就必须在每一处setter都检查。</p>
<p>与之相反，在用例中有编排，因此它可以感知时间的流动。用例可以让<code>Plan</code>的<code>is_changeable</code>方法在其它任何方法之前被调用，因此免除了繁琐地在每一个setter中检查<code>is_changeable</code>的必要。</p>
<h3 id="如何获取Use-Cases层的处理结果"><a href="#如何获取Use-Cases层的处理结果" class="headerlink" title="如何获取Use Cases层的处理结果"></a>如何获取<code>Use Cases</code>层的处理结果</h3><p>正如往<code>Use Cases</code>层中输入参数可以采用：</p>
<ol>
<li>直接在<code>__init__</code>中传入对应类型的参数，或；</li>
<li>在<code>__init__</code>中传入一个能根据方法提取参数的对象。</li>
</ol>
<p>两种方案一样，获取<code>Use Cases</code>层的计算结果同样有两种方案：</p>
<ol>
<li>获取<code>run</code>方法的返回值，捕捉它的异常，或；</li>
<li>在<code>__init__</code>中传入一个能够接受不同结果并处理的对象。</li>
</ol>
<p>在<code>nest</code>这样的仅仅提供HTTP API的应用中，第1种方案便已经足够了。例如，在文件<code>nest/web/controller/create_plan.py</code>中，类<code>CreatePlanUseCase</code>的<code>run</code>方法的返回值为创建的计划对象，如果<code>run</code>调用成功，这个controller会借助于<code>PlanPresenter</code>，将计划对象转换为JSON对象格式的字符串，返回给调用方；如果调用失败，那么controller中也会捕捉异常（如<code>InvalidRepeatTypeError</code>）并以另一种格式返回给调用方。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_plan</span><span class="params">(certificate_repository, repository_factory)</span>:</span></span><br><span class="line">    <span class="comment"># 省略了不必要的代码</span></span><br><span class="line">    params = HTTPParams()</span><br><span class="line">    use_case = CreatePlanUseCase(</span><br><span class="line">        location_repository=repository_factory.location(),</span><br><span class="line">        params=params,</span><br><span class="line">        plan_repository=repository_factory.plan(),</span><br><span class="line">        task_repository=repository_factory.task(),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plan = use_case.run()</span><br><span class="line">        presenter = PlanPresenter(plan=plan)</span><br><span class="line">        <span class="keyword">return</span> {  <span class="comment"># 成功的情形</span></span><br><span class="line">            <span class="string">'error'</span>: <span class="keyword">None</span>,</span><br><span class="line">            <span class="string">'result'</span>: presenter.format(),</span><br><span class="line">            <span class="string">'status'</span>: <span class="string">'success'</span>,</span><br><span class="line">        }, <span class="number">201</span></span><br><span class="line">    <span class="keyword">except</span> InvalidRepeatTypeError <span class="keyword">as</span> e:  <span class="comment"># 失败的情形</span></span><br><span class="line">        <span class="keyword">return</span> {</span><br><span class="line">            <span class="string">'error'</span>: {</span><br><span class="line">                <span class="string">'message'</span>: <span class="string">'不支持的重复类型：{}'</span>.format(e.repeat_type),</span><br><span class="line">            },</span><br><span class="line">            <span class="string">'result'</span>: <span class="keyword">None</span>,</span><br><span class="line">            <span class="string">'status'</span>: <span class="string">'failure'</span>,</span><br><span class="line">        }, <span class="number">422</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果想要更高的灵活性并且也有施展的空间，那么可以考虑第2种方案。例如<code>fledgling</code>项目中文件<code>fledgling/app/use_case/list_plan.py</code>中，就定义了一个接口<code>IPresenter</code></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPresenter</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_find_location</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_find_task</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_invalid_location</span><span class="params">(self, *, error: InvalidLocationError)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_plans</span><span class="params">(self, *, count: int, plans: List[Plan])</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>并且在用例的执行过程中，会多次向<code>self.presenter</code>传递数据</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListPlanUseCase</span>:</span></span><br><span class="line">    <span class="comment"># 省略__init__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        location_id = <span class="keyword">None</span></span><br><span class="line">        location_name = self.params.get_location_name()</span><br><span class="line">        no_location = self.params.get_no_location()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> no_location <span class="keyword">and</span> location_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            locations = self.location_repository.find(name=location_name)</span><br><span class="line">            <span class="keyword">if</span> len(locations) == <span class="number">0</span>:</span><br><span class="line">                self.presenter.on_invalid_location(error=InvalidLocationError(name=location_name))  <span class="comment"># 第1次，触发无效地点的错误</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            location_id = locations[<span class="number">0</span>].id</span><br><span class="line"></span><br><span class="line">        page = self.params.get_page()</span><br><span class="line">        per_page = self.params.get_per_page()</span><br><span class="line">        criteria = {</span><br><span class="line">            <span class="string">'page'</span>: page,</span><br><span class="line">            <span class="string">'per_page'</span>: per_page,</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> location_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            criteria[<span class="string">'location_id'</span>] = location_id</span><br><span class="line">        plans, count = self.plan_repository.list(**criteria)</span><br><span class="line">        location_ids = [plan.location_id <span class="keyword">for</span> plan <span class="keyword">in</span> plans]</span><br><span class="line">        self.presenter.on_find_location()  <span class="comment"># 第2次交互，通知presenter开始查找地点的事件</span></span><br><span class="line">        locations = self.location_repository.find(</span><br><span class="line">            ids=location_ids,</span><br><span class="line">            page=<span class="number">1</span>,</span><br><span class="line">            per_page=len(location_ids),</span><br><span class="line">        )</span><br><span class="line">        task_ids = [plan.task_id <span class="keyword">for</span> plan <span class="keyword">in</span> plans]</span><br><span class="line">        self.presenter.on_find_task()  <span class="comment"># 第3次交互，通知presenter开始查找任务的事件</span></span><br><span class="line">        tasks = self.task_repository.list(</span><br><span class="line">            page=<span class="number">1</span>,</span><br><span class="line">            per_page=len(task_ids),</span><br><span class="line">            task_ids=task_ids,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> plan <span class="keyword">in</span> plans:</span><br><span class="line">            location_id = plan.location_id</span><br><span class="line">            location = [location <span class="keyword">for</span> location <span class="keyword">in</span> locations <span class="keyword">if</span> location.id == location_id][<span class="number">0</span>]</span><br><span class="line">            plan.location = location</span><br><span class="line">            task_id = plan.task_id</span><br><span class="line">            task = [task <span class="keyword">for</span> task <span class="keyword">in</span> tasks <span class="keyword">if</span> task.id == task_id][<span class="number">0</span>]</span><br><span class="line">            plan.task = task</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第4次，也是最后一次，传入用例的处理结果</span></span><br><span class="line">        self.presenter.show_plans(</span><br><span class="line">            count=count,</span><br><span class="line">            plans=plans,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure>
<p>在构造方法中注入<code>presenter</code>的缺点在于用例的<code>run</code>方法中需要显式地<code>return</code>，否则用例会继续执行下去。</p>
<h3 id="Python语言特性的运用"><a href="#Python语言特性的运用" class="headerlink" title="Python语言特性的运用"></a>Python语言特性的运用</h3><h4 id="模拟接口——abstractmethodv-s-NotImplementedError"><a href="#模拟接口——abstractmethodv-s-NotImplementedError" class="headerlink" title="模拟接口——abstractmethodv.s.NotImplementedError"></a>模拟接口——<code>abstractmethod</code>v.s.<code>NotImplementedError</code></h4><p>整洁架构的每一层都只会依赖于内层，而内层又对外层一无所知，负责解耦两者的便是编程语言的接口特性。但Python并不像Java那般有<code>interface</code>关键字，因此我利用它的其它一系列特性来模拟出接口：</p>
<ul>
<li>用<code>class</code>代替<code>interface</code>，这些类继承自内置模块<code>abc</code>的抽象基类<code>ABC</code>；</li>
<li>除此之外，这些类中的方法还用同一模块中的<code>abstractmethod</code>装饰，使它们必须由该类的子类全部定义；</li>
<li>在使用这个接口的位置（例如<code>Use Cases</code>层）用断言<code>assert</code>约束输入参数的类型。</li>
</ul>
<p><code>nest</code>中的大部分需要接口的位置我都是用这种手法来做的，但这种方式会给编写单元测试用例带来一些不便：</p>
<ol>
<li>因为代码中用<code>assert</code>来检查参数类型，导致传入的参数只能是这个接口或其子类的实例；</li>
<li>因为接口类继承自<code>ABC</code>，所以必须定义所有被<code>abstractmethod</code>装饰的方法，否则在实例化时就会抛出异常。</li>
</ol>
<p>例如，在<code>nest</code>项目的文件<code>tests/use_case/task/test_list.py</code>中，作为白盒测试的人员，我确切地知道类<code>ListTaskUseCase</code>的<code>run</code>方法只会调用它的<code>task_repository</code>的<code>find</code>方法，但在类<code>MockTaskRepository</code>中依然不得不定义基类的每一个方法——尽管它们只有一行<code>pass</code>语句。</p>
<p>如果愿意放弃一点点的严谨性，那么可以弱化一下上面的接口方案：</p>
<ol>
<li>不使用<code>abstractmethod</code>，而是在本应为抽象方法的方法中只留下一句<code>raise NotImplementedError</code>；</li>
<li>不使用<code>assert</code>检查类型，而是在参数中写上type hint。</li>
</ol>
<p>有了第1点，那么在测试用例中就不需要为测试路径上不会调用的方法写多余的定义了。而有了第2点，也就不需要为测试路径上不会引用的属性创建对象了，大可直接传入一个<code>None</code>。选择哪一种都无妨，取决于开发者或团队的口味。</p>
<h2 id="金坷垃整洁架构的好处都有啥"><a href="#金坷垃整洁架构的好处都有啥" class="headerlink" title="金坷垃整洁架构的好处都有啥"></a><del>金坷垃</del>整洁架构的好处都有啥</h2><p>在《架构整洁之道》的第20章，作者给出了整洁架构的五种优秀特性：</p>
<ul>
<li>独立于框架。例如，我可以花不是很大的力气，将<code>nest</code>从<a href="https://flask.palletsprojects.com/en/2.0.x/" target="_blank" rel="noopener">Flask</a>迁移到<a href="http://bottlepy.org/docs/dev/" target="_blank" rel="noopener">Bottle</a>上，尽管并不会无缘无故或频繁地这么做；</li>
<li>容易测试。例如，在<code>nest</code>项目的目录<code>tests/use_case</code>下的测试用例不需要有任何外部系统的依赖就可以编写并运行；</li>
<li>独立于用户界面。例如，在<code>nest</code>项目中同一个用例<code>RegistrationUseCase</code>就有HTTP API和命令行两种用户界面：<ul>
<li>在文件<code>nest/web/controller/registration.py</code>中是HTTP API形态；</li>
<li>在文件<code>nest/cli/command/register.py</code>中则是命令行形态。</li>
</ul>
</li>
<li>独立于数据库。例如，就像更换Web框架一样，我也可以从MySQL迁移到PostgreSQL中，这对于<code>Entities</code>和<code>Use Cases</code>层的代码而言别无二致；</li>
<li>独立于外部系统。例如，在<code>fledgling</code>项目中，尽管也定义了一个接口<code>ITaskRepository</code>，但不同于<code>nest</code>中基于数据库的实现子类<code>DatabaseTaskRepository</code>，在<code>fledgling</code>中实现的是基于网络传输的类<code>TaskRepository</code>。但究竟是基于单机数据库，还是身处一个分布式系统（C/S模型）中，<code>Entities</code>和<code>Use Cases</code>层对此是无感知的。</li>
</ul>
<h2 id="甘瓜苦蒂——整洁架构的不足"><a href="#甘瓜苦蒂——整洁架构的不足" class="headerlink" title="甘瓜苦蒂——整洁架构的不足"></a>甘瓜苦蒂——整洁架构的不足</h2><h3 id="渗入内层的I-O"><a href="#渗入内层的I-O" class="headerlink" title="渗入内层的I/O"></a>渗入内层的I/O</h3><!-- 无法隐藏的I/O -->
<!-- 在整洁架构中，为了不在entity层面感知到数据库，但又为了可以最终利用到数据库的事务能力，发明了基于start_transaction/commit/rollback的抽象方法。其中，当需要多个repository联合使用事务时，可以将多个repository传入到start_transaction的参数中。 -->
<!-- 设计模式的运用 -->
<!-- Python的module v.s. 单例模式 -->
<!-- repository.py中的工厂方法模式 -->
<!-- SOLID原则的体现 -->
<!-- 书中是如何理解SOLID原则的，给出每一个对应章节的解释。 -->
<!-- 不同编程语言实践整洁架构的体会 -->
<!-- Python如何 -->
<!-- CL如何 -->
<!-- go如何 -->

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2021/06/26/模拟小于运算符的短路特性/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/26/模拟小于运算符的短路特性/" class="post-title-link" itemprop="url">模拟小于运算符的短路特性</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-26 11:02:53" itemprop="dateCreated datePublished" datetime="2021-06-26T11:02:53+08:00">2021-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-02 11:18:47" itemprop="dateModified" datetime="2022-05-02T11:18:47+08:00">2022-05-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/实战CommonLisp/" itemprop="url" rel="index">
                    <span itemprop="name">实战CommonLisp</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/06/26/模拟小于运算符的短路特性/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/06/26/模拟小于运算符的短路特性/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>忆往昔峥嵘岁月稠</del>在Python的语言标准的<a href="https://docs.python.org/3/reference/expressions.html#comparisons" target="_blank" rel="noopener">Comparisions章节</a>中提到</p>
<blockquote>
<p>Also unlike C, expressions like a &lt; b &lt; c have the interpretation that is conventional in mathematics</p>
</blockquote>
<p>也就是说，在C语言中要写成<code>a &lt; b &amp;&amp; b &lt; c</code>的表达式，在Python中可以写成<code>a &lt; b &lt; c</code>。并且，标准中还提到</p>
<blockquote>
<p>Comparisons can be chained arbitrarily, e.g., x &lt; y &lt;= z is equivalent to x &lt; y and y &lt;= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x &lt; y is found to be false).</p>
</blockquote>
<p>一般将这种性质成为短路。因此，像<code>2 &lt; 1 &lt; (1 / 0)</code>这样的表达式在Python中不会引发异常，而是返回<code>False</code>。</p>
<p>Python的小于号能拥有短路特性，是因为它并非一个普通函数，而是有语言层面加持的操作符。而在Common Lisp（下称CL）中，小于号仅仅是一个普通函数，就像Haskell中的小于号也是一个函数一般。不同的是，CL的小于号能接受多于两个的参数</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">&lt;</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">-1</span>) <span class="comment">; 结果为NIL</span></span><br></pre></td></tr></tbody></table></figure>
<p>但它并没有短路特性</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">&lt;</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">-1</span> (<span class="name">/</span> <span class="number">1</span> <span class="number">0</span>)) <span class="comment">; 引发名为DIVISION-BY-ZERO的错误</span></span><br></pre></td></tr></tbody></table></figure>
<p>要想模拟出具有短路特性的小于号，必须借助于宏的力量。</p>
<h1 id="想生成什么样的代码"><a href="#想生成什么样的代码" class="headerlink" title="想生成什么样的代码"></a>想生成什么样的代码</h1><p>要想写出一个宏，必须先设想出它的语法，以及它会展开成什么样的代码。姑且为这个宏起名为<code>less-than</code>，它的语法应当为</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> less-than (<span class="name">form</span> <span class="symbol">&amp;rest</span> more-forms)</span><br><span class="line">  <span class="comment">; TBC</span></span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure>
<p>至于它的展开结果可以有多种选择。例如，可以<code>(less-than 2 1 (/ 1 0))</code>展开为自身具有短路特性的<code>and</code>形式</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">and</span> (<span class="name">&lt;</span> <span class="number">2</span> <span class="number">1</span>) (<span class="name">&lt;</span> <span class="number">1</span> (<span class="name">/</span> <span class="number">1</span> <span class="number">0</span>)))</span><br></pre></td></tr></tbody></table></figure>
<p>但就像在C语言中用宏朴素地实现计算二者最大值的<code>MAX</code>宏一样，上面的展开方式在一些情况下会招致重复求值</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">less-than</span> <span class="number">1</span> (<span class="name">progn</span> (<span class="name">print</span> 'hello) <span class="number">2</span>) <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>因此，起码要展开为<code>and</code>和<code>let</code>的搭配</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">g917</span> <span class="number">1</span>)</span><br><span class="line">      (<span class="name">g918</span> (<span class="name">progn</span> (<span class="name">print</span> 'hello) <span class="number">2</span>)))</span><br><span class="line">  (<span class="name">and</span> (<span class="name">&lt;</span> g917 g918)</span><br><span class="line">       (<span class="name">let</span> ((<span class="name">g919</span> <span class="number">3</span>))</span><br><span class="line">         (<span class="name">&lt;</span> g918 g919))))</span><br></pre></td></tr></tbody></table></figure>
<p>要想展开为这种结构，可以如这般实现<code>less-than</code></p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> less-than (<span class="name">form</span> <span class="symbol">&amp;rest</span> more-forms)</span><br><span class="line">  (<span class="name">labels</span> ((<span class="name">aux</span> (<span class="name">lhs</span> forms)</span><br><span class="line">             <span class="string">"LHS表示紧接着下一次要比较的、小于号的左操作数。"</span></span><br><span class="line">             (<span class="name">unless</span> forms</span><br><span class="line">               (<span class="name">return-from</span> aux))</span><br><span class="line">             (<span class="name">let*</span> ((<span class="name">rhs</span> (<span class="name">gensym</span>))</span><br><span class="line">                    (<span class="name">rv</span> (<span class="name">aux</span> rhs (<span class="name">rest</span> forms))))</span><br><span class="line">               (<span class="name">if</span> rv</span><br><span class="line">                   `(let ((,rhs ,(first forms)))</span><br><span class="line">                      (and (&lt; ,lhs ,rhs)</span><br><span class="line">                           ,rv))</span><br><span class="line">                   `(&lt; ,lhs ,(first forms))))))</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">null</span> more-forms)</span><br><span class="line">           `(&lt; ,form))</span><br><span class="line">          (<span class="name">t</span></span><br><span class="line">           (<span class="name">let</span> ((<span class="name">lhs</span> (<span class="name">gensym</span>)))</span><br><span class="line">             `(let ((,lhs ,form))</span><br><span class="line">                ,(aux lhs more-forms)))))))</span><br></pre></td></tr></tbody></table></figure>
<p>用上面的输入验证一下是否会导致重复求值</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">macroexpand-1</span> '(less-than <span class="number">1</span> (progn (print 'hello) <span class="number">2</span>) <span class="number">3</span>))</span><br><span class="line">(<span class="name">LET</span> ((<span class="name">#</span><span class="symbol">:G942</span> <span class="number">1</span>))</span><br><span class="line">  (<span class="name">LET</span> ((<span class="name">#</span><span class="symbol">:G943</span> (<span class="name">PROGN</span> (<span class="name">PRINT</span> 'HELLO) <span class="number">2</span>)))</span><br><span class="line">    (<span class="name">AND</span> (<span class="name">&lt;</span> #<span class="symbol">:G942</span> #<span class="symbol">:G943</span>) (<span class="name">&lt;</span> #<span class="symbol">:G943</span> <span class="number">3</span>))))</span><br><span class="line">T</span><br></pre></td></tr></tbody></table></figure>
<h1 id="优化一下"><a href="#优化一下" class="headerlink" title="优化一下"></a>优化一下</h1><p>显然<code>less-than</code>可以优化，只需要简单地运用递归的技巧即可</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> less-than (<span class="name">form</span> <span class="symbol">&amp;rest</span> more-forms)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">&lt;=</span> (<span class="name">length</span> more-forms) <span class="number">1</span>)</span><br><span class="line">         `(&lt; ,form ,@more-forms))</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">lhs</span> (<span class="name">gensym</span>))</span><br><span class="line">               (<span class="name">rhs</span> (<span class="name">gensym</span>)))</span><br><span class="line">           `(let ((,lhs ,form)</span><br><span class="line">                  (,rhs ,(first more-forms)))</span><br><span class="line">              (and (&lt; ,lhs ,rhs)</span><br><span class="line">                   (less-than ,rhs ,@(rest more-forms))))))))</span><br></pre></td></tr></tbody></table></figure>
<p>展开后的代码简短得多</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">macroexpand-1</span> '(less-than <span class="number">1</span> (progn (print 'hello) <span class="number">2</span>) <span class="number">3</span>))</span><br><span class="line">(<span class="name">LET</span> ((<span class="name">#</span><span class="symbol">:G955</span> <span class="number">1</span>) (<span class="name">#</span><span class="symbol">:G956</span> (<span class="name">PROGN</span> (<span class="name">PRINT</span> 'HELLO) <span class="number">2</span>)))</span><br><span class="line">  (<span class="name">AND</span> (<span class="name">&lt;</span> #<span class="symbol">:G955</span> #<span class="symbol">:G956</span>) (<span class="name">LESS-THAN</span> #<span class="symbol">:G956</span> <span class="number">3</span>)))</span><br><span class="line">T</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">…</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liutos" src="/images/loading.png" data-original="/images/微信.jpg">
  <p class="site-author-name" itemprop="name">Liutos</p>
  <div class="site-description" itemprop="description">记录编程生涯的大大小小的事情</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Liutos" title="GitHub → https://github.com/Liutos" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/liutos" title="SegmentFault → https://segmentfault.com/u/liutos" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>SegmentFault</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://u3coding.com" title="http://u3coding.com" rel="noopener" target="_blank">u3coding</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.skypyb.com/" title="https://www.skypyb.com/" rel="noopener" target="_blank">编码妙♂妙♂屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://xfy.now.sh" title="https://xfy.now.sh" rel="noopener" target="_blank">:- op( xfy ).</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://davincievans.top/" title="https://davincievans.top/" rel="noopener" target="_blank">Davinciの红茶馆</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://reverland.org" title="http://reverland.org" rel="noopener" target="_blank">reverland的知行阁</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.gndrive.org/" title="http://www.gndrive.org/" rel="noopener" target="_blank">高达数字实验室</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.hsyyf.me/" title="http://www.hsyyf.me/" rel="noopener" target="_blank">月下叹逍遥/寒山烟雨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.lainme.com/doku.php" title="http://www.lainme.com/doku.php" rel="noopener" target="_blank">Lainme's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://lengxx.com/" title="http://lengxx.com/" rel="noopener" target="_blank">冷轩信</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://forum.ubuntu.org.cn/" title="http://forum.ubuntu.org.cn/" rel="noopener" target="_blank">Ubuntu中文论坛</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://y-window.github.com/" title="http://y-window.github.com/" rel="noopener" target="_blank">Window的空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.thev.net/PaulLiu/" title="http://www.thev.net/PaulLiu/" rel="noopener" target="_blank">九瓜老师的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://weibo.com/liutos" title="http://weibo.com/liutos" rel="noopener" target="_blank">博主的微博</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://github.com/Liutos" title="http://github.com/Liutos" rel="noopener" target="_blank">博主的GitHub页面</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  © 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liutos</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  
  






  















  

  






<script src="/bundle.js"></script><script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://Liutos.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
;
!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script></body></html>