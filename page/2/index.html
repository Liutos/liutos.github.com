<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://liutos.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liutos.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-值得使用的软件之Alfred" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/16/值得使用的软件之Alfred/" class="article-date">
  <time datetime="2018-11-16T15:05:00.000Z" itemprop="datePublished">2018-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/16/值得使用的软件之Alfred/">值得使用的软件之Alfred</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>是一款所谓的“生产力工具”，可以理解为就是帮助Mac用户提高日常事务的处理效率的工具，在我还没有入手MBP的时候就已经（在知乎上）听闻了这款软件的大名了。实际使用了之后发现确实可以提升一些事情的处理效率，是一款值得身为程序员的读者朋友使用的应用。接下来我会举一些例子来说明一下，希望可以传达到我的感受。献上我的Alfred使用统计<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx5nx11uumj21kw115n9m.jpg" alt="Alfred的使用统计"></p>
<h2 id="Alfred的Clipboard"><a href="#Alfred的Clipboard" class="headerlink" title="Alfred的Clipboard"></a>Alfred的Clipboard</h2><p>剪贴板真是一个再常用不过的功能了，我想所有的读者朋友应该都使用过复制&amp;粘贴的功能——不管是在Windows上面的Ctrl-c Ctrl-v也好，还是在Mac上面的Command-c Command-v也罢。Alfred的Clipboard功能可以认为是一个强化版的剪贴板，它可以通过快捷键（在我的系统上设置为了Command-p）快速唤出<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx5o8vf7g9j20vs0ngh1e.jpg" alt="Alfred唤出Clipboard"></p>
<p>并且支持搜索（虽然很遗憾图片没办法搜索）<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx5oh8pgiyj20vs0ngnh2.jpg" alt="在Clipboard中搜索"></p>
<p>当需要在两个应用间复制粘贴多段内容的时候，Clipboard就派上用场了。只需要先把需要的每一段内容在一个应用中分别复制一次，打开另一个应用后唤出Clipboard，便可以把刚才复制的内容逐个粘贴进来。每当我在一些地方看到有趣的图片想要分享给微信或者QQ的朋友时，也是打开微信或者QQ后进入Alfred的Clipboard浏览——打开Clipboard后，敲入“Image”，便可以只查看记录在剪贴板中的图片了，并且还可以在发送前预览<br><img src="http://wx4.sinaimg.cn/large/791cf7abgy1fx6clzi5sej20vq0ngqnt.jpg" alt="在Clipboard中搜索图片"></p>
<h2 id="Alfred的Snippets"><a href="#Alfred的Snippets" class="headerlink" title="Alfred的Snippets"></a>Alfred的Snippets</h2><p>Snippets算是我近期才挖掘到并开始重度使用的功能，用一句话概括，就是“长话短说”。在Snippets中可以新建一个较短的关键字来代替一串较长的输入，例如我就分别用了gcd、gct，以及gmd来代替切换到develop分支、切换到test分支，以及合并develop分支这三条常用的Git操作命令<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx7i4n82ouj21kw1144kh.jpg" alt="在Snippets中定义短语"></p>
<p>之后既可以通过快捷键唤出Snippets面板的方式来输入短语，也可以直接在短语定义时勾选【Auto expandsion allowed】来做到输入短语后自动展开为完整的内容。下图演示的是输入gcd后自动展开为完整的命令<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx95zf440lg20dc06n42u.gif" alt="自动展开Snippets中的短语"></p>
<p>我现在已经积累了很多的短语了，不仅提高了输入的速度，也降低了重复输入这些内容的出错率，实在是居家旅行coding必备。</p>
<h2 id="Alfred的Workflow"><a href="#Alfred的Workflow" class="headerlink" title="Alfred的Workflow"></a>Alfred的Workflow</h2><p>购买Alfred的Powerpack后就可以开启<a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">Workflow</a>的功能了，实际上，在我真正开始用Alfred之前（还在用着Windows的时候），对Alfred的了解基本上局限于“它拥有一个很强大的叫做Workflow的功能”这样，可以说，让Alfred如此闻名遐迩的就是它的Workflow特性吧——不过后来我才知道原来Mac自带一个叫做Automator的类似的功能。</p>
<p>刚开始接触Workflow的时候，我也沉迷于在网上搜罗别人写好的来用，慢慢地才发现这些其他人经常（在知乎的答案里）列举到的Workflow，其实并不适合我。有一两个觉得眼前一亮的，在使用了一两次之后也就不怎么用了。现在，我自己写了一些Workflow，倒是显著地提升了我的开发过程。</p>
<p>比较合适作为例子的是我写的三个用于处理时间的Workflow。一个是用于将日期时间字符串转换为UNIX时间戳（毫秒单位）的Workflow，名为gt——取的是get time之意。使用起来的效果大致如下<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx95y9x87ng20dc0c81en.gif" alt="gt的使用效果"></p>
<p>这个Workflow最终会把结果复制到剪贴板中，便于在其它应用中使用。由于工作内容的缘故，我常常会需要获取某一个时候的UNIX时间戳（毫秒单位）。在有这个Workflow之前，我都是打开iTerm运行node，然后敲入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2018-11-15 00:00:00'</span>).getTime();</span><br></pre></td></tr></table></figure></p>
<p>这般的代码来得到结果的，不仅要在不同的应用间切换来切换去的，而且还需要重复地敲入new、Date，以及getTime等字眼，实在是一件很低效的事情。使用了gt之后，感觉幸福感也提高了很多。</p>
<p>另一个Workflow名为wt——取的是what time之意，它的作用跟gt相反，是将毫秒数转换为可读的日期时间字符串，效果如下<br><img src="http://wx2.sinaimg.cn/large/791cf7abgy1fx960hx1heg20dc0c849f.gif" alt="wt的使用效果"></p>
<p>最后一个Workflow名为int——即I need time，它可以提供特定的一些时刻的时间戳，例如【今天零点】这样的特定的时刻。这三个Workflow的入口节点都是一个<a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/" target="_blank" rel="noopener">Script Filter</a>，int的使用效果如下<br><img src="http://wx3.sinaimg.cn/large/791cf7abgy1fx9um0vongg20dc0c8k95.gif" alt="int的使用效果"></p>
<p>Alfred的Workflow还可以做很多的事情。它是一个入口，很适合用于不需要肉眼查看含有大段文字的结果的交互场景，例如对字符串做编码转换、计算字符串的摘要、通过AppleScript调起微信联系人，以及控制音量等等，只要好好利用，就可以提升平时的使用效率。程序员朋友们，不妨一起来发挥自己的创造力吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2018/11/16/值得使用的软件之Alfred/" data-id="cjs9voc3r000ic030vswais8b" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2018/11/16/值得使用的软件之Alfred/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/alfred/">alfred</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flexi-streams用法简介" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/18/flexi-streams用法简介/" class="article-date">
  <time datetime="2018-09-18T15:14:50.000Z" itemprop="datePublished">2018-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/18/flexi-streams用法简介/">flexi-streams用法简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每过一段时间总会燃起一种用Common Lisp（下文简称CL）来写Web应用的冲动，继而就会开始感慨在CL的生态圈中居然没有一款好用的Web框架。尽管放狗搜索“common lisp web framework”可以找到一些——例如Caveman2，以及在Cliki中记录的一些其它框架。然后使用过其中一部分的人就会知道，大部分用起来的体验都不咋地。</p>
<p>在业界摸爬打滚了一小段时光（从业几年姑且可以这么说吧）后，感觉制作一款专门用于编写JSON-in-JSON-out的Web应用的Web框架应该是一个不错的点子——反正大家都是发出application/json的请求期望application/json的响应，于是乎就撸起袖子自己干了。不过完全从零开始编写起是不现实的，于是乎选择了一个“平台”来作为基础。这个平台就是<a href="https://github.com/fukamachi/clack" target="_blank" rel="noopener">Clack</a>啦</p>
<p>Clack会负责屏蔽下层的Web Server的差异，它只需要我提供一个函数给它作为来访的HTTP请求的“handler”即可，然后在这个handler中我就可以为所欲为啦。Clack在收到HTTP请求后，会把HTTP请求中的一些信息组织为一个列表类型的值传递给这个handler。在这个handler中，我只需要综合运用CAR、CDR之类的奇怪名字的函数就可以拿到自己需要的东西了——当然了，鉴于这个列表是个plist，用CL提供的DESTRUCTURING-BIND就可以很方便地提取啦。</p>
<p>在这个plist中，就有一个叫做:RAW-BODY的p，它的值是一个“流”——是的，就是那种文件流的流！但它又不是一个路边随处可见的妖艳贱货的流，而是一个来自FLEXI-STREAMS这个包（指CL中的package）的流。<a href="https://edicl.github.io/flexi-streams/" target="_blank" rel="noopener">FLEXI-STREAMS</a>是一个提供流操作的库，鉴于我没有看过<a href="http://www.nhplace.com/kent/CL/Issues/stream-definition-by-user.html" target="_blank" rel="noopener">Gray streams</a>相关的内容，就不在这里瞎逼逼误导读者了。总而言之，我必须找到一个办法可以从一个FLEXI-STREAMS提供的输入流类型的值中读出一些东西来。</p>
<p>其实这个办法很简单，就是用CL原生提供的读取流的函数即可——比如READ-SEQUENCE这样的函数。不过我得验证一下不是，为此，我需要有办法可以构造出一个FLEXI-STREAMS流类型的值出来。FLEXI-STREAMS提供了一个叫做MAKE-FLEXI-STREAM的函数，显然这个就是我所需要调用的最后一个函数了。从它的描述来看，它需要一个CL中的原生流来作为第一个参数才行。为此，我试了一下下面的代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">text</span> <span class="string">"Hello, world!"</span>))</span><br><span class="line">  (<span class="name">with-input-from-string</span> (<span class="name">s</span> text)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">buffer</span> (<span class="name">make-array</span> (<span class="name">length</span> text)))</span><br><span class="line">          (<span class="name">fs</span> (<span class="name">flexi-streams</span><span class="symbol">:make-flexi-stream</span> s)))</span><br><span class="line">      (<span class="name">read-sequence</span> buffer fs))))</span><br></pre></td></tr></table></figure>
<p>遗憾的是，运行上面的代码会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">The value</span><br><span class="line">  #\H</span><br><span class="line">is not of type</span><br><span class="line">  (UNSIGNED-BYTE 8)</span><br><span class="line">when setting an element of (ARRAY (UNSIGNED-BYTE 8))</span><br><span class="line">   [Condition of type TYPE-ERROR]</span><br><span class="line"></span><br><span class="line">Restarts:</span><br><span class="line"> 0: [RETRY] Retry SLIME interactive evaluation request.</span><br><span class="line"> 1: [*ABORT] Return to SLIME&apos;s top level.</span><br><span class="line"> 2: [ABORT] abort thread (#&lt;THREAD &quot;worker&quot; RUNNING &#123;1007766D53&#125;&gt;)</span><br><span class="line"></span><br><span class="line">Backtrace:</span><br><span class="line">  0: ((SB-VM::OPTIMIZED-DATA-VECTOR-SET (UNSIGNED-BYTE 8)) #&lt;unavailable argument&gt; #&lt;unavailable argument&gt; #&lt;unavailable argument&gt;)</span><br><span class="line">  1: (SB-IMPL:ANSI-STREAM-READ-SEQUENCE #(0 0 0 0 0 0 ...) #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;1007975973&#125;&gt; 0 13)</span><br><span class="line">  2: (READ-SEQUENCE #(0 0 0 0 0 0 ...) #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;1007975973&#125;&gt; :START 0 :END 13)</span><br><span class="line">  3: ((FLET FLEXI-STREAMS::FILL-BUFFER :IN FLEXI-STREAMS::READ-SEQUENCE*) 13)</span><br><span class="line">  4: ((:METHOD FLEXI-STREAMS::READ-SEQUENCE* (FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT T T T T)) #&lt;FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT (:ISO-8859-1 :EOL-STYLE :LF) &#123;1007975B43&#125;&gt; #&lt;FLEXI-STREAMS:FLEXI-INPUT-STRE..</span><br><span class="line">  5: ((:METHOD STREAM-READ-SEQUENCE (TRIVIAL-GRAY-STREAMS:FUNDAMENTAL-INPUT-STREAM T)) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;1007975C73&#125;&gt; #(0 0 0 0 0 0 ...) 0 NIL) [fast-method]</span><br><span class="line">  6: (READ-SEQUENCE #(0 0 0 0 0 0 ...) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;1007975C73&#125;&gt; :START 0 :END NIL)</span><br><span class="line">  7: ((LAMBDA ()))</span><br><span class="line">  8: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))) #&lt;NULL-LEXENV&gt;)</span><br><span class="line">  9: (EVAL (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))))</span><br><span class="line"> 10: ((LAMBDA NIL :IN SWANK:INTERACTIVE-EVAL))</span><br><span class="line"> --more--</span><br></pre></td></tr></table></figure>
<p>既然在调用READ-SEQUENCE的时候出状况了，不妨试试下面的代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">text</span> <span class="string">"Hello, world!"</span>))</span><br><span class="line">  (<span class="name">with-input-from-string</span> (<span class="name">s</span> text)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">fs</span> (<span class="name">flexi-streams</span><span class="symbol">:make-flexi-stream</span> s)))</span><br><span class="line">      (<span class="name">read-char</span> fs))))</span><br></pre></td></tr></table></figure>
<p>再次令人遗憾的，它会抛出另一个状况（CL中的condition啦）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#&lt;SB-IMPL::STRING-INPUT-STREAM &#123;10020A7243&#125;&gt; is not a binary input stream.</span><br><span class="line">   [Condition of type SIMPLE-TYPE-ERROR]</span><br><span class="line"></span><br><span class="line">Restarts:</span><br><span class="line"> 0: [RETRY] Retry SLIME interactive evaluation request.</span><br><span class="line"> 1: [*ABORT] Return to SLIME&apos;s top level.</span><br><span class="line"> 2: [ABORT] abort thread (#&lt;THREAD &quot;worker&quot; RUNNING &#123;1001F6E813&#125;&gt;)</span><br><span class="line"></span><br><span class="line">Backtrace:</span><br><span class="line">  0: (SB-KERNEL:ILL-BIN #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;10020A7243&#125;&gt;)</span><br><span class="line">  1: (READ-BYTE #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;10020A7243&#125;&gt; NIL NIL)</span><br><span class="line">  2: ((:METHOD FLEXI-STREAMS::READ-BYTE* (FLEXI-STREAMS:FLEXI-INPUT-STREAM)) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;10020A74C3&#125;&gt;) [fast-method]</span><br><span class="line">  3: ((:METHOD FLEXI-STREAMS::OCTETS-TO-CHAR-CODE (FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT T)) #&lt;FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT (:ISO-8859-1 :EOL-STYLE :LF) &#123;10020A7393&#125;&gt; #&lt;unavailable argument&gt;) [fast-me..</span><br><span class="line">  4: ((:METHOD STREAM-READ-CHAR (FLEXI-STREAMS:FLEXI-INPUT-STREAM)) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;10020A74C3&#125;&gt;) [fast-method]</span><br><span class="line">  5: (READ-CHAR #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;10020A74C3&#125;&gt; T NIL #&lt;unused argument&gt;)</span><br><span class="line">  6: ((LAMBDA ()))</span><br><span class="line">  7: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))) #&lt;NULL-LEXENV&gt;)</span><br><span class="line">  8: (EVAL (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))))</span><br><span class="line">  9: ((LAMBDA NIL :IN SWANK:INTERACTIVE-EVAL))</span><br><span class="line"> --more--</span><br></pre></td></tr></table></figure>
<p>看来从一开始提供给MAKE-FLEXI-STREAM函数的参数就应当是一个“二进制”的流才对。为此，我需要借助FLEXI-STREAMS自身的力量——调用它的STRING-TO-OCTETS函数。使用这个函数，可以将一个字符串转换为某种编码下的字节数组，例如下面的代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">flexi-streams</span><span class="symbol">:string-to-octets</span> <span class="string">"Hello"</span>) <span class="comment">;#(72 101 108 108 111)</span></span><br></pre></td></tr></table></figure>
<p>得到一串“octet”后，还需要将其转换为“流”才行。再次借助FLEXI-STREAMS的力量，调用它的MAKE-IN-MEMORY-INPUT-STREAM函数，然后将这个函数调用的返回值作为MAKE-FLEXI-STREAM的第一个参数即可，最终的代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">text</span> <span class="string">"Hello, world!"</span>)           <span class="comment">; 原始文本</span></span><br><span class="line">       (<span class="name">octets</span> (<span class="name">flexi-streams</span><span class="symbol">:string-to-octets</span> text)) <span class="comment">; 使用flexi-streams转换为字节数组，因为下一个函数只接受这种类型的参数</span></span><br><span class="line">       (<span class="name">memory-input</span> (<span class="name">flexi-streams</span><span class="symbol">:make-in-memory-input-stream</span> octets)) <span class="comment">; 同样先转换为内存中的流，因为下一个函数只接受这种类型的参数</span></span><br><span class="line">       (<span class="name">flexi-stream</span> (<span class="name">flexi-streams</span><span class="symbol">:make-flexi-stream</span> memory-input)) <span class="comment">; 终于可以得到一个真正的flexi-stream了</span></span><br><span class="line">       (<span class="name">buffer</span> (<span class="name">make-array</span> (<span class="name">flexi-streams</span><span class="symbol">:octet-length</span> text)))) <span class="comment">; 这里其实用字节的长度还是用字符的长度（flexi-streams:char-length）都没差</span></span><br><span class="line">  (<span class="name">read-sequence</span> buffer flexi-stream)   <span class="comment">; 可以像处理CL中的流那样处理flexi-stream</span></span><br><span class="line">  (<span class="name">print</span> (<span class="name">coerce</span> buffer 'string)))      <span class="comment">; 把字节数组拼成字符串再输出比较好看</span></span><br></pre></td></tr></table></figure>
<p>全文完</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2018/09/18/flexi-streams用法简介/" data-id="cjs9voc3q000gc030bsrt29lm" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2018/09/18/flexi-streams用法简介/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/common-lisp/">common lisp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sdedit使用方法介绍（混沌向）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/12/sdedit使用方法介绍（混沌向）/" class="article-date">
  <time datetime="2018-08-12T00:52:54.000Z" itemprop="datePublished">2018-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/sdedit使用方法介绍（混沌向）/">sdedit使用方法介绍（混沌向）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在寻找绘制时序图的过程中遇到了sdedit，感觉非常适合自己使用，故写这么篇文章向自己也向有同样需求的其它开发人员介绍一些这款软件</p>
<p>sdedit在macOS上安装还是非常容易的，只需要使用homebrew就可以轻松安装，命令如下</p>
<pre><code>brew install sdedit
</code></pre><p>之后sdedit就会被安装到/usr/local/bin 这个目录下，在命令中输入sdedit就可以启动了。</p>
<p>输入sdedit后会启动一个Java Swing写的GUI程序，具体的外观和布局就不介绍了，这里主要讲解一下sdedit所支持的语法</p>
<h1 id="sdedit中绘图的常用语法"><a href="#sdedit中绘图的常用语法" class="headerlink" title="sdedit中绘图的常用语法"></a>sdedit中绘图的常用语法</h1><p>PS：我对UML中的一些术语并不了解，下面的介绍是可能有错误的，具体请以sdedit的官方文档（<a href="http://sdedit.sourceforge.net/enter_text/" target="_blank" rel="noopener">http://sdedit.sourceforge.net/enter_text/</a>）为准。同时，既然有官方文档了，我就不在此翻译一遍了，只记录一些常用的用法</p>
<p>如果需要输入整个时序图的标题（姑且叫做标题），那么可以使用下面的语法</p>
<pre><code>#![一键获取手机号并登录的交互流程]
</code></pre><p>即以UNIX中的shebang开头，后面通过一对方括号包住标题内容即可</p>
<p>如果需要绘制一个参与时序图的节点，那么使用下面的语法（摘抄自官方文档）</p>
<pre><code>&lt;name&gt;:&lt;Type&gt;[&lt;flags&gt;] &quot;&lt;label&gt;&quot;
</code></pre><p>其中，<name>就是节点的唯一名字，之后当描述节点间的交互时需要这个字段，请给每一个节点都取一个独一无二的名字（就像取变量名那样）；<type>部分顾名思义就是类型，虽然我在使用的时候这个字段的值也是随心所欲地写的，但这个字段对sdedit而言似乎有特殊含义——例如，如果这个字段填入的是Actor，那么绘制出来的就会是一个人形的节点，在用来表示用户的时候特别有用；（flags我还没有用过就不介绍了）；label可以理解为节点的文案，如果不填<label>，那么节点在最终绘制的图中展示的时候用的就是<name>作为名字</name></label></type></name></p>
<p>定义好节点之后，就需要把各个节点在不同的时间用不同的消息联系起来了。描述节点间联系用的语法是（摘自官网）</p>
<pre><code>&lt;caller&gt;[&lt;s&gt;]:&lt;answer&gt;=&lt;callee&gt;[m].&lt;message&gt;
</code></pre><p>其中的caller和callee都是写的节点的<name>（所以name需要时独一无二的），这样就会绘制出两条线——一条实线从caller指向callee，以及一条虚线从callee指向caller，以及在callee的生命周期下绘制出一个纵向的矩形，表示callee的处理过程；<message>是从caller发往callee的消息，例如参数的描述；如果需要同时描述从callee返回的结果，那么就需要填写在上述语法的的<answer>的位置——个人觉得这个语法是有点奇怪的</answer></message></name></p>
<h2 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h2><p>上面的这些文本描述都需要输入到sdedit的文本框中（唯一UI上的右下角），之后点击保存就可以得到一个XXX.sdx的文件了。由于在我的电脑上，sdedit的GUI上的导出功能用起来非常有问题，所以我摸索出来的是在命令行导出图片文件的做法（并且可以导出的格式似乎更丰富）。总体的用法是</p>
<pre><code>sdedit -t &lt;类型&gt; -o &lt;输出文件名&gt; &lt;原始的.sdx文件&gt;
</code></pre><p>输出文件名随性地取即可，其中类型对常用的都有支持（svg、png、jpg，和bmp），我一般常用的是png，然后就可以得到一张PNG图片了（便可以美美地用到设计文档里了）</p>
<p>配图什么的等我哪天特别闲了再补充上来吧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2018/08/12/sdedit使用方法介绍（混沌向）/" data-id="cjs9voc3o000cc030pnqy0vkm" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2018/08/12/sdedit使用方法介绍（混沌向）/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sequence-diagram/">sequence diagram</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MacBook-Pro使用体验" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/02/MacBook-Pro使用体验/" class="article-date">
  <time datetime="2018-08-02T15:33:58.000Z" itemprop="datePublished">2018-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/02/MacBook-Pro使用体验/">MacBook Pro使用体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>生平第一次有一台自己的MacBook，使用了一段时间之后也有了自己的一番感想，特此写下来留个纪念。感想主要分为硬件以及软件两个方面，本文不会有太多的条理性</p>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>上周四晚上第一次从收件的超市老板手里接过MacBook Pro的时候，第一感觉是意想不到的沉重。回到家拆开包装，拿起机体和电源适配器的时候，也是觉得非常的重。虽然经过几天的使用后发现并没有当初那般沉重的感觉了，但总体还是超过了我的预期。</p>
<p>接着是发现这台电脑居然没有开机键。老实说，其实这个是我在昨天才意识到的；同时，这台电脑只有四个Type-C的接口，不得不下单买了个外接的适配器。</p>
<p>触控板的面积很大，但正如传闻中所说的，触控板非常地好用，不像我之前用的电脑触控板是塑料材质的，当手出汗的时候非常地难用。</p>
<p>比较可惜的是，control键只在键盘的左侧有，对于使用Emacs来编码的人（指我自己）来说，是比较不方便的。虽然现在已经分别将左右的option设置成了（Windows上的）control，以及将command设置成了（Windows上的）Alt，但无名指在按键的时候还是难免误触。同时，没有独立的home/end/up/down，刚开始还真有点不习惯</p>
<p>touchbar毕竟是一块没有力反馈的触摸屏，所以每当需要按ESC的时候都忍不住要肉眼确认一下或者按两下。但用touchbar来控制音量则非常方便</p>
<p>散热有点糟糕。第一天晚上折腾的时候，安装完Visual Studio Code然后VSC自己卡死了，随后机器开始发热，尤其是touchbar上方靠近屏幕铰链的位置很烫——可千万不要轻易烧坏了呀</p>
<p>电池很给力，不需要每天下班都带着重重的电源适配器回家</p>
<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>开机后的第一感觉就是界面新颖，虽然并不是第一次亲眼看见macOS了，但作为自己的机器来使用，认真一看确实觉得比Windows要美观，比起之前在虚拟机中使用的Mint也要更优雅统一。触控板非常地好用，尤其是三指上划用于在窗口间切换的功能非常地棒，两指点击表示右键单击的效果也非常地好，既轻盈又方便。字体很好看，就连在Emacs中展示的中文也变得可爱起来</p>
<p>摆脱了虚拟机，也就不用再把内存用在一起重复的功能上了（比如把内存分给虚拟机的操作系统），搭配上SSD现在开启软件都非常地快。不过大概是因为虚拟机用惯了，有时候总忍不住切换到调度中心，然后找一个看起来比较像虚拟机的应用来点一下，2333</p>
<p>以前在Mint里面用的搜狗输入法总觉得有什么欠缺，现在可以用上全功能的版本了感觉很爽快，连在Emacs中输入中文也变得畅快起来。更令人惊喜的是，不知道如何折腾，现在我居然可以在多个软件里用上Emacs的键绑定了，目前发现的包括但不限于Firefox的输入框、微信、QQ，以及有道云笔记。</p>
<p>Mac上的一些软件很有趣，比如Alfred、Timing等等，同时也是我第一次使用zsh+oh-my-zsh，的确是很强大的工具。这两天我也开始编写自己的Workflow了，打算接着学习一下Apple Script更好地帮助自己使用这个系统。</p>
<p>好了，就酱</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2018/08/02/MacBook-Pro使用体验/" data-id="cjs9voc3k0007c030opfxjgwt" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2018/08/02/MacBook-Pro使用体验/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/macbook/">macbook</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cl-mongo用法入门" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/cl-mongo用法入门/" class="article-date">
  <time datetime="2017-06-04T13:21:20.000Z" itemprop="datePublished">2017-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/cl-mongo用法入门/">cl-mongo用法入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近用Common Lisp开发一个个人项目，需要记录发出的HTTP请求的参数，包括了目标地址、HTTP body，以及HTTP头部等多种信息。为了可以结构化地存储这些数据（比如HTTP头部是由多个键值对组成的），我选择将它们保存到MongoDB中。Google一番后，我找到了<a href="https://github.com/fons/cl-mongo" target="_blank" rel="noopener">cl-mongo</a>这个库，可以在Common Lisp中读写MongoDB，尝试了一下也确实可以满足自己的需求。为了方便自己查阅，也为了方便有相同需求的人了解如何使用cl-mongo，于是写了这篇文章。</p>
<p>首先使用<code>CL-MONGO:MONGO</code>函数连接MongoDB的服务器程序（mongod）。因为在我的系统上mongod进程监听的是27017这个端口，并且我希望使用的数据库名为test，因此键入如下代码来连接数据库</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:mongo</span> <span class="symbol">:db</span> <span class="string">"test"</span></span><br><span class="line">                <span class="symbol">:host</span> <span class="string">"127.0.0.1"</span></span><br><span class="line">                <span class="symbol">:port</span> <span class="number">27017</span>)</span><br></pre></td></tr></table></figure>
<p>连接上了数据库后，首先尝试往其中写入一个文档。假设现在要记录的是发出的HTTP请求的信息，那么一个可以写入的基本信息就是请求的目标地址。假设在命令行的mongo shell中输入的内容如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.http_request.insert(&#123;<span class="attr">uri</span>: <span class="string">'http://example.com'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>那么使用cl-mongo提供的<code>DB.INSERT</code>函数达到上述效果的代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.insert <span class="string">"http_request"</span></span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"uri"</span> <span class="string">"http://example.com"</span>))</span><br></pre></td></tr></table></figure>
<p>求值上述代码后返回值为NIL。为了将上述写入的文档重新查询出来，需要使用cl-mongo提供的<code>DB.FIND</code>函数。因为只有一个文档，所以直接查询就可以查看到结果了。在mongo shell中我们可以使用如下代码查询</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.http_request.find();</span><br></pre></td></tr></table></figure>
<p>使用<code>DB.FIND</code>函数的话编写的代码可能会长得像下面这样</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.find <span class="string">"http_request"</span> <span class="symbol">:all</span>)</span><br></pre></td></tr></table></figure>
<p>在我的系统上求值了上述代码后在REPL中输出的内容如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">86</span> <span class="number">449</span> <span class="number">0</span> <span class="number">1</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="string">"http_request"</span>)</span><br><span class="line"> (<span class="name">&lt;CL-MONGO</span><span class="symbol">:DOCUMENT&gt;</span> : &#123; </span><br><span class="line">   _id : CL-MONGO:<span class="symbol">:BSON-OID</span> [#(<span class="number">89</span> <span class="number">52</span> <span class="number">26</span> <span class="number">160</span> <span class="number">109</span> <span class="number">156</span> <span class="number">254</span> <span class="number">71</span> <span class="number">184</span> <span class="number">115</span> <span class="number">102</span> <span class="number">30</span>)]</span><br><span class="line">   elements : <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>值得注意的是，<code>DB.FIND</code>的返回值不完全是文档组成的数组，而是在这个结果集的数组之外又多了一层列表，并且列表的第一个元素还是一个一看之下不知其所以然的子列表。由于cl-mongo的GitHub上没有提及这个玩意儿的来历，我也没有深入去了解<code>DB.FIND</code>函数的实现代码，因此这个元素就先忽略它吧。如果需要使用<code>DB.FIND</code>查询到的结果，那么开发者需要对<code>DB.FIND</code>的返回值应用一下函数<code>SECOND</code>才行，如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">second</span> (<span class="name">cl-mongo</span><span class="symbol">:db</span>.find <span class="string">"http_request"</span> <span class="symbol">:all</span>))</span><br></pre></td></tr></table></figure>
<p>返回值的列表中的每一个元素都是<code>CL-MONGO:DOCUMENT</code>这个类的实例对象，如果要直接使用还是稍微有点不方便的，因此我写了一个函数用来将<code>DB.FIND</code>函数查询到的<code>CL-MONGO:DOCUMENT</code>的实例对象都转换为较为熟悉，容易操作的数据类型——association list，函数的定义如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> document-to-alist (<span class="name">doc</span>)</span><br><span class="line">  <span class="string">"Convert a DOC of type CL-MONGO:DOCUMENT to a equivalent, serializable alist."</span></span><br><span class="line">  (<span class="name">check-type</span> doc cl-mongo<span class="symbol">:document</span>)</span><br><span class="line">  (<span class="name">labels</span> ((<span class="name">aux</span> (<span class="name">doc</span>)</span><br><span class="line">             (<span class="name">cond</span> ((<span class="name">typep</span> doc 'cl-mongo<span class="symbol">:document</span>)</span><br><span class="line">                    (<span class="name">let</span> ((<span class="name">keys</span> (<span class="name">cl-mongo</span><span class="symbol">:get-keys</span> doc)))</span><br><span class="line">                      (<span class="name">mapcar</span> #'(lambda (key)</span><br><span class="line">                                  (cons key</span><br><span class="line">                                        (aux (cl-mongo:get-element key doc))))</span><br><span class="line">                              keys)))</span><br><span class="line">                   (<span class="name">t</span> doc))))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">id</span> (<span class="name">cl-mongo</span><span class="symbol">:doc-id</span> doc)))</span><br><span class="line">      (<span class="name">append</span> (<span class="name">aux</span> doc) (<span class="name">list</span> (<span class="name">cons</span> <span class="string">"_id"</span> id))))))</span><br></pre></td></tr></table></figure>
<p>使用如下代码即可查看方才所写入的文档究竟长什么样子了</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">document-to-alist</span> (<span class="name">first</span> (<span class="name">second</span> (<span class="name">cl-mongo</span><span class="symbol">:db</span>.find <span class="string">"http_request"</span> <span class="symbol">:all</span>))))</span><br></pre></td></tr></table></figure>
<p>如果想要修改数据库中的文档，例如增加一个字段，那么可以使用cl-mongo提供的<code>DB.UPDATE</code>函数，用法如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.update <span class="string">"http_request"</span></span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"uri"</span> <span class="string">"http://example.com"</span>)</span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"$set"</span></span><br><span class="line">                                 (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"method"</span> <span class="string">"GET"</span>)))</span><br></pre></td></tr></table></figure>
<p>最后如果要删除刚才所写入的这个文档，可以使用cl-mongo的<code>DB.DELETE</code>函数（我很好奇这个函数居然不是叫做DB.REMOVE），用法如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.delete <span class="string">"http_request"</span></span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"uri"</span> <span class="string">"http://example.com"</span>))</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2017/06/04/cl-mongo用法入门/" data-id="cjs9voc3l0008c030ynfj8lu3" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2017/06/04/cl-mongo用法入门/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/common-lisp/">common lisp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongo/">mongo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-远程请求Squid" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/18/远程请求Squid/" class="article-date">
  <time datetime="2017-05-18T13:18:42.000Z" itemprop="datePublished">2017-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/18/远程请求Squid/">远程请求Squid</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不久前在办公室抓取某网站S被对方发现，导致对方自动屏蔽了来自办公室网络的所有HTTP请求，连正儿八经地用浏览器打开也不行。为了可以摸索出“改头换面”（改HTTP头部）访问的方法，必须先成功访问至少一次，看看发出的HTTP头部是怎样的才行。恰好想起自己有一台腾讯云服务器，登上去用<code>curl</code>访问网站S，发现是成功的（也就是尚未被屏蔽）。既然如此，干脆在服务器上部署一套Squid作为正向代理，帮助办公网络的请求成功抵达网站S并拿到响应页面。</p>
<p>用<code>apt-get</code>安装了<code>squid</code>软件包后启动并监听端口8321，在办公网络下将公网地址和8321端口作为代理配置传递给<code>curl</code>的<code>-x</code>选项，访问网站S。不料Squid拒绝了我的请求，返回了如下内容（节选自<code>curl -v</code>命令的输出）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt; HTTP/1.1 403 Forbidden</span><br><span class="line">&lt; Server: squid/3.5.12</span><br><span class="line">&lt; Mime-Version: 1.0</span><br><span class="line">&lt; Date: Wed, 17 May 2017 15:18:08 GMT</span><br><span class="line">&lt; Content-Type: text/html;charset=utf-8</span><br><span class="line">&lt; Content-Length: 3531</span><br><span class="line">&lt; X-Squid-Error: ERR_ACCESS_DENIED 0</span><br><span class="line">&lt; Vary: Accept-Language</span><br><span class="line">&lt; Content-Language: en</span><br><span class="line">&lt; X-Cache: MISS from VM-44-136-ubuntu</span><br><span class="line">&lt; X-Cache-Lookup: NONE from VM-44-136-ubuntu:8321</span><br><span class="line">&lt; Via: 1.1 VM-44-136-ubuntu (squid/3.5.12)</span><br><span class="line">&lt; Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>经过一番Google，才知道原来是Squid的配置导致的。在Squid配置文件（/etc/squid/squid.conf）中，默认的acl和http_access指令的设置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">acl SSL_ports port 443</span><br><span class="line">acl Safe_ports port 80          # http</span><br><span class="line">acl Safe_ports port 21          # ftp</span><br><span class="line">acl Safe_ports port 443         # https</span><br><span class="line">acl Safe_ports port 70          # gopher</span><br><span class="line">acl Safe_ports port 210         # wais</span><br><span class="line">acl Safe_ports port 1025-65535  # unregistered ports</span><br><span class="line">acl Safe_ports port 280         # http-mgmt</span><br><span class="line">acl Safe_ports port 488         # gss-http</span><br><span class="line">acl Safe_ports port 591         # filemaker</span><br><span class="line">acl Safe_ports port 777         # multiling http</span><br><span class="line">acl CONNECT method CONNECT</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http_access deny !Safe_ports</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line">http_access allow localhost manager</span><br><span class="line">http_access deny manager</span><br><span class="line">http_access allow localhost</span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>
<p>由于Squid是按照第一条匹配的http_access指令来决定允许还是拒绝的，因为来自我办公网络的请求实际上命中的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_access deny all</span><br></pre></td></tr></table></figure>
<p>因此被拒绝是必然的。为了可以接受来自办公网络发起的请求，首先需要新增一行acl指令。通过Squid的日志（/var/log/squid/access.log）可以查看到被拒绝的请求的IP地址是多少，此处假设IP地址为8.7.198.45，那么相应的acl指令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl myclients src 8.7.198.45</span><br></pre></td></tr></table></figure>
<p>此处的myclients为自定义的名称，顾名思义，它表示“我的客户端”；src是一种acl类型，表示客户端的IP地址；8.7.198.45是src类型下的参数，也就是我所使用的客户端发出的请求的来源IP地址。配置了acl后，还需要配置http_access指令。这个就简单多了，只要允许上面创建的这个acl的访问即可，内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_access allow myclients</span><br></pre></td></tr></table></figure>
<p>之后再重启Squid服务即可</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service squid restart</span><br></pre></td></tr></table></figure>
<p>这时候再从办公网络中以腾讯云服务器上的Squid为正向代理发出请求，就不会再被Squid拒绝了。</p>
<p>全文完</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2017/05/18/远程请求Squid/" data-id="cjs9voc410018c030m40j7bwu" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2017/05/18/远程请求Squid/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/squid/">squid</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tutorial/">tutorial</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/教程/">教程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何使用CL实现snowflake" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/30/如何使用CL实现snowflake/" class="article-date">
  <time datetime="2017-04-30T14:59:30.000Z" itemprop="datePublished">2017-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/30/如何使用CL实现snowflake/">如何使用CL实现snowflake</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR;"></a>TL;DR;</h2><p>这是一篇为了完成写作KPI而写的博客，总结起来就是提供了一种用Common Lisp实现来自于Twitter的雪花算法的实现方案。成品在<a href="https://github.com/Liutos/clitool/blob/master/cl/misc/snowflake.lisp" target="_blank" rel="noopener">这里</a>，本文只是简单地描述一下生成雪花ID的大致思路，详细内容请各位移步代码仓库查看。</p>
<p>上述代码仓库中的snowflake算法——如果我的实现确实可以称作snowflake算法的话——的思路来自于下列两个地方：</p>
<ol>
<li><a href="http://www.lanindex.com/twitter-snowflake，64位自增id算法详解/" target="_blank" rel="noopener">http://www.lanindex.com/twitter-snowflake，64位自增id算法详解/</a></li>
<li><a href="https://github.com/sony/sonyflake" target="_blank" rel="noopener">https://github.com/sony/sonyflake</a></li>
</ol>
<h2 id="如何获取时间戳"><a href="#如何获取时间戳" class="headerlink" title="如何获取时间戳"></a>如何获取时间戳</h2><p>Common Lisp本身提供了一个获取时间戳的函数，也就是<code>get-universal-time</code>，可惜的是，这个函数所返回的并不是通常意义上的<a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Epoch时间戳</a>，而是自己的一套计算时间的方式中的表示时间的整数。为了获得UNIX时间戳，需要借助于第三方库<a href="https://common-lisp.net/project/local-time/manual.html" target="_blank" rel="noopener"><code>local-time</code></a>。为了可以获取到毫秒精度的时间戳，一个可运行的函数如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> now ()</span><br><span class="line">  <span class="string">"Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."</span></span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">now</span> (<span class="name">local-time</span><span class="symbol">:now</span>))</span><br><span class="line">         (<span class="name">seconds</span> (<span class="name">local-time</span><span class="symbol">:timestamp-to-unix</span> now))</span><br><span class="line">         (<span class="name">milliseconds</span> (<span class="name">local-time</span><span class="symbol">:timestamp-millisecond</span> now)))</span><br><span class="line">    (<span class="name">+</span> (<span class="name">*</span> <span class="number">1000</span> seconds) milliseconds)))</span><br></pre></td></tr></table></figure>
<h2 id="如何获取机器ID"><a href="#如何获取机器ID" class="headerlink" title="如何获取机器ID"></a>如何获取机器ID</h2><p>这里参考了Sony的雪花ID算法中的思路，基于机器的内网IP地址来生成机器ID。当然了，Common Lisp标准中是没有提供获取机器的内网IP地址的方法的，这一点也可以借助于第三方库实现，选用的是<a href="https://common-lisp.net/project/ip-interfaces/" target="_blank" rel="noopener"><code>ip-interfaces</code></a>。通过这个库提供的<code>get-ip-interfaces</code>函数可以获取到机器的所有“接口”，遍历这个接口的列表后即可找出其中的内网IP。一台机器可能会有多个内网IP，我的方法是选用了第一个找到的内网IP地址。当然了，还需要一个将向量转化为数值的函数，并取出转化为数值后的IP地址的低10位，作为机器ID。</p>
<h2 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h2><p>如果希望生成的ID是保持递增的，那么就需要维护一个可以原子递增的数值计数器。在真实的使用中可以通过Redis的INCR指令来生成这一个ID，但是因为这里的雪花ID算法是作为一个独立的库实现的，不需要依赖于数据库等外部组建，因此这里就直接使用了Common Lisp自带的<code>random</code>函数来生成这个序号了。</p>
<p>全文完</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2017/04/30/如何使用CL实现snowflake/" data-id="cjs9voc3s000kc030ju0jorpk" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2017/04/30/如何使用CL实现snowflake/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/common-lisp/">common lisp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何检查一组区间中是否存在两个区间有交集" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/如何检查一组区间中是否存在两个区间有交集/" class="article-date">
  <time datetime="2017-03-19T14:49:46.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/如何检查一组区间中是否存在两个区间有交集/">如何检查一组区间中是否存在两个区间有交集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>假设有N个区间，将它们表达为<img src="http://latex.codecogs.com/gif.latex?%5Bb_i,%20e_i%5D" alt="">，其中下标i位于区间<img src="http://latex.codecogs.com/gif.latex?%5B0,%20N-1%5D" alt="">中</p>
<p>为了判定这组区间中是否存在两个区间是有重叠的，首先对这组区间进行排序，使得对于排序后的每一个区间<img src="http://latex.codecogs.com/gif.latex?%5B0,%20N-1%5D" alt="">而言，都有<img src="http://latex.codecogs.com/gif.latex?b_i%20%3C%20b_%7Bi+1%7D" alt="">（这里的i小于N-1）。</p>
<p>为了说明要如何判定这些区间中是否存在重叠，首先我们假设这其中确实存在着至少两个这样的区间，假设分别是第j个和第k个（假设j小于k），它们必然会满足这样的关系</p>
<p><img src="http://latex.codecogs.com/gif.latex?e_j%20%3E%20b_k" alt=""></p>
<p>这是因为如果<img src="http://latex.codecogs.com/gif.latex?e_j%20%3C%20b_k" alt="">，那么所有位于区间<img src="http://latex.codecogs.com/gif.latex?%5Bb_j,%20e_j%5D" alt="">中的数都将会小于 b_k，那么第j个区间与第k个区间就不可能有交集了，因此上述不等式一定成立。再加上这一组区间都是按照区间的下界递增排序的，那么必然有</p>
<p><img src="http://latex.codecogs.com/gif.latex?b_j%20%3C%20b_k%20%3C%20e_j" alt=""></p>
<p>假设<img src="http://latex.codecogs.com/gif.latex?k%20-%20j%20%3E%201" alt="">，由于k和j都是正整数，这意味着在第j和第k个区间之间，必然还存在着一个区间l，那么这个区间的必然满足</p>
<p><img src="http://latex.codecogs.com/gif.latex?b_j%20%3C%20b_l" alt=""></p>
<p><img src="http://latex.codecogs.com/gif.latex?e_j%20%3E%20b_k%20%3E%20b_l" alt=""></p>
<p>这就意味着第j个区间和第l个区间也存在交集，它们的交集是子区间<img src="http://latex.codecogs.com/gif.latex?%5Bb_l,%20e_j%5D" alt="">（这里假设<img src="http://latex.codecogs.com/gif.latex?e_l%20%3E%20e_j" alt="">）。这就说明了，如果可以在一组区间中找到两个不相邻的区间，它们存在重叠的部分，那么一定可以找到第三个区间，使得这个区间与其中的一个区间也存在重叠。</p>
<p>这表示如果我们要判定一组区间是否存在重叠，那么只需要先将它们基于区间的起点按照递增排序后，比较每一对相邻的两个区间是否存在重叠即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2017/03/19/如何检查一组区间中是否存在两个区间有交集/" data-id="cjs9voc3v000uc0302mui8328" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2017/03/19/如何检查一组区间中是否存在两个区间有交集/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何安装及使用Elastic-Search" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/如何安装及使用Elastic-Search/" class="article-date">
  <time datetime="2017-03-08T09:31:32.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/如何安装及使用Elastic-Search/">如何安装及使用Elastic Search</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近产品需要一个搜索商城中的商品的功能，于是接触了一下Elastic Search。虽然久仰它的大名，但一直都没有真正用过。这次稍微摸索了一下，顺便记录下来，说不定哪天就真的需要用上了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先需要下载Elastic Search，我选择了.zip格式的安装包，下载地址在<a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.zip" target="_blank" rel="noopener">这里</a>。下载完成后就拿到了一个5.2.2版本的Elastic Search的安装包，只需要解压即可使用。因为我喜欢把软件安装到主目录的app目录下，所以我用的命令是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/liutos/app</span><br><span class="line">unzip ../installer/elasticsearch-5.2.2.zip</span><br></pre></td></tr></table></figure>
<p>主目录下的installer是我习惯的用来存放软件的安装包的位置。解压后生成了一个名为elasticsearch-5.2.2的新目录。在这个目录下有一个名为bin的子目录，只需要进入该目录运行其中的elasticsearch文件即可，实例命令为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-5.2.2/bin</span><br><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure>
<p>为了让Elastic Search可以不占用当前的终端，添加了-d选项，使其以后台进程（daemon）的方式运行。Elastic Search需要JVM才能运行，在执行上面的命令之前请各位自行准备好Java程序的运行环境。成功启动后，Elastic Search默认会监听9200端口，可以通过浏览器访问<a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a>来确认Elastic Search是否正常启动了</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>遵照官方文档中的指导，先创建一个索引以便后续向这个索引中添加文档。假设要创建的索引是为商品准备的，取名为products，可以通过如下的命令创建出来</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT <span class="string">'http://localhost:9200/products'</span></span><br></pre></td></tr></table></figure>
<p>创建成功后Elastic Search的响应结果为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"acknowledged"</span>:<span class="literal">true</span>,<span class="string">"shards_acknowledged"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果希望Elastic Search返回更可读的形式，可以添加<code>?pretty</code>参数到上面的URL的末尾。</p>
<h2 id="文档的增删查改"><a href="#文档的增删查改" class="headerlink" title="文档的增删查改"></a>文档的增删查改</h2><p>索引已经创建了，就可以创建文档了。Elastic Search的文档是对象形式的，假设现在要创建的对象的类型为product，示例命令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'http://localhost:9200/products/product'</span> --data <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "id": 1,</span></span><br><span class="line"><span class="string">  "name": "Product 1"</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>在我的机器上，Elastic Search的响应结果为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"_index"</span>:<span class="string">"products"</span>,<span class="string">"_type"</span>:<span class="string">"product"</span>,<span class="string">"_id"</span>:<span class="string">"AVqpZHmVckriR6iVcbaW"</span>,<span class="string">"_version"</span>:1,<span class="string">"result"</span>:<span class="string">"created"</span>,<span class="string">"_shards"</span>:&#123;<span class="string">"total"</span>:2,<span class="string">"successful"</span>:1,<span class="string">"failed"</span>:0&#125;,<span class="string">"created"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中名为”_id”的字段的值为Elastic Search自动为这份新写入的文档分配的ID，通过这个ID可以从Elastic Search中取出这份文档，示例命令如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'http://localhost:9200/products/product/AVqpZHmVckriR6iVcbaW?pretty'</span></span><br></pre></td></tr></table></figure>
<p>相当的RESTful的接口路径，也许你已经猜到了，删除一个文档的代码就是将请求的GET方法替换为DELETE。是的，示例代码如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE <span class="string">'http://localhost:9200/products/product/AVqpZHmVckriR6iVcbaW?pretty'</span></span><br></pre></td></tr></table></figure>
<p>再次查找刚才的ID的文档时，响应结果中的”_found”字段的值就已经变成了false了。关于修改文档的方法，请参考官方手册中的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html" target="_blank" rel="noopener">章节</a>。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>最简单的搜索接口的使用就是通过浏览器访问<a href="http://localhost:9200/products/_search" target="_blank" rel="noopener">http://localhost:9200/products/_search</a>这个地址了。在我的机器上，看到的页面内容为如下的JSON字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">"took"</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="string">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"_shards"</span>: &#123;</span><br><span class="line">        <span class="string">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"hits"</span>: &#123;</span><br><span class="line">        <span class="string">"total"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"max_score"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="string">"hits"</span>: [ ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便接下来的演示，先通过Elastic Search的_bulk接口向其批量创建文档数据，示例代码如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'http://localhost:9200/_bulk?pretty'</span> --data-binary <span class="string">'@docs'</span></span><br></pre></td></tr></table></figure>
<p>其中docs文件中的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;create&quot;: &#123;&quot;_index&quot;: &quot;products&quot;, &quot;_type&quot;: &quot;product&quot;, &quot;_id&quot;: 1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;设计模式之禅&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;: &#123;&quot;_index&quot;: &quot;products&quot;, &quot;_type&quot;: &quot;product&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;失控：全人类的最终命运和结局&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;: &#123;&quot;_index&quot;: &quot;products&quot;, &quot;_type&quot;: &quot;product&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;构建高性能Web站点&quot;, &quot;price&quot;: 75.00, &quot;author&quot;: &quot;郭欣&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;: &#123;&quot;_index&quot;: &quot;products&quot;, &quot;_type&quot;: &quot;product&quot;, &quot;_id&quot;: 4&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;大型网站技术架构：核心原理与案例分析&quot;, &quot;price&quot;: 59.00, &quot;author&quot;: &quot;李智慧&quot;, &quot;publisher&quot;: &quot;电子工业出版社&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>尽管这里是一个文本文件，但是根据<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html" target="_blank" rel="noopener">官方文档</a>的说法，此处需要使用curl的二进制模式来发送数据，否则会报错。</p>
<h3 id="个性化搜索"><a href="#个性化搜索" class="headerlink" title="个性化搜索"></a>个性化搜索</h3><p>如果希望找到《失控》这本书的信息，那么可以根据书名进行查找，示例代码如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">'http://localhost:9200/products/_search?q=name:失控'</span></span><br></pre></td></tr></table></figure>
<p>Elastic Search提供了许多的搜索选项，如果全部通过URL中的query string来传递将会非常难以构造。为此，可以使用Elastic Search提供的基于HTTP body的参数传递方式，示例代码如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/products/_search'</span> --data <span class="string">'&#123;"query": &#123;"match": &#123;"name": "失控"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<p>Elastic Search支持相当丰富的搜索选项，这里不逐一介绍了，大家可以从官方文档的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html" target="_blank" rel="noopener">这里</a>开始翻看。本来想在Chrome的POSTMAN插件中试验搜索功能的，结果当我选定了GET方法后，就不需要我提交HTTP body了，因此还是用curl进行演示。回到正题，如果我们搜索的是一个“站”字，那么Elastic Search会吐出两个结果，此处可以使用搜索接口的<code>from</code>和<code>size</code>参数，分别控制返回的内容取自搜索结果中的哪一个片段。例如想要取出结果中的第二个，可以使用下列代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/products/_search?pretty'</span> --data <span class="string">'&#123;"from": 1, "size": 1, "query": &#123;"match": &#123;"name": "站"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<p>通过结合使用<code>from</code>和<code>size</code>参数，可以实现许多应用中所要求的分页功能。在我厂的业务场景中，商品信息还是很多的，不可能全部放入到Elastic Search中作为文档数据存储，Elastic Search只是负责提供搜索出来的商品ID即可，之后再通过商品ID从原来的商品的数据库中按照顺序取出对应的完整的商品信息。因此，在搜索Elastic Search时实际上只需要商品的ID就足够了，可以通过Elastic Search提供的<code>_source</code>字段控制接口吐出的内容，示例代码如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET <span class="string">'http://localhost:9200/products/_search?pretty'</span> --data <span class="string">'&#123;"query": &#123;"match_all": &#123;&#125;&#125;, "_source": ["_id"]&#125;'</span></span><br></pre></td></tr></table></figure>
<p>这样在吐出的内容中<code>_source</code>字段的值就会是一个空对象，应用程序只需要取每一个hits数组中的记录的”_id”字段即可。这样做的目的是减少Elastic Search通过网络传输了一部分毫无必要的数据，略微优化一下网络开销</p>
<p>全文完</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2017/03/08/如何安装及使用Elastic-Search/" data-id="cjs9voc3u000pc030xgkrrsdi" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2017/03/08/如何安装及使用Elastic-Search/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何用Common-Lisp实现尾递归优化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/23/如何用Common-Lisp实现尾递归优化/" class="article-date">
  <time datetime="2017-02-23T14:58:07.000Z" itemprop="datePublished">2017-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/23/如何用Common-Lisp实现尾递归优化/">如何用Common Lisp实现尾递归优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h2><p>如果一个函数在定义时引用了自身，那么这个函数就是一个递归函数。例如我们所熟知的阶乘就可以通过递归函数的形式予以定义</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> fact (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&lt;=</span> n <span class="number">0</span>)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      (<span class="name">*</span> n (<span class="name">fact</span> (<span class="number">1</span>- n)))))</span><br></pre></td></tr></table></figure>
<p>在if语句的备选路径上，正在定义的函数<code>fact</code>被自身所调用，因此<code>fact</code>就是一个递归函数了。递归有一类较为特殊的形式，叫做尾递归，它们的特征是递归函数的调用位于被定义函数的最后一个步骤。也就是说，这个递归调用的返回值也就是整个函数调用的返回值，后面不再有其它的计算步骤了。例如实现了辗转相除法的下面这个函数就是尾递归的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-gcd (<span class="name">a</span> b)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">zerop</span> a) b)</span><br><span class="line">        ((<span class="name">zerop</span> b) a)</span><br><span class="line">        (<span class="name">t</span> (<span class="name">my-gcd</span> b (<span class="name">mod</span> a b)))))</span><br></pre></td></tr></table></figure>
<p>此处命名为<code>my-gcd</code>，是因为在Common Lisp中已经预置了一个叫做<code>gcd</code>的函数了</p>
<h2 id="什么是尾递归优化"><a href="#什么是尾递归优化" class="headerlink" title="什么是尾递归优化"></a>什么是尾递归优化</h2><p>递归调用其实也就是函数调用，每一次调用都需要保存当前的执行上下文（寄存器的值、程序计数器的值等信息）并压入栈中。如果递归调用得非常深，那么很可能将栈空间消耗殆尽导致程序崩溃，因此很多时候都会选择使用循环来实现用递归实现的效果。尾递归形式的一个优势，就在于编译器可以对其进行优化，使得原本需要添加一个栈帧的函数调用操作，直接重用当前的调用中所使用的栈帧即可。这样一来，递归函数的调用就不会无节制地消耗栈空间了。</p>
<p>另一种对尾递归进行优化的方式，则是将其改写为【赋值】与【跳转】。例如对于上面的<code>my-gcd</code>函数，可以改写为如下形式</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-gcd (<span class="name">a</span> b)</span><br><span class="line">  (<span class="name">tagbody</span></span><br><span class="line">   rec</span><br><span class="line">     (<span class="name">cond</span> ((<span class="name">zerop</span> a) (<span class="name">return-from</span> my-gcd b))</span><br><span class="line">           ((<span class="name">zerop</span> b) (<span class="name">return-from</span> my-gcd a))</span><br><span class="line">           (<span class="name">t</span> (<span class="name">progn</span></span><br><span class="line">                (<span class="name">psetf</span> a b</span><br><span class="line">                       b (<span class="name">mod</span> a b))</span><br><span class="line">                (<span class="name">go</span> rec))))))</span><br></pre></td></tr></table></figure>
<h2 id="如何在Common-Lisp中实现"><a href="#如何在Common-Lisp中实现" class="headerlink" title="如何在Common Lisp中实现"></a>如何在Common Lisp中实现</h2><p>如果要使用递归的形式定义一个计算列表长度的函数，那么很可能会写出这样子的代码</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-length (<span class="name">lst</span>)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="number">1</span>+ (<span class="name">my-length</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure>
<p>采用累加器的思路，可以将上述函数改写为下面的尾递归形式</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-length (<span class="name">lst</span> acc)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">      acc</span><br><span class="line">      (<span class="name">my-length</span> (<span class="name">rest</span> lst) (<span class="number">1</span>+ acc))))</span><br></pre></td></tr></table></figure>
<p>对于第二个版本的<code>my-length</code>函数，同样可以手动改写为基于【赋值】和【跳转】的实现形式，结果如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-length (<span class="name">lst</span> acc)</span><br><span class="line">  (<span class="name">tagbody</span></span><br><span class="line">   rec</span><br><span class="line">     (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">         (<span class="name">return-from</span> my-length acc)</span><br><span class="line">         (<span class="name">progn</span></span><br><span class="line">           (<span class="name">psetf</span> lst (<span class="name">rest</span> lst)</span><br><span class="line">                  acc (<span class="number">1</span>+ acc))</span><br><span class="line">           (<span class="name">go</span> rec)))))</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了，<code>my-gcd</code>和<code>my-length</code>函数的改写都是很有规律的，甚至可以通过一个宏来帮助我们自动完成这种变换。这个宏所需要做的事情其实只有三件：</p>
<ol>
<li>将原本的定义中的函数体包裹在一个<code>tagbody</code>中</li>
<li>将原本作为返回值的表达式包裹在一个<code>return-from</code>中</li>
<li>将递归调用的表达式改为按顺序执行的<code>psetf</code>和<code>go</code>的组合</li>
</ol>
<p>为了降低一下实现难度，第二点暂时就不处理了，函数的实现者必须手动编写<code>return-from</code>语句。因此，如果只考虑首尾两个条件，首先，可以考虑实现第三条，将函数体内的递归调用修改为<code>progn</code>、<code>psetf</code>和<code>go</code>的组合。要实现这个变换，可以使用<code>macrolet</code>，如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> my-length (<span class="name">lst</span> acc)</span><br><span class="line">  (<span class="name">tagbody</span></span><br><span class="line">   rec</span><br><span class="line">     (<span class="name">macrolet</span> ((<span class="name">my-length</span> (<span class="name">&amp;rest</span> args)</span><br><span class="line">                  `(progn</span><br><span class="line">                     (psetf ,@(mapcan #'list '(lst acc) args))</span><br><span class="line">                     (go rec))))</span><br><span class="line">       (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">           (<span class="name">return-from</span> my-length acc)</span><br><span class="line">           (<span class="name">my-length</span> (<span class="name">rest</span> lst) (<span class="number">1</span>+ acc))))))</span><br></pre></td></tr></table></figure>
<p>为了自动生成上面的代码，我编写了这样的一个宏</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> define-rec (<span class="name">name</span> lambda-list <span class="symbol">&amp;body</span> body)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">rec</span> (<span class="name">gensym</span>)))</span><br><span class="line">    `(defun ,name ,lambda-list</span><br><span class="line">       (tagbody</span><br><span class="line">          ,rec</span><br><span class="line">          (macrolet ((,name (&amp;rest exprs)</span><br><span class="line">                       ,``(progn</span><br><span class="line">                            (psetf ,@(mapcan #'list ',lambda-list exprs))</span><br><span class="line">                            (go ,',rec))))</span><br><span class="line">            ,@body)))))</span><br></pre></td></tr></table></figure>
<p>利用上面这个宏编写一个计算列表长度的尾递归形式的函数，代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-rec</span> my-length (<span class="name">lst</span> acc)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span> lst)</span><br><span class="line">      (<span class="name">return-from</span> my-length acc)</span><br><span class="line">      (<span class="name">my-length</span> (<span class="name">rest</span> lst) (<span class="number">1</span>+ acc))))</span><br></pre></td></tr></table></figure>
<p>利用<code>macroexpand-1</code>或者是SLIME提供的展开一次宏的调试功能，在我的及其上得到的代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">DEFUN</span> MY-LENGTH (<span class="name">LST</span> ACC)</span><br><span class="line">  (<span class="name">TAGBODY</span></span><br><span class="line">   #<span class="symbol">:G937</span></span><br><span class="line">    (<span class="name">MACROLET</span> ((<span class="name">MY-LENGTH</span> (<span class="name">&amp;REST</span> EXPRS)</span><br><span class="line">                 `(PROGN</span><br><span class="line">                   (PSETF ,@(MAPCAN #'LIST '(LST ACC) EXPRS))</span><br><span class="line">                   (GO ,'#:G937))))</span><br><span class="line">      (<span class="name">IF</span> (<span class="name">NULL</span> LST)</span><br><span class="line">          (<span class="name">RETURN-FROM</span> MY-LENGTH ACC)</span><br><span class="line">          (<span class="name">MY-LENGTH</span> (<span class="name">REST</span> LST) (<span class="number">1</span>+ ACC))))))</span><br></pre></td></tr></table></figure>
<p>跟上面手写的代码没有太大的差别，并且用于计算所得到的列表长度也是正确的。那么如何验证这个函数是采用了【赋值】和【跳转】的机制来完成运算的呢？可以借助Common Lisp提供的<code>trace</code>函数。如果使用的真实执行递归调用的<code>my-length</code>函数的定义，那么执行<code>(trace my-length)</code>后运行<code>(my-length &#39;(1 2 4 5) 0)</code>，在我的机器上会输出如下内容</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">my-length</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">0</span>)</span><br><span class="line">  0: (MY-LENGTH (1 2 4 5) 0)</span><br><span class="line">    1: (MY-LENGTH (2 4 5) 1)</span><br><span class="line">      2: (MY-LENGTH (4 5) 2)</span><br><span class="line">        3: (MY-LENGTH (5) 3)</span><br><span class="line">          4: (MY-LENGTH NIL 4)</span><br><span class="line">          4: MY-LENGTH returned 4</span><br><span class="line">        3: MY-LENGTH returned 4</span><br><span class="line">      2: MY-LENGTH returned 4</span><br><span class="line">    1: MY-LENGTH returned 4</span><br><span class="line">  0: MY-LENGTH returned 4</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>而如果是使用<code>define-rec</code>宏定义的<code>my-length</code>，求值同样的表达式的输出为</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">my-length</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span>) <span class="number">0</span>)</span><br><span class="line">  0: (MY-LENGTH (1 2 4 5) 0)</span><br><span class="line">  0: MY-LENGTH returned 4</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>显然，这当中没有递归的函数调用，<code>my-length</code>确实不需要调用自身。</p>
<p>全文完</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liutos.github.io/2017/02/23/如何用Common-Lisp实现尾递归优化/" data-id="cjs9voc3u000rc030bsx99yq9" class="article-share-link">Share</a>
      
        <a href="https://liutos.github.io/2017/02/23/如何用Common-Lisp实现尾递归优化/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/common-lisp/">common lisp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tail-recursion/">tail recursion</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/尾递归/">尾递归</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2018/">2018</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/alfred/">alfred</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bash/">bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs/">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boostnote/">boostnote</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/closure/">closure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/common-lisp/">common lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cps/">cps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dynamic-programming/">dynamic programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/editor/">editor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elisp/">elisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/emacs/">emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/find/">find</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grep/">grep</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gtd/">gtd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/head/">head</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/install/">install</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lisp/">lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macbook/">macbook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macro/">macro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongo/">mongo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note-taking/">note taking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oop/">oop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/org-mode/">org-mode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project-euler/">project euler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/recursion/">recursion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/restart/">restart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/search/">search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sequence-diagram/">sequence diagram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sort/">sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/squid/">squid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tail-recursion/">tail recursion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tutorial/">tutorial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/">typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yu-writer/">yu writer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安装/">安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/宏/">宏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/尾递归/">尾递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索/">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记类软件/">笔记类软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器/">编辑器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/闭包/">闭包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象/">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/2018/" style="font-size: 10px;">2018</a> <a href="/tags/alfred/" style="font-size: 15px;">alfred</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/bfs/" style="font-size: 10px;">bfs</a> <a href="/tags/boostnote/" style="font-size: 10px;">boostnote</a> <a href="/tags/closure/" style="font-size: 10px;">closure</a> <a href="/tags/common-lisp/" style="font-size: 20px;">common lisp</a> <a href="/tags/cps/" style="font-size: 10px;">cps</a> <a href="/tags/dynamic-programming/" style="font-size: 10px;">dynamic programming</a> <a href="/tags/editor/" style="font-size: 10px;">editor</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/elisp/" style="font-size: 10px;">elisp</a> <a href="/tags/emacs/" style="font-size: 17.5px;">emacs</a> <a href="/tags/find/" style="font-size: 10px;">find</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/grep/" style="font-size: 10px;">grep</a> <a href="/tags/gtd/" style="font-size: 10px;">gtd</a> <a href="/tags/head/" style="font-size: 10px;">head</a> <a href="/tags/install/" style="font-size: 10px;">install</a> <a href="/tags/lisp/" style="font-size: 10px;">lisp</a> <a href="/tags/macbook/" style="font-size: 10px;">macbook</a> <a href="/tags/macro/" style="font-size: 10px;">macro</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mongo/" style="font-size: 10px;">mongo</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/note-taking/" style="font-size: 10px;">note taking</a> <a href="/tags/oop/" style="font-size: 10px;">oop</a> <a href="/tags/org-mode/" style="font-size: 12.5px;">org-mode</a> <a href="/tags/project-euler/" style="font-size: 17.5px;">project euler</a> <a href="/tags/recursion/" style="font-size: 10px;">recursion</a> <a href="/tags/restart/" style="font-size: 10px;">restart</a> <a href="/tags/search/" style="font-size: 10px;">search</a> <a href="/tags/sequence-diagram/" style="font-size: 10px;">sequence diagram</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/sort/" style="font-size: 10px;">sort</a> <a href="/tags/squid/" style="font-size: 10px;">squid</a> <a href="/tags/tail-recursion/" style="font-size: 10px;">tail recursion</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/tutorial/" style="font-size: 12.5px;">tutorial</a> <a href="/tags/typora/" style="font-size: 10px;">typora</a> <a href="/tags/yu-writer/" style="font-size: 10px;">yu writer</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/安装/" style="font-size: 10px;">安装</a> <a href="/tags/宏/" style="font-size: 10px;">宏</a> <a href="/tags/尾递归/" style="font-size: 10px;">尾递归</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/搜索/" style="font-size: 10px;">搜索</a> <a href="/tags/教程/" style="font-size: 12.5px;">教程</a> <a href="/tags/数学/" style="font-size: 15px;">数学</a> <a href="/tags/笔记类软件/" style="font-size: 10px;">笔记类软件</a> <a href="/tags/算法/" style="font-size: 12.5px;">算法</a> <a href="/tags/编辑器/" style="font-size: 10px;">编辑器</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a> <a href="/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/tags/面向对象/" style="font-size: 10px;">面向对象</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/05/拿Emacs对接我的cuckoo/">拿Emacs对接我的cuckoo</a>
          </li>
        
          <li>
            <a href="/2019/01/28/Project-Euler第69题/">Project-Euler第69题</a>
          </li>
        
          <li>
            <a href="/2019/01/11/一些在Emacs中搜索文本的方法/">一些在Emacs中搜索文本的方法</a>
          </li>
        
          <li>
            <a href="/2019/01/07/Emacs的org-mode实现自动的internal-archive/">Emacs的org-mode实现自动的internal archive</a>
          </li>
        
          <li>
            <a href="/2018/12/29/2018年度技术总结/">2018年度技术总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'Liutos';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>