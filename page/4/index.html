<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">







<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://liutos.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

<script data-ad-client="ca-pub-4199841931601311" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta name="description" content="记录编程生涯的大大小小的事情">
<meta name="keywords" content="emacs,lisp,programming">
<meta property="og:type" content="website">
<meta property="og:title" content="小打小闹写点bug">
<meta property="og:url" content="https://liutos.github.io/page/4/index.html">
<meta property="og:site_name" content="小打小闹写点bug">
<meta property="og:description" content="记录编程生涯的大大小小的事情">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小打小闹写点bug">
<meta name="twitter:description" content="记录编程生涯的大大小小的事情">

<link rel="canonical" href="https://liutos.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>小打小闹写点bug</title>
  
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-94082039-2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-94082039-2');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext');loadCss('//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小打小闹写点bug</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">乍听之下，不无道理；仔细揣摩，胡说八道</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Liutos" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2020/06/25/MySQL的NOT-EXISTS遭遇战/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/25/MySQL的NOT-EXISTS遭遇战/" class="post-title-link" itemprop="url">MySQL的NOT EXISTS遭遇战</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-25 22:12:40 / 修改时间：22:15:19" itemprop="dateCreated datePublished" datetime="2020-06-25T22:12:40+08:00">2020-06-25</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/06/25/MySQL的NOT-EXISTS遭遇战/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/25/MySQL的NOT-EXISTS遭遇战/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浅尝一下NOT-EXISTS"><a href="#浅尝一下NOT-EXISTS" class="headerlink" title="浅尝一下NOT EXISTS"></a>浅尝一下<code>NOT EXISTS</code></h1><p>最近老婆在看视频学习MySQL，然后碰到了这样一道习题：有三个表，分别记录学生、课程，以及学生选修了什么课程的信息，问如何用<code>NOT EXISTS</code>找出选修了所有课程的学生。</p>
<p>为了避免想破脑袋编造一些尴尬的学生姓名和课程名，我简化了一下习题中的表的结构，只留下它们的ID列。建表语句如下</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选修关系</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`elective`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`student`</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`course_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`course`</span>(<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>还需要给它们塞入一些示例数据</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>), (<span class="number">4</span>), (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> (<span class="string">`id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`elective`</span> (<span class="string">`course_id`</span>, <span class="string">`student_id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>显然，只有<code>id</code>列的值为1和5的学生是选修了全部课程的。用<code>NOT EXISTS</code>写出来的SQL语句如下</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>   <span class="string">`student`</span> </span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">                   <span class="keyword">FROM</span>   <span class="string">`course`</span> </span><br><span class="line">                   <span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">                                      <span class="keyword">FROM</span>   <span class="string">`elective`</span> </span><br><span class="line">                                      <span class="keyword">WHERE</span>  <span class="string">`student`</span>.<span class="string">`id`</span> = </span><br><span class="line">                                             <span class="string">`elective`</span>.<span class="string">`student_id`</span> </span><br><span class="line">                                             <span class="keyword">AND</span> <span class="string">`course`</span>.<span class="string">`id`</span> = </span><br><span class="line">                                     <span class="string">`elective`</span>.<span class="string">`course_id`</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>在<a href="https://dbeaver.io/" target="_blank" rel="noopener">DBEaver</a>中运行后的结果为</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200625/双重NOT_EXISTS的执行结果.jpg" alt="在DBEaver中执行的结果"></p>
<p>正确地找出了两个选修了所有课程的学生的<code>id</code>。</p>
<h1 id="如何理解双重NOT-EXISTS"><a href="#如何理解双重NOT-EXISTS" class="headerlink" title="如何理解双重NOT EXISTS"></a>如何理解双重<code>NOT EXISTS</code></h1><p>当第一次被请教这道习题的时候，我其实并不能理解<code>NOT EXISTS</code>的含义。直到后来去看<code>EXISTS</code>的<a href="https://dev.mysql.com/doc/refman/8.0/en/exists-and-not-exists-subqueries.html" target="_blank" rel="noopener">文档</a>，才顿悟了上面的SQL。</p>
<p>我的理解方法是将双重<code>NOT EXISTS</code>转换为三层循环。以上面的SQL为例，转述为人话就是：找出<code>student</code>表中所有的、<strong>没有</strong>任何一门<code>course</code>表中的课程是<strong>没有</strong>选修的、的学生——双重的 <strong>没有</strong>。</p>
<p>转换为三层循环大概长这样</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> student <span class="keyword">of</span> students) {</span><br><span class="line">  <span class="comment">// 是否存在学生未选修的课程</span></span><br><span class="line">  <span class="keyword">let</span> existSuchCourse = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> course <span class="keyword">of</span> courses) {</span><br><span class="line">    <span class="keyword">let</span> existSuchElective = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> elective <span class="keyword">of</span> electives) {</span><br><span class="line">      <span class="keyword">if</span> (elective.student_id === student.id &amp;&amp; elective.course_id === course.id) {</span><br><span class="line">        existSuchElective = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果遍历完elective表的记录后，existSuchElective仍然为false，说明的确有一门课程是没有选修记录的</span></span><br><span class="line">    <span class="comment">// 那么便意味着“存在至少一门课程，使得当前被遍历的学生与该课程没有选修关系”。</span></span><br><span class="line">    <span class="keyword">if</span> (!existSuchElective) {</span><br><span class="line">      existSuchCourse = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果遍历完一圈后确实没有找到“未选修”的课程，说明这名学生全都选修了</span></span><br><span class="line">  <span class="keyword">if</span> (!existSuchCourse) {</span><br><span class="line">    <span class="built_in">console</span>.log(student);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="NOT-EXISTS的本质"><a href="#NOT-EXISTS的本质" class="headerlink" title="NOT EXISTS的本质"></a><code>NOT EXISTS</code>的本质</h1><p>即使不强行理解，也可以让MySQL明确告知双重<code>NOT EXISTS</code>是怎么运作的。用<code>EXPLAIN</code>解释上面的SQL的结果如下图所示</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200625/双重NOT_EXISTS的EXPLAIN结果.jpg" alt=""></p>
<p>MySQL的<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN命令的文档</a>中说明了如何解读执行计划</p>
<blockquote>
<p>EXPLAIN returns a row of information for each table used in the SELECT statement. It lists the tables in the output in the order that MySQL would read them while processing the statement. This means that MySQL reads a row from the first table, then finds a matching row in the second table, and then in the third table, and so on. When all tables are processed, MySQL outputs the selected columns and backtracks through the table list until a table is found for which there are more matching rows. The next row is read from this table and the process continues with the next table.</p>
</blockquote>
<p>以上面的<code>EXPLAIN</code>为例，MySQL从<code>student</code>表中读出一行，再从<code>course</code>表中读取一行，最后从<code>elective</code>表中读取一行，然后看看<code>WHERE</code>子句是否能够被满足。如果可以，就输出从<code>student</code>表中读出来的这行数据。上图第2和第3行的<code>select_type</code>都是<code>DEPENDENT SUBQUERY</code>，表示它们依赖于“外层”的查询上下文——<code>elective</code>的<code>WHERE</code>子句依赖于<code>student</code>和<code>course</code>中读出来的行。</p>
<p>似乎和方才的三重循环有异曲同工之妙呢。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>像<code>NOT EXISTS</code>这么“高阶”的功能我从未在业务代码中读过和使用过——别说<code>NOT EXISTS</code>，就算是<code>EXISTS</code>也是从未有之，甚至连子查询也极少。毕竟“正经的互联网公司”只是把MySQL<del>当妹妹</del>当一个具备复杂查询查询功能的key-value数据库来使用（笑</p>
<p>比起双重<code>NOT EXISTS</code>，我更可能凭直觉写出基于子查询的解决方法</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>   <span class="string">`student`</span> </span><br><span class="line"><span class="keyword">WHERE</span>  <span class="string">`id`</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="string">`student_id`</span> </span><br><span class="line">                <span class="keyword">FROM</span>   <span class="string">`elective`</span> </span><br><span class="line">                <span class="keyword">GROUP</span>  <span class="keyword">BY</span> <span class="string">`student_id`</span> </span><br><span class="line">                <span class="keyword">HAVING</span>( <span class="keyword">Count</span>(<span class="number">0</span>) ) = <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>我甚至觉得会有人把数据库里的行读进内存然后用应用层代码来找出选修了全部课程的学生！</p>
<p>全文完。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2020/06/10/用org-mode管理API测试用例/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/10/用org-mode管理API测试用例/" class="post-title-link" itemprop="url">用org-mode管理API测试用例</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-10 21:31:58 / 修改时间：21:58:19" itemprop="dateCreated datePublished" datetime="2020-06-10T21:31:58+08:00">2020-06-10</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/06/10/用org-mode管理API测试用例/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/10/用org-mode管理API测试用例/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="API测试用例是什么？"><a href="#API测试用例是什么？" class="headerlink" title="API测试用例是什么？"></a>API测试用例是什么？</h1><p>在互联网大行其道的今天，身为一名电商平台的程序员，必定经常与HTTP API打交道，一个常见的情况便是做API测试。抛开可以用单元测试代替的，很多时候需要真地发出HTTP请求才行。这些负责发出HTTP请求的东西可能是一行<code>curl</code>命令，可能是一个<code>.js</code>文件，也可能是一个在postman中点击按钮的操作，但不管形态如何，它们便是API测试用例。尽管名字中带有“用例”二字，但很多时候是由人来校验结果的，用例更关注发出怎样的HTTP请求。</p>
<h1 id="为什么要管理它们？"><a href="#为什么要管理它们？" class="headerlink" title="为什么要管理它们？"></a>为什么要管理它们？</h1><p>不同于每天在浏览器中发生成千上万次的、平凡的HTTP（或HTTPS）请求，API测试用例是值得一番精心管理的，因为：</p>
<ol>
<li><p>API测试用例通常会重复使用，因此必须将它们持久化保存。也许是保存成shell脚本，也许是保存成脚本语言源文件，也许是保存为某一款软件的数据文件；</p>
</li>
<li><p>需要为多个API编写测试用例，因此必须区分不同的API对应的测试用例。例如，负责管理业务资源的服务（比如一个管理商品数据的、提供RESTful API的服务），起码需要提供增删查改的功能，那么也就需要有增删查改对应的API测试用例；</p>
</li>
<li><p>需要为多个服务的API编写用例，因此必须区分不同的服务对应的测试用例集。例如，既然有商品服务，那么极可能还有订单服务、优惠券服务、物流服务，等等，每个服务又都有增删查改的功能，这些不同服务的API也需要各自的测试用例；</p>
</li>
<li><p>需要区分不同的运行环境。通常本地、开发、测试，以及生产环境是互相隔离的，一个用例中的参数往往不能照搬到另一个环境中。</p>
</li>
</ol>
<p>API、服务，以及环境这三个维度上的区别，使得测试用例的数量显著增加，如不进行管理，当要用时，要么不得不从零开始再写一遍脚本，要么得翻查很久才能找到所需的用例。</p>
<h1 id="用org-mode管理"><a href="#用org-mode管理" class="headerlink" title="用org-mode管理"></a>用org-mode管理</h1><h2 id="org-mode是什么？"><a href="#org-mode是什么？" class="headerlink" title="org-mode是什么？"></a>org-mode是什么？</h2><p><code>org-mode</code>是一款Emacs编辑器的扩展，它让使用者能够用快速高效的纯文本方式来记笔记、维护待办事项、安排计划，以及编写文档。<code>org-mode</code>的精髓在于它的大纲组织能力，以及依托于Emacs的扩展能力，两者使其正好可以胜任管理API测试用例的工作。一个<code>.org</code>文件的示例如下图所示</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/org-mode官网示例.jpg" alt="org-mode官网的示例截图"></p>
<h2 id="如何用org-mode管理API测试用例？"><a href="#如何用org-mode管理API测试用例？" class="headerlink" title="如何用org-mode管理API测试用例？"></a>如何用org-mode管理API测试用例？</h2><p>尽管<code>org-mode</code>提供了丰富的功能，但只是管理API测试用例的话，并用不上太多花里胡哨的东西，只需要<code>org-mode</code>的大纲功能和<code>org-babel</code>特性即可。</p>
<p>首先用不同的<code>.org</code>文件区分不同的环境。</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/用不同的org文件区分环境.jpg" alt=""></p>
<p>接着用不同层级的headline区分不同的服务、资源类型，以及API。</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/用不同层级的headline管理的示例.jpg" alt=""></p>
<p>然后用<code>org-mode</code>的<a href="https://orgmode.org/manual/Structure-of-Code-Blocks.html" target="_blank" rel="noopener">代码块</a>语法来编写HTTP请求。以请求<code>https://httpbin.org/uuid</code>为例</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC restclient</span><br><span class="line">  GET https://httpbin.org/uuid</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></tbody></table></figure>
<p><code>#+BEGIN_SRC</code>和<code>#+END_SRC</code>分别表示开启和结束代码块，<code>restclient</code>表示这个代码块内的代码可以用Emacs的<code>restclient-mode</code>来编辑。在代码块中，<code>GET https://httpbin.org/uuid</code>表示以GET方法请求<code>https://httpbin.org/uuid</code>。</p>
<p>安装了<a href="https://github.com/pashky/restclient.el" target="_blank" rel="noopener"><code>restclient</code></a>后，将光标定位在代码块上并按下<code>ctrl-c '</code>，可以进入一个单独的buffer编辑其中的源代码</p>
<video controls=""><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/进入restclient模式的buffer.mp4" type="video/mp4"><br></video>

<p>最后，如果配置了<code>org-babel</code>，甚至可以直接在代码块上按下<code>ctrl-c ctrl-c</code>来发出HTTP请求。</p>
<p><video controls=""><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/org-mode中发出HTTP请求.mp4" type="video/mp4"><br></video><br>可以看到，HTTP响应的内容会保留在这个<code>.org</code>文件中。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以前我也用过其它的工具来管理API测试用例：</p>
<ol>
<li>刚工作的时候用的是Postman，那时候Postman还是Chrome的一个插件；</li>
<li>后来出于对Firefox浏览器的喜爱，找了一个叫RESTClient的插件来代替postman，久而久之发觉两者的差距蛮大，终究无法代替；</li>
<li>接着遇到了Emacs中的<code>restclient.el</code>，于是用了好一段时间的纯<code>restclient-mode</code>（没有搭配<code>org-mode</code>）；</li>
<li>再后来开始用Mac办公了，便开始寻找Mac下的这类工具，遇到了<a href="https://insomnia.rest/" target="_blank" rel="noopener">Insomnia</a>。如果有人找我推荐用于HTTP API测试的GUI工具的话，我会毫无不犹豫地推荐这款。</li>
</ol>
<p>再后来，我又回到了Emacs，并用<code>org-mode</code>来管理这些API测试用例。目前这是最适合我的一种方式。</p>
<p>全文完。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2020/05/22/重定向的时候shell在干什么？/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/22/重定向的时候shell在干什么？/" class="post-title-link" itemprop="url">重定向的时候shell在干什么？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-22 22:49:15 / 修改时间：22:50:16" itemprop="dateCreated datePublished" datetime="2020-05-22T22:49:15+08:00">2020-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/究竟在干什么系列/" itemprop="url" rel="index">
                    <span itemprop="name">究竟在干什么系列</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/22/重定向的时候shell在干什么？/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/22/重定向的时候shell在干什么？/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>“究竟在干什么”是一系列关于软件背后运作原理的文章，每一篇文章旨在讲解一些在日常编程实践中常见但可能并不为人所熟知的技术细节，抛砖引玉，期待激发读者朋友的更多思考。</p>
</blockquote>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>每当需要<code>ssh</code>登录到服务器并运行一个比较花时间的脚本时（比如临时从生产环境导出数据），为了能够知道脚本是否运行结束，或者是否出错退出，我都会将脚本的输出内容重定向到文件中</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node foobar.js &gt; /tmp/foobar.log 2&gt; /tmp/foobar.err</span><br></pre></td></tr></tbody></table></figure>
<p>如果不在乎将正常的打印和错误混在一起，可以写成</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node foobar.js &gt; /tmp/foobar.log 2&gt;&amp;1</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中的<code>2</code>和<code>1</code>分别是标准错误（C语言中的<code>stderr</code>）和标准输出（C语言中的<code>stdout</code>）的文件描述符，<code>2&gt;&amp;1</code>的意思便是将打印到标准错误中的内容<em>转移</em>到标准输出中去——这个<em>转移</em>在shell中的术语便叫做重定向（redirection）。</p>
<h1 id="2-gt-amp-1该放哪里？"><a href="#2-gt-amp-1该放哪里？" class="headerlink" title="2>&amp;1该放哪里？"></a><code>2&gt;&amp;1</code>该放哪里？</h1><p><code>bash</code>的<code>man</code>文档中有一个名为<code>REDIRECTION</code>的章节专门介绍了重定向相关的内容，其中有一段有意思的内容</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/bash的文档中对重定向次序的说明.jpg" alt=""></p>
<p>用<code>ls</code>不方便做演示，我准备了下面这一段Node.js代码</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.error(<span class="string">'Print to standard error.'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Print to standard output.'</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>将代码保存到文件<code>foobar.js</code>中。</p>
<p>如果将<code>2&gt;&amp;1</code>写在后面，那么<code>foobar.log</code>中会包含两行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp node foobar.js &gt; /tmp/foobar.log 2&gt;&amp;1</span><br><span class="line">➜  /tmp cat /tmp/foobar.log</span><br><span class="line">Print to standard error.</span><br><span class="line">Print to standard output.</span><br></pre></td></tr></tbody></table></figure>
<p>否则，<code>foobar.log</code>中只含有一行内容，另一行会出现在终端上</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp node foobar.js 2&gt;&amp;1 &gt; /tmp/foobar.log</span><br><span class="line">Print to standard error.</span><br><span class="line">➜  /tmp cat /tmp/foobar.log</span><br><span class="line">Print to standard output.</span><br></pre></td></tr></tbody></table></figure>
<p>那么为什么会这样呢？</p>
<h1 id="重定向的时候，shell在做些什么？"><a href="#重定向的时候，shell在做些什么？" class="headerlink" title="重定向的时候，shell在做些什么？"></a>重定向的时候，shell在做些什么？</h1><p>以执行<code>node foobar.js &gt; /tmp/foobar.log</code>为例，当shell发现命令中含有重定向的符号时，便开始忙碌起来。</p>
<p>shell首先用<code>open</code>函数打开文件<code>/tmp/foobar.log</code>，拿到一个文件描述符（一个非负整数）。Node.js的<code>fs</code>模块中有一个<code>open</code>方法，在调用成功时，也是往回调函数传入文件描述符</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(<span class="string">'/tmp/cuckoo.log'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`fd for cuckoo.log is <span class="subst">${fd}</span>`</span>);</span><br><span class="line">  fs.open(<span class="string">'/tmp/cuckoo.err'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`fd for cuckoo.err is <span class="subst">${fd}</span>`</span>);</span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>比较奇妙的是，多次运行时拿到的文件描述符总是相同的</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp date; node open.test.js</span><br><span class="line">Fri May 22 21:00:56 CST 2020</span><br><span class="line">fd for cuckoo.log is 21</span><br><span class="line">fd for cuckoo.err is 24</span><br><span class="line">➜  /tmp date; node open.test.js</span><br><span class="line">Fri May 22 21:00:59 CST 2020</span><br><span class="line">fd for cuckoo.log is 21</span><br><span class="line">fd for cuckoo.err is 24</span><br></pre></td></tr></tbody></table></figure>
<p>说回重定向。shell拿到文件描述符后，便调用<code>dup2</code>函数。既然有<code>dup2</code>，那么就有<code>dup</code>。<code>dup</code>接收一个文件描述符作为参数，返回一个新的文件描述符。而<code>dup2</code>则接收两个参数，它可以作为让第二个参数的数字成为一个新的文件描述符，指向与第一个参数相同的文件。</p>
<p>用图形可以更好地表达<code>dup2</code>的实现原理。下图是一个进程没有重定向时的状态，每个文件描述符都指向它们<em>原本</em>对应的文件</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/before_redirect.jpeg" alt=""></p>
<p>作为数字的文件描述符，相当于是<em>文件描述符表</em>的数组下标。调用<code>dup2</code>后，就变成了</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/after_redirect.jpeg" alt=""></p>
<p>可以将<code>dup2</code>理解为：把<em>文件描述符表</em>的一个元素（以<code>dup2</code>的第一个参数作为下标），按位复制到另一个元素中（以<code>dup2</code>的第二个参数作为下标）。</p>
<p>这样一来，凡是写往文件描述符<code>1</code>的数据，其实都写到了文件<code>/tmp/foobar.log</code>中。</p>
<p>所以，如果命令中重定向操作是<code>2&gt;&amp;1 &gt; /tmp/foobar.log</code>，那么文件描述符表中下标1和2的元素并不会指向相同的文件</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/放前面.jpeg" alt=""></p>
<p>如果重定向操作是<code>&gt; /tmp/foobar.log 2&gt;&amp;1</code>，则如下图所示</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/放后面.jpeg" alt=""></p>
<p>因此，此时不管是写往文件描述符1还是2，最终都<em>重定向</em>到了<code>/tmp/foobar.log</code>中。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果想要严谨地知道<code>bash</code>是如何处理重定向的，可以在GitHub的这个<a href="https://github.com/bminor/bash" target="_blank" rel="noopener">Bash源代码镜像</a>上直接查看，找到根目录下的<a href="https://github.com/bminor/bash/blob/master/redir.c" target="_blank" rel="noopener">redir.c</a>文件即可。</p>
<p>此外，对于上面的示意图，维基百科的<a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">File descriptor词条</a>也有一幅更严谨的版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2020/05/07/程序员特有的画图方式——语绘工具小入门/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/程序员特有的画图方式——语绘工具小入门/" class="post-title-link" itemprop="url">程序员特有的画图方式——语绘工具小入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-07 20:37:04 / 修改时间：21:07:31" itemprop="dateCreated datePublished" datetime="2020-05-07T20:37:04+08:00">2020-05-07</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/07/程序员特有的画图方式——语绘工具小入门/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/07/程序员特有的画图方式——语绘工具小入门/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h1><p>虽然程序员多数时候都在与字符打交道，但偶尔也会像建筑或制造业的工程师一样，画一些图，比如：</p>
<ol>
<li>为了表达多个系统如何协作以实现业务需求，会画时序图；</li>
<li>为了表达存储到数据库中的业务实体间的关系，会画ER图；</li>
<li>为了表达复杂的业务实体在整个生存期中状态的变化，会画状态图。</li>
</ol>
<p>除此之外，还有流程图、甘特图、火焰图，等等。</p>
<p>尽管软件开发过程中产出的这些图不一定逼真、漂亮，或严谨，但凭着图上不同的形状、颜色，以及布局，也可以做到一图胜千言的效果。</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/你倒是上个图啊.jpeg" alt=""></p>
<p>图很有用，画图的工具也同样举足轻重。如果是本地的桌面应用，多数人可能会选择用Windows平台的Visio或macOS平台的OmniGraffle；若说到作图网站，则可能会选择ProcessOn或Draw.io。</p>
<p>但比起用鼠标拖拖拉拉，我更喜欢用代码来画图。</p>
<h1 id="用代码画图？"><a href="#用代码画图？" class="headerlink" title="用代码画图？"></a>用代码画图？</h1><p>用代码画图大致上可以分为两类：</p>
<ol>
<li>用具体的编程语言控制某种绘图的API画出想要的图形，比如OpenGL、HTML5中的Canvas；</li>
<li>用DSL描述想要画的图，然后用程序根据DSL生成图片。</li>
</ol>
<p>我所说的<em>用代码画图</em>指的是上述的第二类。</p>
<p>百闻不如一见，以最容易上手的<code>DOT</code>语言为例，将下列内容保存在名为<code>hello.dot</code>的文件中</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph G {</span><br><span class="line">        Hello -&gt; World</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在shell中运行如下命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot -Tpng hello.dot -o hello.png</span><br></pre></td></tr></tbody></table></figure>
<p>便得到了相应的PNG文件</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/hello.jpeg" alt=""></p>
<h1 id="更多的栗子"><a href="#更多的栗子" class="headerlink" title="更多的栗子"></a>更多的栗子</h1><p>下面就带各位读者走马观花地看看不同的图可以用哪些工具来绘制。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>说到程序员画的图，最出名的当属流程图了。依稀记得在高中的时候，某一册的数学课本中讲到了算法（也许是辗转相除法），并且给出了图示，那应当就是我第一次见到流程图。上大学后也有一段时间痴迷于寻找能够绘制流程图的DSL，不过一直未果。直到遇到Boostnote后，才知道的确有这样的DSL，那便是<a href="https://flowchart.js.org/" target="_blank" rel="noopener">flowchart.js</a>。</p>
<p><code>flowchart.js</code>是一个JS编写的、用来绘制流程图的库。比如下面这张图</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/flowchart.jpeg" alt=""></p>
<p>便是依据下列的DSL生成的</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></tbody></table></figure>
<p><code>flowchart.js</code>生成的是SVG格式的图片文件，但SVG文件不方便嵌入到Markdown或Confluence的文档中，因此我会把它转换为PNG格式。折腾了一番后，发现在Mac上最靠谱的方法，是将SVG文件嵌入一个HTML文档，再用浏览器打开这个HTML，然后复制图片到<em>预览</em>程序上保存下来。</p>
<p>遗憾的是，不管是Emacs还是VSCode，似乎都没有辅助编辑<code>flowchart.js</code>的DSL的插件。</p>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>有限状态机的示意图也是很常见的图形，尤其是在讲解编译器的书的语法分析章节中。在Graphviz项目官网的<a href="https://graphviz.gitlab.io/gallery/" target="_blank" rel="noopener">Gallery板块</a>中，便有一个有限状态机的例子</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/dfa.jpeg" alt=""></p>
<p>它由如下的<code>DOT</code>代码描述</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">digraph finite_state_machine {</span><br><span class="line">	rankdir=LR;</span><br><span class="line">	size="8,5"</span><br><span class="line">	node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;</span><br><span class="line">	node [shape = circle];</span><br><span class="line">	LR_0 -&gt; LR_2 [ label = "SS(B)" ];</span><br><span class="line">	LR_0 -&gt; LR_1 [ label = "SS(S)" ];</span><br><span class="line">	LR_1 -&gt; LR_3 [ label = "S($end)" ];</span><br><span class="line">	LR_2 -&gt; LR_6 [ label = "SS(b)" ];</span><br><span class="line">	LR_2 -&gt; LR_5 [ label = "SS(a)" ];</span><br><span class="line">	LR_2 -&gt; LR_4 [ label = "S(A)" ];</span><br><span class="line">	LR_5 -&gt; LR_7 [ label = "S(b)" ];</span><br><span class="line">	LR_5 -&gt; LR_5 [ label = "S(a)" ];</span><br><span class="line">	LR_6 -&gt; LR_6 [ label = "S(b)" ];</span><br><span class="line">	LR_6 -&gt; LR_5 [ label = "S(a)" ];</span><br><span class="line">	LR_7 -&gt; LR_8 [ label = "S(b)" ];</span><br><span class="line">	LR_7 -&gt; LR_5 [ label = "S(a)" ];</span><br><span class="line">	LR_8 -&gt; LR_6 [ label = "S(b)" ];</span><br><span class="line">	LR_8 -&gt; LR_5 [ label = "S(a)" ];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不少工具将<code>DOT</code>语言作为中间媒介来实现绘图的功能。</p>
<p>与<code>flowchart.js</code>不同，Emacs和VSCode都可以很好地支持<code>DOT</code>代码的编辑和预览。Emacs上有<code>dot-mode</code>，VSCode则有<a href="https://marketplace.visualstudio.com/items?itemName=Stephanvs.dot" target="_blank" rel="noopener">Graphviz (dot) language support for Visual Studio Code</a>这个插件。</p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>我画得最多的当属时序图。在旧文<a href="https://liutos.github.io/2019/06/18/%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B7%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/">《时序图绘制工具走马观花》</a>中，提到了三个工具：</p>
<ol>
<li><a href="https://www.websequencediagrams.com/" target="_blank" rel="noopener">WebSequenceDiagrams</a>，一个在线绘制时序图的网站；</li>
<li><a href="http://sdedit.sourceforge.net/" target="_blank" rel="noopener">sdedit</a>，一个本地的命令行兼GUI绘图工具；</li>
<li><a href="https://sequencediagram.org/" target="_blank" rel="noopener">SequenceDiagram</a>，也是一个网站。</li>
</ol>
<p>当时倾向于使用<code>sdedit</code>。时过境迁，如今的<code>WebSequenceDiagrams</code>变得更好看了，而我也选择了<a href="https://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a>作为绘制时序图的主力工具。下面这张图是<code>PlantUML</code>官网给出的例子</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/sequencediagram.jpeg" alt=""></p>
<p>它依据如下的代码生成</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">用户 -&gt; 认证中心: 登录操作</span><br><span class="line">认证中心 -&gt; 缓存: 存放(key=token+ip,value=token)token</span><br><span class="line"></span><br><span class="line">用户 &lt;- 认证中心 : 认证成功返回token</span><br><span class="line">用户 -&gt; 认证中心: 下次访问头部携带token认证</span><br><span class="line">认证中心 &lt;- 缓存: key=token+ip获取token</span><br><span class="line">其他服务 &lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务</span><br><span class="line">其他服务 -&gt; 用户: 信息</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>
<p>Emacs的<code>plantuml-mode</code>，以及VSCode的<a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" target="_blank" rel="noopener">PlantUML</a>插件都可以为<code>PlantUML</code>的DSL提供语法高亮。</p>
<p>下载了<code>PlantUML</code>的<code>jar</code>包后，在Emacs中添加如下的配置，就可以不依赖远程服务器来生成PNG格式的图片了</p>
<figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> plantuml-default-exec-mode 'jar)</span><br><span class="line">(<span class="name">setq</span> plantuml-jar-path <span class="string">"/path/to/plantuml.jar"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h2><p>在《架构整洁之道》一书中，作者提出了一个软件架构模式，其中有一层便是<em>用例</em>。看完这本书后，我越发地喜欢作者这一套架构模式，渐渐开始在设计文档中给出需求的典型用例——尽管是文字描述。再后来，才知道原来UML中已经有一类专门用于描述用例的图形方法——用例图。</p>
<p>用于画用例图的依然是<code>PlantUML</code>。下列这张图</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/用例图.jpeg" alt=""></p>
<p>便是依据如下的源代码生成的</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">left to right direction</span><br><span class="line">actor 员工 as yg</span><br><span class="line">actor 顾客 as gk</span><br><span class="line">actor 餐厅员工 as ctyg</span><br><span class="line">actor A2 as a2</span><br><span class="line">actor 送餐员 as scy</span><br><span class="line">rectangle cos {</span><br><span class="line">        note "没注册工资\n支付的采用\n送餐时收费" as mzc</span><br><span class="line">        usecase 查看菜单 as ckcd</span><br><span class="line">        usecase 注册 as zc</span><br><span class="line">        usecase 登录 as dl</span><br><span class="line">        usecase 订餐 as dc</span><br><span class="line">        usecase "预约/覆盖预约" as yy</span><br><span class="line">        usecase 备餐 as bc</span><br><span class="line">        usecase 请求送餐 as qqsc</span><br><span class="line">        usecase 记录送餐 as jlsc</span><br><span class="line">        usecase 打印送餐说明 as dyscsm</span><br><span class="line">        usecase 记录收费 as jlsf</span><br><span class="line">        zc .&gt; dl : &lt;&lt;extends&gt;&gt;</span><br><span class="line">        dl .&gt; dc : &lt;&lt;extends&gt;&gt;</span><br><span class="line">}</span><br><span class="line">actor A1 as a1</span><br><span class="line">note bottom of a1 : 已注册工资支付</span><br><span class="line"></span><br><span class="line">yg &lt;|-- gk</span><br><span class="line">gk &lt;|-- ctyg</span><br><span class="line">ctyg &lt;|-- a2</span><br><span class="line">ctyg &lt;|-- scy</span><br><span class="line"></span><br><span class="line">yg -- ckcd</span><br><span class="line">yg ---- zc</span><br><span class="line">yg --- dl</span><br><span class="line">gk -- dc</span><br><span class="line">gk ---- yy</span><br><span class="line">ctyg -- bc</span><br><span class="line">ctyg --- qqsc</span><br><span class="line">scy -- jlsc</span><br><span class="line">scy --- dyscsm</span><br><span class="line">scy -- mzc</span><br><span class="line">jlsf -- mzc</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>
<p>比较遗憾的是，<code>PlantUML</code>自动排版的结果显得不那么整齐，左下角有一个明显的三角形空白区域——这也是DSL大法的一个缺点，即无法完美地控制最终的排列效果。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>最开始接触UML的时候，学习的便是类图——尽管接触得最早，画得却最少。比起类图，ER图反而画得更多一点。</p>
<p>如果要画类图，首选的工具是<a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener"><code>mermaid</code></a>。跟<code>PlantUML</code>一样，<code>mermaid</code>也是一个大而全的东西，除了画UML类图，也可以画流程图、时序图，以及UML状态图等。下面这张图</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/类图.jpeg" alt=""></p>
<p>便是<code>mermaid-cli</code>依据如下的源代码生成的</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  Image &lt;|-- BMP</span><br><span class="line">  Image &lt;|-- GIF</span><br><span class="line">  Image &lt;|-- JPEG</span><br><span class="line">  Image: +setImpl()</span><br><span class="line">  Image: +parseFile()</span><br><span class="line"></span><br><span class="line">  ImageImpl &lt;|-- WinImpl</span><br><span class="line">  ImageImpl &lt;|-- LinuxImpl</span><br><span class="line">  ImageImpl: +doPaint()</span><br><span class="line"></span><br><span class="line">  Image ..&gt; ImageImpl</span><br></pre></td></tr></tbody></table></figure>
<p>Emacs用户可以安装<code>mermaid-mode</code>，VSCode用户则可以使用<a href="https://marketplace.visualstudio.com/items?itemName=vstirbu.vscode-mermaid-preview" target="_blank" rel="noopener">Mermaid Preview</a>这个插件，来辅助编辑<code>mermaid</code>的源文件。</p>
<p>方才提到的<code>mermaid-cli</code>是一个命令行程序，用于在本地根据<code>mermaid</code>的源文件产生PNG格式的图片，安装也很简单</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mermaid.cli</span><br></pre></td></tr></tbody></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有许多的图可以用DSL来绘制，感兴趣的读者可以到<code>mermaid</code>或<code>PlantUML</code>的官网了解一番，这里不再一一举例。</p>
<p>用DSL来绘图有一些优点：</p>
<ol>
<li>不需要借助鼠标工具，纯键盘党的福音；</li>
<li>源代码为纯文本，生成器跨多平台，可以在多个平台甚至网页上编辑和查看，不受单一软件厂商的约束；</li>
<li>方便修改，改完不需要来回调整各个图形的位置。</li>
</ol>
<p>但也有一些缺点：</p>
<ol>
<li>不直观，生成图片前不好猜测最终的效果；</li>
<li>无法准确地控制图中所有元素的排列和位置，有时候得不到想要的效果；</li>
<li>需要学习不同的DSL，学习成本比可视化工具要高。</li>
</ol>
<p>就像软件开发中没有银弹一样，画图工具也没有万金油，关键还是要因地制宜地选择最合适的工具来解决眼前的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liutos.github.io/2020/04/26/你或许不知道，shell不能比较大小/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/微信.jpg">
      <meta itemprop="name" content="Liutos">
      <meta itemprop="description" content="记录编程生涯的大大小小的事情">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小打小闹写点bug">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/26/你或许不知道，shell不能比较大小/" class="post-title-link" itemprop="url">你或许不知道，shell不能比较大小</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-26 21:19:01 / 修改时间：22:25:16" itemprop="dateCreated datePublished" datetime="2020-04-26T21:19:01+08:00">2020-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/究竟在干什么系列/" itemprop="url" rel="index">
                    <span itemprop="name">究竟在干什么系列</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/04/26/你或许不知道，shell不能比较大小/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/04/26/你或许不知道，shell不能比较大小/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>“究竟在干什么”是一系列关于软件开发过程中背后运作原理的文章，每一篇文章旨在讲解一些在日常编程实践中常见但可能并不为人所熟知的技术细节，抛砖引玉，期待激发读者朋友的更多思考。</p>
</blockquote>
<h1 id="如何在shell中比较大小？"><a href="#如何在shell中比较大小？" class="headerlink" title="如何在shell中比较大小？"></a>如何在shell中比较大小？</h1><p>如果在搜索引擎中搜索“shell 比较”，那么得到的结果基本上都在告诉你要写<code>[ blablabla ]</code>这样的代码</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/搜索“shell比较”的结果.jpg" alt=""></p>
<p>例如，如果想知道当前的UNIX时间是否已经以<code>16</code>开头，可以用下列的shell代码</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">ts=$(date '+%s')</span><br><span class="line">if [ "${ts}" -gt 1600000000 -a "${ts}" -lt 1700000000 ]; then</span><br><span class="line">    echo '当前的UNIX时间戳已经以16开头啦。'</span><br><span class="line">else</span><br><span class="line">    echo '当前的UNIX时间戳还没以16开头哦。'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<p>当我写这个的时候，<code>date '+%s'</code>的值为<code>1587901648</code>，所以运行后走的是<code>else</code>的分支。</p>
<p>除了用<code>-gt</code>表示大于之外，还有各种各样的其它比较运算符，例如下列的四个运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-ge</code></td>
<td>大于或等于</td>
<td><code>[ 2 -ge 1 ]</code></td>
</tr>
<tr>
<td><code>-eq</code></td>
<td>等于</td>
<td><code>[ 1 -eq 1 ]</code></td>
</tr>
<tr>
<td><code>-le</code></td>
<td>小于或等于</td>
<td><code>[ 2 -le 3 ]</code></td>
</tr>
<tr>
<td><code>-lt</code></td>
<td>小于</td>
<td><code>[ 3 -lt 4 ]</code></td>
</tr>
</tbody>
</table>
<p>还有一些“测试”类型的运算符，例如</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-b file</code></td>
<td>测试<code>file</code>是否存在并且是个块设备</td>
<td><code>[ -b /dev/disk0 ]</code></td>
</tr>
<tr>
<td><code>-c file</code></td>
<td>测试<code>file</code>是否存在并且是个字符设备</td>
<td><code>[ -c /dev/tty ]</code></td>
</tr>
</tbody>
</table>
<h1 id="是shell的语法么？"><a href="#是shell的语法么？" class="headerlink" title="[是shell的语法么？"></a><code>[</code>是shell的语法么？</h1><p>大部分写shell代码的人或许会认为，<code>[]</code>是shell语言用于实现一系列的比较操作的特殊语法。但实际上，<code>[]</code>并不是一个语法——<code>[</code>是一个独立的命令行程序，<code>]</code>则什么都不是，仅仅是一个普通的字符。</p>
<p>在bash中使用<code>which</code>命令可以看到<code>[</code>的真面目</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/which方括号的结果.jpg" alt=""></p>
<p><code>[</code>是一个独立的程序，对，你没有看错（鲍尔默脸）。而且<code>[</code>有它自己的man文档</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/方括号的man文档.jpg" alt=""></p>
<p>在man文档中出现了另外一个命令<code>test</code>，它和<code>[</code>的功能是一模一样的。或许<code>test</code>是一个“yet another [”？真相却更简单一点——<code>test</code>和<code>[</code>是同一个东西</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/左方括号和test是同一个东西.jpg" alt=""></p>
<h1 id="源代码的二三事"><a href="#源代码的二三事" class="headerlink" title="[源代码的二三事"></a><code>[</code>源代码的二三事</h1><p>可以在GitHub上找到<code>[</code>和<code>test</code>的<a href="https://github.com/freebsd/freebsd/blob/master/bin/test/test.c" target="_blank" rel="noopener">源代码</a>，代码很短，稍微读一下可以发现不少有意思的地方。</p>
<p>众所周知，如果在shell代码中使用<code>[</code>做比较运算，必须写上对应的右方括号<code>]</code>。但既然<code>[</code>是一个普通的外部程序，那么这个匹配括号的检查显然不会是shell来做的——没错，<code>[</code>自己会检查是否有写上相应的右方括号，这一段逻辑在源文件的<code>main</code>函数开始不久就出现了。</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/检测右方括号是否存在.jpg" alt=""></p>
<p>这个检查只有在程序被以<code>[</code>的名字启动的时候才会生效，所以<code>test 1 -eq 1</code>是不需要写括号的。</p>
<p>其实除了上文中给出的那些比较和测试运算符之外，<code>[</code>也支持复杂的逻辑运算表达式，比如文章开头的示例代码中的<code>-a</code>就是逻辑与的意思。在代码的注释中还贴心地给出了所接受的参数的BNF</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/test接受的语法.jpg" alt=""></p>
<p>而解析参数的过程则是一个手写的递归下降语法分析器，在源代码中可以找到与上面的产生式对应的多个函数：<code>oexpr</code>、<code>aexpr</code>、<code>nexpr</code>、<code>primary</code>，以及<code>binop</code>。</p>
<p>由于在shell语言中，0表示逻辑真，而1表示逻辑假（与C语言相反），所以在<code>main</code>函数中，如果发现传入的第一个参数为感叹号（<code>!</code>，表示逻辑取反），则将<code>oexpr</code>的调用结果直接返回，否则需要将结果取反后再从<code>main</code>函数中返回——给操作系统。</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/调用oexpr后取反.jpg" alt=""></p>
<h1 id="shell真的不原生支持比较？"><a href="#shell真的不原生支持比较？" class="headerlink" title="shell真的不原生支持比较？"></a>shell真的不原生支持比较？</h1><p>尽管在bash中，<code>[</code>的确是作为一个外部程序存在的，但在zsh中却相反</p>
<p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/test作为内置命令.jpg" alt=""></p>
<p>而且，即使是bash也并非完全没有原生的比较操作——此处需要召唤<code>[[</code>。<code>[[</code>是shell的<em>保留字</em>，它是一个<em>less suprise</em>版本的<code>[</code>，在Stack Overflow上有不少关于它的问答值得一看：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash" target="_blank" rel="noopener">https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash</a></li>
<li><a href="https://stackoverflow.com/questions/669452/is-double-square-brackets-preferable-over-single-square-brackets-in-ba" target="_blank" rel="noopener">https://stackoverflow.com/questions/669452/is-double-square-brackets-preferable-over-single-square-brackets-in-ba</a></li>
</ol>
<p>第二个链接的回答中还给出了一个值得一看的、关于bash中的“测试”功能的<a href="http://mywiki.wooledge.org/BashGuide/Practices#Bash_Tests" target="_blank" rel="noopener">指引</a>，其中甚至提到了</p>
<blockquote>
<p>It can produce surprising results, especially for people starting shell scripting that think [ ] is part of the shell syntax.</p>
</blockquote>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不得不承认，本文标题党了一把，shell还是自身就具备比较大小这样的功能的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">…</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">…</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liutos" src="/images/loading.png" data-original="/images/微信.jpg">
  <p class="site-author-name" itemprop="name">Liutos</p>
  <div class="site-description" itemprop="description">记录编程生涯的大大小小的事情</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Liutos" title="GitHub → https://github.com/Liutos" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/liutos" title="SegmentFault → https://segmentfault.com/u/liutos" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>SegmentFault</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://u3coding.com" title="http://u3coding.com" rel="noopener" target="_blank">u3coding</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.skypyb.com/" title="https://www.skypyb.com/" rel="noopener" target="_blank">编码妙♂妙♂屋</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://xfy.now.sh" title="https://xfy.now.sh" rel="noopener" target="_blank">:- op( xfy ).</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://davincievans.top/" title="https://davincievans.top/" rel="noopener" target="_blank">Davinciの红茶馆</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://reverland.org" title="http://reverland.org" rel="noopener" target="_blank">reverland的知行阁</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.gndrive.org/" title="http://www.gndrive.org/" rel="noopener" target="_blank">高达数字实验室</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.hsyyf.me/" title="http://www.hsyyf.me/" rel="noopener" target="_blank">月下叹逍遥/寒山烟雨</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.lainme.com/doku.php" title="http://www.lainme.com/doku.php" rel="noopener" target="_blank">Lainme's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://lengxx.com/" title="http://lengxx.com/" rel="noopener" target="_blank">冷轩信</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://forum.ubuntu.org.cn/" title="http://forum.ubuntu.org.cn/" rel="noopener" target="_blank">Ubuntu中文论坛</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://y-window.github.com/" title="http://y-window.github.com/" rel="noopener" target="_blank">Window的空间</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.thev.net/PaulLiu/" title="http://www.thev.net/PaulLiu/" rel="noopener" target="_blank">九瓜老师的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://weibo.com/liutos" title="http://weibo.com/liutos" rel="noopener" target="_blank">博主的微博</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://github.com/Liutos" title="http://github.com/Liutos" rel="noopener" target="_blank">博主的GitHub页面</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  © 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liutos</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  
  






  















  

  






<script src="/bundle.js"></script><script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://Liutos.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
;
!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script></body></html>