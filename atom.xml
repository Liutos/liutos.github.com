<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小打小闹写点bug</title>
  
  <subtitle>乍听之下，不无道理；仔细揣摩，胡说八道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liutos.github.io/"/>
  <updated>2021-06-14T12:30:36.060Z</updated>
  <id>https://liutos.github.io/</id>
  
  <author>
    <name>Liutos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从AOP到method-combination</title>
    <link href="https://liutos.github.io/2021/06/14/%E4%BB%8EAOP%E5%88%B0method-combination/"/>
    <id>https://liutos.github.io/2021/06/14/从AOP到method-combination/</id>
    <published>2021-06-14T12:28:28.000Z</published>
    <updated>2021-06-14T12:30:36.060Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><p>Emacs的org-mode用的是一门叫Org的标记语言，正如大部分的标记语言那样，它也支持无序列表和检查清单——前者以<code>-</code>（一个连字符、一个空格）为前缀，后者以<code>- [ ]</code>或<code>- [x]</code>为前缀（比无序列表多了一对方括号及中间的字母<code>x</code>）</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210614/org模式中checkbox的语法.jpg" alt=""></p><p>此外，org-mode还为编辑这两种列表提供了快速插入新一行的快捷键<code>M-RET</code>（即按住<code>alt</code>键并按下回车键）。如果光标位于无序列表中，那么新的一行将会自动插入<code>-</code>前缀。遗憾的是，如果光标位于检查清单中，那么新一行并没有自动插入一对方括号</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210614/在Emacs中用alt回车添加一行.gif" alt=""></p><p>每次都要手动敲入<code>[ ]</code>还挺繁琐的。好在这是Emacs，它是可扩展的、可定制的。只需敲几行代码，就可以让Emacs代劳输入方括号了。</p><h1 id="Emacs的AOP特性——advice-add"><a href="#Emacs的AOP特性——advice-add" class="headerlink" title="Emacs的AOP特性——advice-add"></a>Emacs的AOP特性——<code>advice-add</code></h1><p>借助Emacs的<code>describe-key</code>功能，可以知道在一个<code>org-mode</code>的文件中按下<code>M-RET</code>时，Emacs会调用到函数<code>org-insert-item</code>上。要想让<code>M-RET</code>实现自动追加方括号的效果，马上可以想到简单粗暴的办法：</p><ul><li>定义一个新的函数，并将<code>M-RET</code>绑定到它身上；</li><li>重新定义<code>org-insert-item</code>函数，使其追加方括号；</li></ul><p>但不管是上述的哪一种，都需要连带着重新实现插入连字符、空格前缀的已有功能。有一种更温和的办法可以在现有的<code>org-insert-item</code>的基础上扩展它的行为，那就是Emacs的<code>advice</code>特性。</p><p><code>advice</code>是面向切面编程范式的一种，使用Emacs的<code>advice-add</code>函数，可以在一个普通的函数被调用前或被调用后捎带做一些事情——比如追加一对方括号。对于这两个时机，分别可以直接用<code>advice-add</code>的<code>:before</code>和<code>:after</code>来实现，但用在这里都不合适，因为：</p><ul><li>检测是否位于检查清单中，需要在调用<code>org-insert-item</code>前做；</li><li>追加一对方括号，则需要在<code>org-insert-item</code>之后做。</li></ul><p>因此，正确的做法是使用<code>:around</code>来修饰原始的<code>org-insert-item</code>函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-defun</span> lt-around-org-insert-item (<span class="name">oldfunction</span> <span class="symbol">&amp;rest</span> args)</span><br><span class="line">  <span class="string">"在调用了org-insert-item后识时务地追加 [ ]这样的内容。"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">is-checkbox</span> <span class="literal">nil</span>)</span><br><span class="line">        (<span class="name">line</span> (<span class="name">buffer-substring-no-properties</span> (<span class="name">line-beginning-position</span>) (<span class="name">line-end-position</span>))))</span><br><span class="line">    <span class="comment">;; 检查当前行是否为checkbox</span></span><br><span class="line">    (<span class="name">when</span> (<span class="name">string-match-p</span> <span class="string">"- \\[.\\]"</span> line)</span><br><span class="line">      (<span class="name">setf</span> is-checkbox <span class="literal">t</span>))</span><br><span class="line">    <span class="comment">;; 继续使用原来的org-insert-item插入文本</span></span><br><span class="line">    (<span class="name">apply</span> oldfunction args)</span><br><span class="line">    <span class="comment">;; 决定要不要追加“ [ ]”字符串</span></span><br><span class="line">    (<span class="name">when</span> is-checkbox</span><br><span class="line">      (<span class="name">insert</span> <span class="string">"[ ] "</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">advice-add</span> 'org-insert-item <span class="symbol">:around</span> #'lt-around-org-insert-item)</span><br></pre></td></tr></table></figure><p>这下子，<code>M-RET</code>对检查清单也一视同仁了</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210614/advice后的效果.gif" alt=""></p><h1 id="Common-Lisp的method-combination"><a href="#Common-Lisp的method-combination" class="headerlink" title="Common Lisp的method combination"></a>Common Lisp的<code>method combination</code></h1><p><code>advice-add</code>的<code>:after</code>、<code>:around</code>，以及<code>:before</code>在Common Lisp中有着完全同名的等价物，只不过不是用一个叫<code>advice-add</code>的函数，而是喂给一个叫<code>defmethod</code>的宏。举个例子，用<code>defmethod</code>可以定义出一个多态的<code>len</code>函数，对不同类型的入参执行不同的逻辑</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defgeneric</span> len (<span class="name">x</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> len ((<span class="name">x</span> string))</span><br><span class="line">  (<span class="name">length</span> x))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> len ((<span class="name">x</span> hash-table))</span><br><span class="line">  (<span class="name">hash-table-count</span> x))</span><br></pre></td></tr></table></figure><p>然后为其中参数类型为字符串的特化版本定义对应的<code>:after</code>、<code>:around</code>，以及<code>:before</code>修饰过的方法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmethod</span> len <span class="symbol">:after</span> ((<span class="name">x</span> string))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"after len~%"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> len <span class="symbol">:around</span> ((<span class="name">x</span> string))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"around中调用len前~%"</span>)</span><br><span class="line">  (<span class="name">prog1</span></span><br><span class="line">      (<span class="name">call-next-method</span>)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"around中调用len后~%"</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> len <span class="symbol">:before</span> ((<span class="name">x</span> string))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"before len~%"</span>))</span><br></pre></td></tr></table></figure><p>这一系列方法的调用规则为：</p><ol><li>先调用<code>:around</code>修饰的方法；</li><li>由于上述方法中调用了<code>call-next-method</code>，因此再调用<code>:before</code>修饰的方法；</li><li>调用不加修饰的方法（在CL中这称为<code>primary</code>方法）；</li><li>再调用<code>:after</code>修饰的方法；</li><li>最后，又回到了<code>:around</code>中调用<code>call-next-method</code>的位置。</li></ol><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210614/实际效果.jpg" alt=""></p><p>咋看之下，Emacs的<code>advice-add</code>支持的修饰符要多得多，实则不然。在CL中，<code>:after</code>、<code>:around</code>，以及<code>:before</code>同属于一个名为<code>standard</code>的<code>method combination</code>，而CL还内置了其它的<code>method combination</code>。在<a href="https://lispcookbook.github.io/cl-cookbook/clos.html#method-qualifiers-before-after-around" target="_blank" rel="noopener">《Other method combinations》</a>一节中，作者演示了<code>progn</code>和<code>list</code>的例子。</p><p>如果想要模拟Emacs的<code>advice-add</code>所支持的其它修饰符，那么就必须定义新的<code>method combination</code>了。</p><h1 id="可编程的编程语言——define-method-combination"><a href="#可编程的编程语言——define-method-combination" class="headerlink" title="可编程的编程语言——define-method-combination"></a>可编程的编程语言——<code>define-method-combination</code></h1><p>曾经我以为，<code>defmethod</code>只能接受<code>:after</code>、<code>:around</code>，以及<code>:before</code>，认为这三个修饰符是必须在语言一级支持的特性。直到有一天我闯入了LispWorks的<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_4.htm" target="_blank" rel="noopener">define-method-combination</a>词条中，才发现它们也是三个平凡的修饰符而已。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-method-combination</span> standard ()</span><br><span class="line">  ((<span class="name">around</span> (<span class="symbol">:around</span>))</span><br><span class="line">   (<span class="name">before</span> (<span class="symbol">:before</span>))</span><br><span class="line">   (<span class="name">primary</span> () <span class="symbol">:required</span> <span class="literal">t</span>)</span><br><span class="line">   (<span class="name">after</span> (<span class="symbol">:after</span>)))</span><br><span class="line">  (<span class="name">flet</span> ((<span class="name">call-methods</span> (<span class="name">methods</span>)</span><br><span class="line">           (<span class="name">mapcar</span> #'(lambda (method)</span><br><span class="line">                       `(call-method ,method))</span><br><span class="line">                   methods)))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">form</span> (<span class="name">if</span> (<span class="name">or</span> before after (<span class="name">rest</span> primary))</span><br><span class="line">                    `(multiple-value-prog1</span><br><span class="line">                         (progn ,@(call-methods before)</span><br><span class="line">                                (call-method ,(first primary)</span><br><span class="line">                                             ,(rest primary)))</span><br><span class="line">                       ,@(call-methods (reverse after)))</span><br><span class="line">                    `(call-method ,(first primary)))))</span><br><span class="line">      (<span class="name">if</span> around</span><br><span class="line">          `(call-method ,(first around)</span><br><span class="line">                        (,@(rest around)</span><br><span class="line">                           (make-method ,form)))</span><br><span class="line">          form))))</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210614/DIO就是厉害梗图.jpg" alt=""></p><p>秉持“柿子要挑软的捏”的原则，让我来尝试模拟出<code>advice-add</code>的<code>:after-while</code>和<code>:before-while</code>的效果吧。</p><p><code>:after-while</code>和<code>:before-while</code>的效果还是很容易理解的</p><blockquote><p>Call function after the old function and only if the old function returned non-<code>nil</code>.</p><p>Call function before the old function and don’t call the old function if function returns <code>nil</code>.</p></blockquote><p>因此，由<code>define-method-combination</code>生成的<code>form</code>中（犹记得伞哥在《PCL》中将它翻译为形式），势必要：</p><ul><li>检查是否有被<code>:before-while</code>修饰的方法；</li><li>如果有，检查调用了被<code>:before-while</code>修饰的方法后的返回值是否为<code>NIL</code>；</li><li>如果没有，或者被<code>:before-while</code>修饰的方法的返回值为非<code>NIL</code>，便调用<code>primary</code>方法；</li><li>如果有被<code>:after-while</code>修饰的方法，并且<code>primary</code>方法的返回值不为<code>NIL</code>，就调用这些方法；</li><li>返回<code>primary</code>方法的返回值。</li></ul><p>为了简单起见，尽管<code>after-while</code>和<code>before-while</code>变量指向的是多个“可调用”的方法，但这里只调用“最具体”的一个。</p><p>给这个新的<code>method combination</code>取名为<code>emacs-advice</code>，其具体实现已是水到渠成</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-method-combination</span> emacs-advice ()</span><br><span class="line">  ((<span class="name">after-while</span> (<span class="symbol">:after-while</span>))</span><br><span class="line">   (<span class="name">before-while</span> (<span class="symbol">:before-while</span>))</span><br><span class="line">   (<span class="name">primary</span> () <span class="symbol">:required</span> <span class="literal">t</span>))</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">after-while-fn</span> (<span class="name">first</span> after-while))</span><br><span class="line">        (<span class="name">before-while-fn</span> (<span class="name">first</span> before-while))</span><br><span class="line">        (<span class="name">result</span> (<span class="name">gensym</span>)))</span><br><span class="line">    `(let ((,result (when ,before-while-fn</span><br><span class="line">                      (call-method ,before-while-fn))))</span><br><span class="line">       (when (or (null ,before-while-fn)</span><br><span class="line">                 ,result)</span><br><span class="line">         (let ((,result (call-method ,(first primary))))</span><br><span class="line">           (when (and ,result ,after-while-fn)</span><br><span class="line">             (call-method ,after-while-fn))</span><br><span class="line">           ,result)))))</span><br></pre></td></tr></table></figure><p><code>call-method</code>（以及它的搭档<code>make-method</code>）是专门用于在<code>define-method-combination</code>中调用传入的方法的宏。</p><p>用一系列<code>foobar</code>方法来验证一番</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defgeneric</span> foobar (<span class="name">x</span>)</span><br><span class="line">  (<span class="symbol">:method-combination</span> emacs-advice))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> foobar (<span class="name">x</span>)</span><br><span class="line">  'hello)</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> foobar <span class="symbol">:after-while</span> (<span class="name">x</span>)</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> x))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"for side effect~%"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> foobar <span class="symbol">:before-while</span> (<span class="name">x</span>)</span><br><span class="line">  (<span class="name">evenp</span> x))</span><br><span class="line"></span><br><span class="line">(<span class="name">foobar</span> <span class="number">1</span>) <span class="comment">;; 返回NIL</span></span><br><span class="line">(<span class="name">foobar</span> <span class="number">2</span>) <span class="comment">;; 打印“fo side effect”，并返回HELLO</span></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>尽管我对CL赏识有加，但越是琢磨<code>define-method-combination</code>，就越会发现编程语言的能力是有极限的<del>，除非超越编程语言</del>。比如Emacs的<code>advice-add</code>所支持的<code>:filter-args</code>和<code>:filter-return</code>就无法用<code>define-method-combination</code>优雅地实现出来——并不是完全不行，只不过需要将它们合并在由<code>:around</code>修饰的方法之中。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
      <category term="oop" scheme="https://liutos.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>非递归遍历二叉树到底有什么用</title>
    <link href="https://liutos.github.io/2021/05/03/%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/"/>
    <id>https://liutos.github.io/2021/05/03/非递归遍历二叉树到底有什么用/</id>
    <published>2021-05-03T03:58:11.000Z</published>
    <updated>2021-05-03T04:04:18.147Z</updated>
    
    <content type="html"><![CDATA[<p>准备过互联网公司的服务端岗位面试的人，对于二叉树的三种遍历方式想必是如数家珍。假设以类<code>BinaryTree</code>定义一棵二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, right, value)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure><p>实现一个前序遍历的算法便是信手拈来的事情</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_traversal</span><span class="params">(tree, func)</span>:</span></span><br><span class="line">    <span class="string">"""前序遍历二叉树的每个节点。"""</span></span><br><span class="line">    <span class="keyword">if</span> tree <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    func(tree.value)</span><br><span class="line">    preorder_traversal(tree.left, func)</span><br><span class="line">    preorder_traversal(tree.right, func)</span><br></pre></td></tr></table></figure><p>随着行业曲率的增大，要求写出不使用递归的版本也没什么过分的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterative_preorder_traversal</span><span class="params">(tree, func)</span>:</span></span><br><span class="line">    nodes = [tree]</span><br><span class="line">    <span class="keyword">while</span> len(nodes) &gt; <span class="number">0</span>:</span><br><span class="line">        node = nodes.pop()</span><br><span class="line">        func(node)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            nodes.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            nodes.append(node.left)</span><br></pre></td></tr></table></figure><p>一直以来，我觉得这种用一个显式的栈来代替递归过程中隐式的栈的做法就是镜花水月。但最近却找到了它的一个用武之地——用于实现<code>iterator</code>。</p><h1 id="iterator是个啥？"><a href="#iterator是个啥？" class="headerlink" title="iterator是个啥？"></a><code>iterator</code>是个啥？</h1><p>这年头，<code>iterator</code>已经不是什么新鲜事物了，许多语言中都有支持，维基百科上有一份<a href="https://en.wikipedia.org/wiki/Iterator#In_different_programming_languages" target="_blank" rel="noopener">清单</a>列出了比较知名的语言的<code>iterator</code>特性。按照Python官方的术语表中的<a href="https://docs.python.org/3/glossary.html#term-iterator" target="_blank" rel="noopener">定义</a>，<code>iterator</code>表示一个数据流，反复调用其<code>__next__</code>方法可以一个接一个地返回流中的下一项数据。将内置函数<code>iter</code>作用于<code>list</code>、<code>str</code>、<code>tuple</code>类型的对象，可以获得相应的迭代器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat get_iter.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -*- coding: utf8 -*-</span></span><br><span class="line">if __name__ == '__main__':</span><br><span class="line">    values = [</span><br><span class="line">        [1, 2, 3],</span><br><span class="line">        'Hello, world!',</span><br><span class="line">        (True, None),</span><br><span class="line">    ]</span><br><span class="line">    for v in values:</span><br><span class="line">        print('type of iter(&#123;&#125;) is &#123;&#125;'.format(v, type(iter(v))))</span><br><span class="line"><span class="meta">$</span><span class="bash"> python get_iter.py</span></span><br><span class="line">type of iter([1, 2, 3]) is &lt;class 'list_iterator'&gt;</span><br><span class="line">type of iter(Hello, world!) is &lt;class 'str_iterator'&gt;</span><br><span class="line">type of iter((True, None)) is &lt;class 'tuple_iterator'&gt;</span><br></pre></td></tr></table></figure><h1 id="写一个前序遍历的iterator"><a href="#写一个前序遍历的iterator" class="headerlink" title="写一个前序遍历的iterator"></a>写一个前序遍历的<code>iterator</code></h1><p>一个<code>iterator</code>对象必须要实现<code>__iter__</code>和<code>__next__</code>方法：</p><ul><li><code>__iter__</code>只需要返回<code>iterator</code>对象自身即可；</li><li>顾名思义，<code>__next__</code>负责返回下一个元素。</li></ul><p>仔细观察一下前文中的<code>iterative_preorder_traversal</code>函数可以看出：</p><ul><li><code>nodes = [tree]</code>属于初始化逻辑；</li><li><code>len(nodes) &gt; 0</code>用于判断是应当抛出<code>StopIteration</code>，还是应当继续返回下一个值（<code>nodes.pop()</code>）；</li><li>最后四行就是负责填充<code>nodes</code>，好让它可以在下一次调用<code>__next__</code>的时候有值可以返回的。</li></ul><p>到这里，<code>iterator</code>的具体实现代码已经呼之欲出了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        nodes = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            nodes.append(root)</span><br><span class="line">        self.nodes = nodes</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.nodes) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        node = self.nodes.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.nodes.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.nodes.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure><p>构造一棵这样的满二叉树</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210503/满二叉树.png" alt=""></p><p>用<code>BinaryTreePreorderIterator</code>可以正确地打印出每一个节点的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tree = BinaryTree(</span><br><span class="line">        BinaryTree(</span><br><span class="line">            BinaryTree(<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">1</span>), </span><br><span class="line">            BinaryTree(<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">3</span>), </span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">        ),</span><br><span class="line">        BinaryTree(</span><br><span class="line">            BinaryTree(<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">5</span>), </span><br><span class="line">            BinaryTree(<span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">7</span>), </span><br><span class="line">            <span class="number">6</span>,</span><br><span class="line">        ),</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> BinaryTreePreorderIterator(tree):</span><br><span class="line">        print(<span class="string">'&#123;&#125;\t'</span>.format(n), end=<span class="string">''</span>)</span><br><span class="line"><span class="comment"># 打印内容为：4213657</span></span><br></pre></td></tr></table></figure><h1 id="iterator的优势"><a href="#iterator的优势" class="headerlink" title="iterator的优势"></a><code>iterator</code>的优势</h1><p>显然，<code>iterator</code>比起<code>preorder_traversal</code>更为灵活——很容易在<code>for-in</code>循环内添加各种各样的控制逻辑：用<code>continue</code>跳过一些值，或者用<code>break</code>提前结束遍历过程。这些在函数<code>preorder_traversal</code>中做起来会比较别扭。</p><p>聪明的你应该已经发现了，大可不必将<code>preorder_traversal</code>拆解到一个构造方法和一个<code>__next__</code>方法中。用<code>generator</code>写起来明明更加直观</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_generator</span><span class="params">(tree)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个能够以前序遍历的次序遍历二叉树节点的generator。"""</span></span><br><span class="line">    nodes = [tree]</span><br><span class="line">    <span class="keyword">while</span> len(nodes) &gt; <span class="number">0</span>:</span><br><span class="line">        node = nodes.pop()</span><br><span class="line">        <span class="keyword">yield</span> node.value</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            nodes.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            nodes.append(node.left)</span><br></pre></td></tr></table></figure><p>但是，很多语言并不支持<code>generator</code>。与之相比，<code>iterator</code>要亲民得多，更容易移植。例如，即使是Common Lisp这种一穷二白的语言，也可以实现和Python的<code>iterator</code>以及<code>for</code>类似的效果</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">in-package</span> #<span class="symbol">:cl-user</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defpackage</span> #<span class="symbol">:com</span>.liutos.binary-tree</span><br><span class="line">  (<span class="symbol">:use</span> #<span class="symbol">:cl</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">in-package</span> #<span class="symbol">:com</span>.liutos.binary-tree)</span><br><span class="line"></span><br><span class="line">(<span class="name">defclass</span> preorder-iterator ()</span><br><span class="line">  ((<span class="name">nodes</span></span><br><span class="line">    <span class="symbol">:initform</span> <span class="literal">nil</span>)</span><br><span class="line">   (<span class="name">tree</span></span><br><span class="line">    <span class="symbol">:initarg</span> <span class="symbol">:tree</span>))</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"前序遍历二叉树的迭代器"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> initialize-instance <span class="symbol">:after</span> ((<span class="name">instance</span> preorder-iterator) <span class="symbol">&amp;key</span>)</span><br><span class="line">  (<span class="name">with-slots</span> (<span class="name">nodes</span> tree)</span><br><span class="line">      instance</span><br><span class="line">    (<span class="name">when</span> tree</span><br><span class="line">      (<span class="name">push</span> tree nodes))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defgeneric</span> next (<span class="name">iterator</span>)</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"返回迭代器的下一个值。"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define-condition</span> stop-iteration (<span class="name">error</span>)</span><br><span class="line">  ()</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"Python中StopIteration异常的等价物。"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> next ((<span class="name">iterator</span> preorder-iterator))</span><br><span class="line">  (<span class="name">with-slots</span> (<span class="name">nodes</span>) iterator</span><br><span class="line">    (<span class="name">when</span> (<span class="name">null</span> nodes)</span><br><span class="line">      (<span class="name">error</span> 'stop-iteration))</span><br><span class="line"></span><br><span class="line">    (<span class="name">let</span> ((<span class="name">node</span> (<span class="name">pop</span> nodes)))</span><br><span class="line">      <span class="comment">;; 一个节点的结构为：(值 左子树 右子树)</span></span><br><span class="line">      (<span class="name">when</span> (<span class="name">third</span> node)</span><br><span class="line">        (<span class="name">push</span> (<span class="name">third</span> node) nodes))</span><br><span class="line">      (<span class="name">when</span> (<span class="name">second</span> node)</span><br><span class="line">        (<span class="name">push</span> (<span class="name">second</span> node) nodes))</span><br><span class="line">      (<span class="name">first</span> node))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmacro</span> for-in (<span class="name">var</span> iterator <span class="symbol">&amp;body</span> forms)</span><br><span class="line">  <span class="string">"将iterator中的值逐个绑定到变量var上，并执行forms中的表达式。"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">iter</span> (<span class="name">gensym</span>)))</span><br><span class="line">    `(let ((,iter ,iterator))</span><br><span class="line">       (handler-case</span><br><span class="line">           (loop</span><br><span class="line">              (let ((,var (next ,iter)))</span><br><span class="line">                ,@forms))</span><br><span class="line">         (stop-iteration (c)</span><br><span class="line">           (declare (ignorable c)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defparameter</span> *tree*</span><br><span class="line">  '(<span class="number">4</span> (<span class="number">2</span> (<span class="number">1</span> <span class="literal">nil</span> <span class="literal">nil</span>) (<span class="number">3</span> <span class="literal">nil</span> <span class="literal">nil</span>)) (<span class="number">6</span> (<span class="number">5</span> <span class="literal">nil</span> <span class="literal">nil</span>) (<span class="number">7</span> <span class="literal">nil</span> <span class="literal">nil</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> test-preorder-iterator ()</span><br><span class="line">  <span class="string">"测试前序遍历迭代器。"</span></span><br><span class="line">  (<span class="name">for-in</span> n (<span class="name">make-instance</span> 'preorder-iterator</span><br><span class="line">                           <span class="symbol">:tree</span> *tree*)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~D~C"</span> n #\Tab)))</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>中序遍历和后序遍历也可以写成迭代器，证明略。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="算法" scheme="https://liutos.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="二叉树" scheme="https://liutos.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://liutos.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="common-lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="python" scheme="https://liutos.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>当你SET的时候，Redis到底在SET些什么</title>
    <link href="https://liutos.github.io/2021/04/17/%E5%BD%93%E4%BD%A0SET%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8CRedis%E5%88%B0%E5%BA%95%E5%9C%A8SET%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <id>https://liutos.github.io/2021/04/17/当你SET的时候，Redis到底在SET些什么/</id>
    <published>2021-04-17T07:09:24.000Z</published>
    <updated>2021-04-17T07:14:19.543Z</updated>
    
    <content type="html"><![CDATA[<p>准备过互联网公司的服务端岗位面试的人，对Redis中的5种数据类型想必是如数家珍。而网上很多面试题里也会出现这道题目</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210417/面试题例子1.jpg" alt="来自https://blog.csdn.net/ThinkWon/article/details/103522351"></p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210417/面试题例子2.jpg" alt="来自https://juejin.cn/post/6844903982066827277"></p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210417/面试题例子3.jpg" alt="来自https://mikechen.cc/3313.html"></p><p>随着行业曲率的增大，光是知道有这些数据类型已经不够了，还得知道同一个类型也有不同的底层数据结构。例如同样是<code>string</code>类型，不同内容或不同长度会采用不同的编码方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET key1 "1"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET key2 "value"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET key3 "Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp."</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; TYPE key1</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; TYPE key2</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; TYPE key3</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING key1</span><br><span class="line">"int"</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING key2</span><br><span class="line">"embstr"</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING key3</span><br><span class="line">"raw"</span><br></pre></td></tr></table></figure><p>而<code>hash</code>类型也有两种底层实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  HSET myhash field1 "Hello"</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;  HSET myhash2 field1 "Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp."</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING myhash</span><br><span class="line">"ziplist"</span><br><span class="line">127.0.0.1:6379&gt; OBJECT ENCODING myhash2</span><br><span class="line">"hashtable"</span><br></pre></td></tr></table></figure><p>不知道你是否曾经好奇过，上文中的<code>key1</code>、<code>key2</code>、<code>key3</code>、<code>myhash</code>，以及<code>myhash2</code>这些键，与它们各自的值（前三个为<code>string</code>，后两个为<code>hash</code>）之间的关系又是存储在什么数据结构中的呢？</p><p>答案在意料之外，情理之中：键与值的关系，也是存储在一张哈希表中的，并且正是上文中的<code>hashtable</code>。</p><p>求证的办法当然是阅读Redis的源代码。</p><h1 id="Redis命令的派发逻辑"><a href="#Redis命令的派发逻辑" class="headerlink" title="Redis命令的派发逻辑"></a>Redis命令的派发逻辑</h1><p>阅读Redis的源码是比较轻松愉快的，一是因为其源码由简单易懂的C语言编写，二是因为源码仓库的<code>README.md</code>中对内部实现做了一番高屋建瓴的介绍。在<code>README.md</code>的<a href="https://github.com/redis/redis#serverc" target="_blank" rel="noopener">server.c</a>一节中，道出了有关命令派发的两个关键点</p><blockquote><p><code>call()</code> is used in order to call a given command in the context of a given client.</p></blockquote><blockquote><p>The global variable <code>redisCommandTable</code> defines all the Redis commands, specifying the name of the command, the function implementing the command, the number of arguments required, and other properties of  each command.</p></blockquote><p>位于文件<code>src/server.c</code>中的变量<code>redisCommandTable</code>定义了所有可以在Redis中使用的命令——为什么一个C语言项目里要用<code>camelCase</code>这种格格不入的命名风格呢——它的元素的类型为<code>struct redisCommand</code>，其中：</p><ul><li><code>name</code>存放命令的名字；</li><li><code>proc</code>存放实现命令的C函数的指针；</li></ul><p>比如高频使用的<code>GET</code>命令在<code>redisCommandTable</code>中就是这样定义的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>,</span><br><span class="line"> <span class="string">"read-only fast @string"</span>,</span><br><span class="line"> <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br></pre></td></tr></table></figure><p>身为一名老解释器爱好者，对这种套路的代码当然是不会陌生的。我也曾在写过的、跑不起来的玩具解释器上用过类似的手法</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210417/liutscm中的类似代码.jpg" alt=""></p><p>Redis收到一道需要执行的命令后，根据命令的名字用<code>lookupCommand</code>找到一个命令（是个<code>struct redisCommand</code>类型的结构体），然后<code>call</code>函数做的事情就是调用它的<code>proc</code>成员所指向的函数而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;cmd-&gt;proc(c);</span><br></pre></td></tr></table></figure><p>那么接下来，就要看看<code>SET</code>命令对应的C函数究竟做了些什么了。</p><h1 id="SET命令的实现"><a href="#SET命令的实现" class="headerlink" title="SET命令的实现"></a><code>SET</code>命令的实现</h1><p><code>redisCommonTable</code>中下标为2的元素正是<code>SET</code>命令的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note that we can't flag set as fast, since it may perform an</span></span><br><span class="line"><span class="comment"> * implicit DEL of a large key. */</span></span><br><span class="line">&#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,</span><br><span class="line"> <span class="string">"write use-memory @string"</span>,</span><br><span class="line"> <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br></pre></td></tr></table></figure><p>其中函数<code>setCommand</code>定义在文件<code>t_string.c</code>中，它根据参数中是否有传入<code>NX</code>、<code>XX</code>、<code>EX</code>等选项计算出一个<code>flags</code>后，便调用<code>setGenericCommand</code>——顾名思义，这是一个通用的<code>SET</code>命令，它同时被<code>SET</code>、<code>SETNX</code>、<code>SETEX</code>，以及<code>PSETEX</code>四个Redis命令的实现函数所共用。</p><p><code>setGenericCommand</code>调用了<code>genericSetKey</code>，后者定义在文件<code>db.c</code>中。尽管该函数上方的注释写着</p><blockquote><p>All the new keys in the database should be created via this interface.</p></blockquote><p>但<del>人生不如意事十之八九</del>事实并非如此。例如在命令<code>RPUSH</code>的实现函数<code>rpushCommand</code>中，调用了<code>pushGenericCommand</code>，后者直接调用了<code>dbAdd</code>往Redis中存入键和列表对象的关系。</p><p>言归正传。根据键存在与否，<code>genericSetKey</code>会调用<code>dbAdd</code>或<code>dbOverwrite</code>。而在<code>dbAdd</code>中，最终调用了<code>dictAdd</code>将键与值存入数据库中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道了，使用<code>SET</code>命令时传入的<code>key</code>和<code>value</code>，是存储在一个<code>dict</code>类型的数据结构中。</p><h1 id="HSET命令的实现"><a href="#HSET命令的实现" class="headerlink" title="HSET命令的实现"></a><code>HSET</code>命令的实现</h1><p>依葫芦画瓢，Redis的<code>HSET</code>命令由位于文件<code>t_hash.c</code>中的函数<code>hsetCommand</code>实现，它会尝试转换要操作的<code>hash</code>值的编码方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>如果<code>hashTypeTryConversion</code>发现要写入哈希表的任何一个键或者值的长度超过了<code>server.hash_max_ziplist_value</code>所规定的值，就会将<code>hash</code>类型的编码从<code>ziplist</code>转换为<code>hashtable</code>。<code>server.hash_max_ziplist_value</code>的值在文件<code>config.c</code>中通过宏设置，默认值为64——这正是上文中<code>myhash2</code>所对应的值的编码为<code>hashtable</code>的原因。</p><p>将思绪拉回到函数<code>hsetCommand</code>中。做完编码的转换后，它调用函数<code>hashTypeSet</code>，在编码为<code>hashtable</code>的世界线中，同样调用了<code>dictAdd</code>实现往哈希表中写入键值对。</p><p>殊途同归</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210417/path_to_dbAdd.png" alt=""></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>因此，在Redis中用以维持每一个键与其对应的值——这些值也许是<code>string</code>，也许是<code>list</code>，也许是<code>hash</code>——的关系的数据结构，与Redis中的一系列操作哈希表的命令——也许是<code>HSET</code>、也许<code>HGET</code>，也许是<code>HDEL</code>——所用的数据结构，不能说是毫不相关，起码是一模一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多重返回值的阵营九宫格</title>
    <link href="https://liutos.github.io/2021/03/14/%E5%A4%9A%E9%87%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%98%B5%E8%90%A5%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    <id>https://liutos.github.io/2021/03/14/多重返回值的阵营九宫格/</id>
    <published>2021-03-14T07:52:34.000Z</published>
    <updated>2021-03-14T07:57:18.761Z</updated>
    
    <content type="html"><![CDATA[<p>通常在糊业务代码的时候，不管是函数、方法，还是宏，都只会有一个返回值。比如在C语言用于检查一个字符是否为阿拉伯数字的<code>isdigit</code>函数就只会返回是（1）或否（0）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"isdigit('%c') is %d\n"</span>, c, <span class="built_in">isdigit</span>(c));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有时候如果一个函数、方法，或宏可以返回多个值的话会更加方便。例如，在Python中<code>dict</code>类型有一个实例方法<code>get</code>，它可以取得<code>dict</code>实例中与给定的键对应的值。但如果有一个键在字典中的值为<code>None</code>，那么光凭<code>get</code>的返回值无法准确判断这个键是否存在——除非你给它一个非<code>None</code>的默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(d, key)</span>:</span></span><br><span class="line">    print(<span class="string">"d.get('&#123;0&#125;') is &#123;1&#125;\t'&#123;0&#125;' in d is &#123;2&#125;"</span>.format(key, d.get(key), key <span class="keyword">in</span> d))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    d = &#123;</span><br><span class="line">        <span class="string">'foo'</span>: <span class="string">'bar'</span>,</span><br><span class="line">        <span class="string">'baz'</span>: <span class="keyword">None</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    test(d, <span class="string">'foo'</span>)</span><br><span class="line">    test(d, <span class="string">'baz'</span>)</span><br></pre></td></tr></table></figure><p>发展了这么多年的编程语言，又怎么会连一次调用、多值返回这么简单的事情都做不到呢。事实上，有各种各样、各显神通的返回多个值的方法，我给其中的一些做了个分类</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210314/多重返回值的定义阵营九宫格.png" alt=""></p><h1 id="Lisp的multiple-value-bind"><a href="#Lisp的multiple-value-bind" class="headerlink" title="Lisp的multiple-value-bind"></a>Lisp的<code>multiple-value-bind</code></h1><p>Common Lisp（简称为CL）的多重返回值当之无愧是其中最正统、最好用的实现方式。以它的内置函数<code>truncate</code>为例，它的第一个返回值为第一个参数除以第二个参数的商，第二个返回值为对应的余数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">truncate</span> <span class="number">10</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果不加修饰地调用<code>truncate</code>，就像其它只返回一个值的函数一样，也只会拿到一个返回值</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">truncate</span> <span class="number">10</span> <span class="number">3</span>)))</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"q = ~D~%"</span> q))</span><br><span class="line">q = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>除非用<code>multiple-value-bind</code>来捕获一个函数产生的所有返回值</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">multiple-value-bind</span> (<span class="name">q</span> r)</span><br><span class="line">             (<span class="name">truncate</span> <span class="number">10</span> <span class="number">3</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"q = ~D~8Tr = ~D~%"</span> q r))</span><br><span class="line">q = <span class="number">3</span>   r = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>CL的方案的优点在于它十分灵活。即使将一个函数从返回单个值改为返回多个值，也不会导致原本调用该函数的位置要全部修改一遍——对修改封闭，对扩展开放（误）。</p><h1 id="Go的多重返回值"><a href="#Go的多重返回值" class="headerlink" title="Go的多重返回值"></a>Go的多重返回值</h1><p>踩在C语言肩膀上的Go也能够从函数中返回多个值。在<code>io/ioutil</code>包的<a href="https://golang.org/pkg/io/ioutil/" target="_blank" rel="noopener">官方文档</a>中有大量的例子，比如用<code>ReadAll</code>方法从字符串衍生的流中读取全部内容，就会返回两个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"Hello, world!"</span></span><br><span class="line">reader := strings.NewReader(s)</span><br><span class="line">bytes, err := ioutil.ReadAll(reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"bytes is %s"</span>, bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go以这种方式取代了C语言中用返回值表达成功与否、再通过指针传出读到的数据的风格。由于这个模式在有用的Go程序中到处出现，因此Gopher们用的都是定制的键盘（误）</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210314/go的错误检查.jpg" alt=""></p><p>不同于前文的<code>multiple-value-bind</code>，如果一个函数或方法返回多个值，那么调用者必须捕获每一个值，否则编译无法通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  try cat try_read_all_ignore_err.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">"io/ioutil"</span><br><span class="line">"strings"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s := "Hello, world!"</span><br><span class="line">reader := strings.NewReader(s)</span><br><span class="line">bytes := ioutil.ReadAll(reader)</span><br><span class="line">fmt.Printf("bytes is %s", bytes)</span><br><span class="line">&#125;</span><br><span class="line">➜  try go build try_read_all_ignore_err.go</span><br><span class="line"><span class="meta">#</span> command-line-arguments</span><br><span class="line">./try_read_all_ignore_err.go:12:8: assignment mismatch: 1 variable but ioutil.ReadAll returns 2 values</span><br></pre></td></tr></table></figure><p>这一要求也是合理的，毕竟多重返回值机制主要用于向调用者传递出错原因——既然可能出错，那么就必须要检查一番。</p><h1 id="Python和Rust的解构"><a href="#Python和Rust的解构" class="headerlink" title="Python和Rust的解构"></a>Python和Rust的解构</h1><p>就像CL的<code>truncate</code>函数一样，Python中的函数<code>divmod</code>也可以同时返回两个数相除的商和余数，并且咋看之下也是返回多个值的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q, r = divmod(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'q = &#123;&#125;\tr = &#123;&#125;'</span>.format(q, r))</span><br></pre></td></tr></table></figure><p>但本质上，这是因为Python支持<a href="https://docs.python.org/3/reference/simple_stmts.html#assignment-statements" target="_blank" rel="noopener">解构</a>，同时<a href="https://docs.python.org/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod</code></a>返回的是一个由商和余数组成的元组。这样的做法与CL的真·奥义·多重返回值的差异在于，如果只想要<code>divmod</code>的第一个值，那么等号左侧也要写成对应的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q, _ = divmod(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'q = &#123;&#125;'</span>.format(q))</span><br></pre></td></tr></table></figure><p>在支持解构的语言中都可以模仿出多重返回值，例如Rust</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">divmod</span></span>(a: <span class="built_in">u32</span>, b: <span class="built_in">u32</span>) -&gt; (<span class="built_in">u32</span>, <span class="built_in">u32</span>) &#123;</span><br><span class="line">    (a / b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (q, r) = divmod(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"q = &#123;&#125;\tr = &#123;&#125;"</span>, q, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Prolog的归一"><a href="#Prolog的归一" class="headerlink" title="Prolog的归一"></a>Prolog的归一</h1><p>到了Prolog这里，画风就有点不一样了。首先Prolog既没有函数，也没有方法，更没有宏。在Prolog中，像<code>length/2</code>和<code>member/2</code>这样的东西叫做<code>functor</code>，它们之于Prolog中的列表，就犹如CL的<code>length</code>和<code>member</code>之于列表、Python的<code>len</code>函数和<code>in</code>操作符之于列表，JavaScript的<code>length</code>属性和<code>indexOf</code>方法之于数组……</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210314/prolog的length和member.jpg" alt=""></p><p>其次，Prolog并不“返回”一个<code>functor</code>的“调用结果”，它只是判断输入的查询是否成立，以及给出使查询成立的变量值。在第一个查询中，<code>length/2</code>的第二个参数为变量<code>L</code>，因此Prolog给出了使这个查询成立的<code>L</code>的值4；第二个查询中没有变量，Prolog只是简单地给出查询是否成立；第三个查询中，Prolog给出了四个能够使查询成立的变量<code>X</code>的值。</p><p>由于Prolog会给出查询中每一个变量的值，可以用这个特性来模拟多重返回值。例如，可以让Prolog一次性给出两个数字的和、差、积，和商</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210314/同时计算出和查积商.jpg" alt=""></p><p>麻烦之处在于就算只想要得到两数之和，也必须用占位符填在后三个参数上：<code>jjcc(10, 3, S, _, _, _)</code>。</p><h1 id="作弊的指针与全局变量"><a href="#作弊的指针与全局变量" class="headerlink" title="作弊的指针与全局变量"></a>作弊的指针与全局变量</h1><p>尽管在开篇的时候提到了C语言中的函数无法返回多个值，但如果像上文的Prolog那般允许修改参数的话，C语言也是可以做到的，谁让它有指针这个强力特性呢。例如，<code>stat(2)</code>函数就会将关于一个文件的信息填充到参数中所指向的结构体的内存中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *path = <span class="string">"./try_stat.c"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    stat(path, &amp;buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"inode's number of %s is %llu\n"</span>, path, buf.st_ino);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>man 2 stat</code>可以知道<code>struct stat</code>类型中有非常多的内容，这显然也是一种多重返回值。同样的手法，在Go中也可以运用，例如用于把从数据库中读取出来的行的数据写入目标数据结构的<a href="https://golang.org/pkg/database/sql/#Rows.Scan" target="_blank" rel="noopener"><code>Scan</code>方法</a>。</p><p>最后，如果只要能让调用者感知就行，那么全局变量未尝不是一种通用的多重返回值机制。例如在C语言中的<code>strtol</code>函数，就会在无法转换出任何数字的时候返回0并设置<code>errno</code>，因此检查<code>errno</code>是必须的步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try_conversion</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> num = strtol(str, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno == EINVAL || errno == ERANGE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> message[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(message, <span class="keyword">sizeof</span>(message), <span class="string">"strtol(\"%s\")"</span>, str);</span><br><span class="line">        perror(message);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"strtol(\"%s\") is %ld\n"</span>, str, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    try_conversion(<span class="string">"233"</span>);</span><br><span class="line">    try_conversion(<span class="string">"0"</span>);</span><br><span class="line">    try_conversion(<span class="string">"lisp"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于<code>errno</code>是一个全局变量，<code>strtol</code>的使用者完全有可能忘记要检查。相比之下，Go的<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">strconv</a>包的函数都将转换过程中的错误以第二个参数的形式返回给调用者，用起来更安全。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>按照<a href="https://mp.weixin.qq.com/s/8T0rrl5dkwtYB_XCbAhACQ" target="_blank" rel="noopener">《代码写得不好，不要总觉得是自己抽象得不好》</a>这篇文章的说法，代码写成什么样子完全是由产品经理决定的。但产品经理又怎么会在意你用的技术是怎么实现多重返回值的呢。综上所述，这个特性没用（误）。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="编程语言" scheme="https://liutos.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>终端看片指日可待</title>
    <link href="https://liutos.github.io/2021/02/27/%E7%BB%88%E7%AB%AF%E7%9C%8B%E7%89%87%E6%8C%87%E6%97%A5%E5%8F%AF%E5%BE%85/"/>
    <id>https://liutos.github.io/2021/02/27/终端看片指日可待/</id>
    <published>2021-02-27T06:54:55.000Z</published>
    <updated>2021-02-27T07:02:53.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在旧文<a href="https://liutos.github.io/2020/07/03/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E7%A7%92%E8%A1%A8/">《如何写一个命令行的秒表》</a>中，借助命令<code>tput</code>，我实现了“原地更新”所输出的时分秒的效果</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/stopwatch的演示效果.gif" alt=""></p><p>其中用到的是ASCII转义序列<code>\x1b[8D</code>和<code>\x1b[0K</code>。除此之外，ASCII转义序列还有许多其它功能。例如，可以用来定制输出内容的前景色</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/打印红色的helloworld.jpg" alt=""></p><p>将转义序列中的参数<code>38</code>改为<code>48</code>，可以定制输出内容的背景色</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/打印红色背景的helloworld.jpg" alt=""></p><p>将打印内容改为两个空格，看起来就像是在一块黑色的画布上涂了一个红色的方块</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/打印红色方块.jpg" alt=""></p><p>既然如此，只要尺寸合适，就可以在终端打印出一张图片，只需要将每一个像素的颜色作为背景色，在坐标对应的行列上输出两个空格即可。如果能抹掉输出的内容并在同样的位置上打印一张不同的图片，甚至可以实现动画的效果。</p><p>百闻不如一见，下面我用Python演示一番。</p><h1 id="把GIF装进终端"><a href="#把GIF装进终端" class="headerlink" title="把GIF装进终端"></a>把GIF装进终端</h1><p>要想用前文的思路在终端中显示一张GIF图片，必须先得到GIF图片每一帧的每个像素的颜色才行。在Python中使用名为<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a>的库可以轻松地解析GIF文件，先安装这个库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp rmdir show_gif</span><br><span class="line">➜  /tmp mkdir show_gif</span><br><span class="line">➜  /tmp cd show_gif</span><br><span class="line">➜  show_gif python3 -m venv ./venv</span><br><span class="line">➜  show_gif . ./venv/bin/activate</span><br><span class="line">(venv) ➜  show_gif pip install Pillow</span><br><span class="line">Collecting Pillow</span><br><span class="line">  Using cached Pillow-8.1.0-cp39-cp39-macosx_10_10_x86_64.whl (2.2 MB)</span><br><span class="line">Installing collected packages: Pillow</span><br><span class="line">Successfully installed Pillow-8.1.0</span><br><span class="line">WARNING: You are using pip version 20.2.3; however, version 21.0.1 is available.</span><br><span class="line">You should consider upgrading via the '/private/tmp/show_gif/venv/bin/python3 -m pip install --upgrade pip' command.</span><br></pre></td></tr></table></figure><p>接着便可以让它读入并解析一张GIF图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    im = Image.open(path)</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>然后将每一帧都转换为<code>RGB</code>模式再遍历其每一个像素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    im = Image.open(path)</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):</span><br><span class="line">        rgb_frame = frame.convert(<span class="string">'RGB'</span>)</span><br><span class="line">        pixels = rgb_frame.load()</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.height):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.width):</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>调用<code>Image</code>类的实例方法<code>load</code>得到的是一个<a href="https://pillow.readthedocs.io/en/stable/reference/PixelAccess.html" target="_blank" rel="noopener"><code>PixelAccess</code></a>类的实例，它可以像二维数组一般用坐标获取每一个像素的颜色值，颜色值则是一个长度为3的<code>tuple</code>类型的值，其中依次是像素的三原色的分量。</p><p>从<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#24-bit" target="_blank" rel="noopener">ANSI escape code词条的24-bit小节</a>中得知，使用参数为<code>48;2;</code>的转义序列，再接上以分号分隔的三原色分量即可设置24位的背景色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    im = Image.open(path)</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):</span><br><span class="line">        rgb_frame = frame.convert(<span class="string">'RGB'</span>)</span><br><span class="line">        pixels = rgb_frame.load()</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.height):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.width):</span><br><span class="line">                colors = pixels[x, y]</span><br><span class="line">                print(<span class="string">'\x1b[48;2;&#123;&#125;;&#123;&#125;;&#123;&#125;m  \x1b[0m'</span>.format(*colors), end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>在每次二重循环遍历了所有像素后，还必须清除输出的内容，并将光标重置到左上角才能再次打印，这可以用ASCII转义序列来实现。查阅<a href="https://vt100.net/docs/vt100-ug/chapter3.html" target="_blank" rel="noopener">VT100 User Guide</a>可以知道，用<a href="https://vt100.net/docs/vt100-ug/chapter3.html#ED" target="_blank" rel="noopener">ED命令</a>可以擦除显示的字符，对应的转义序列为<code>\x1b[2J</code>；用<a href="https://vt100.net/docs/vt100-ug/chapter3.html#CUP" target="_blank" rel="noopener">CUP命令</a>可以移动光标的位置到左上角，对应的转义序列为<code>\x1b[0;0H</code>。在每次开始打印一帧图像前输出这两个转义序列即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    im = Image.open(path)</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):</span><br><span class="line">        rgb_frame = frame.convert(<span class="string">'RGB'</span>)</span><br><span class="line">        pixels = rgb_frame.load()</span><br><span class="line">        print(<span class="string">'\x1b[2J\x1b[0;0H'</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.height):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.width):</span><br><span class="line">                colors = pixels[x, y]</span><br><span class="line">                print(<span class="string">'\x1b[48;2;&#123;&#125;;&#123;&#125;;&#123;&#125;m  \x1b[0m'</span>.format(*colors), end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>最后，只需要在每次打印完一帧后，按GIF文件的要求睡眠一段时间即可。每一帧的展示时长可以从<code>info</code>属性的键<code>duration</code>中得到，单位是毫秒</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    im = Image.open(path)</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):</span><br><span class="line">        rgb_frame = frame.convert(<span class="string">'RGB'</span>)</span><br><span class="line">        pixels = rgb_frame.load()</span><br><span class="line">        print(<span class="string">'\x1b[2J\x1b[0;0H'</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.height):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.width):</span><br><span class="line">                colors = pixels[x, y]</span><br><span class="line">                print(<span class="string">'\x1b[48;2;&#123;&#125;;&#123;&#125;;&#123;&#125;m  \x1b[0m'</span>.format(*colors), end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">''</span>)</span><br><span class="line">        time.sleep(rgb_frame.info[<span class="string">'duration'</span>] / <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>现在可以看看效果了。我准备了一张测试用的GIF图片，宽度和高度均为47像素，共34帧</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/一颗苹果的动画.gif" alt=""></p><p>让它在终端中显示出来吧</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/在终端播放一棵苹果的动图.gif" alt=""></p><h1 id="一点微小的改进"><a href="#一点微小的改进" class="headerlink" title="一点微小的改进"></a>一点微小的改进</h1><p>你可能留意到了，前文的演示效果中有明显的闪烁，这是因为打印ASCII转义序列的速度不够快导致的。既然如此，可以将一整行的转义序列先生成出来，再一次性输出到终端。改动不复杂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    im = Image.open(path)</span><br><span class="line">    <span class="keyword">for</span> frame <span class="keyword">in</span> ImageSequence.Iterator(im):</span><br><span class="line">        rgb_frame = frame.convert(<span class="string">'RGB'</span>)</span><br><span class="line">        pixels = rgb_frame.load()</span><br><span class="line">        print(<span class="string">'\x1b[2J\x1b[0;0H'</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.height):</span><br><span class="line">            last_colors = <span class="keyword">None</span></span><br><span class="line">            line = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, rgb_frame.width):</span><br><span class="line">                colors = pixels[x, y]</span><br><span class="line">                <span class="keyword">if</span> colors != last_colors:</span><br><span class="line">                    line += <span class="string">'\x1b[0m\x1b[48;2;&#123;&#125;;&#123;&#125;;&#123;&#125;m  '</span>.format(*colors)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line += <span class="string">'  '</span></span><br><span class="line">                last_colors = colors</span><br><span class="line">            print(<span class="string">'&#123;&#125;\x1b[0m'</span>.format(line))</span><br><span class="line">        time.sleep(rgb_frame.info[<span class="string">'duration'</span>] / <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>但效果却很显著</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210227/不怎么闪烁的版本.gif" alt=""></p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="命令行" scheme="https://liutos.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="绘图" scheme="https://liutos.github.io/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>此数绵绵无绝期——欧拉计划第66题</title>
    <link href="https://liutos.github.io/2021/02/11/%E6%AD%A4%E6%95%B0%E7%BB%B5%E7%BB%B5%E6%97%A0%E7%BB%9D%E6%9C%9F%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92%E7%AC%AC66%E9%A2%98/"/>
    <id>https://liutos.github.io/2021/02/11/此数绵绵无绝期——欧拉计划第66题/</id>
    <published>2021-02-11T07:21:32.000Z</published>
    <updated>2021-02-12T06:44:00.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仅以此文膜拜八年前的自己</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><a href="https://projecteuler.net/about" target="_blank" rel="noopener">欧拉计划</a>（Project Euler）就像LeetCode，是一个编程答题的网站。不同于LeetCode的是，欧拉计划只要求用户提交最终答案即可（一般是一个数字），而不需要完整代码。因此，可以尽情地使用自己喜欢的编程语言——不少题目甚至光靠笔和纸便能解决。</p><p>欧拉计划的<a href="https://projecteuler.net/problem=66" target="_blank" rel="noopener">第66题</a>非常有意思，它的题目很简单，就是要求找出在不大于1000的整数中，以哪一个数字为丢番图方程的系数，可以得到所有最小解中的最大值。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210211/第66题的描述.jpeg" alt=""></p><p>可以很容易地看出方程有一个直观的暴力算法：让y从1开始递增，对于每一个y，计算公式<code>Dy^2+1</code>的值。如果该值为平方数，那么它的平方根就是最小的x解。再依照这个算法求解所有D不大于1000的方程，便可以求出题目的答案。很容易用Python写出这个算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_square</span><span class="params">(num: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> math.isqrt(num) ** <span class="number">2</span> == num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_x</span><span class="params">(D: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求出给定D时，满足题目所给的丢番图方程的最小的x。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> is_square(D)</span><br><span class="line">    y = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        candidate = D * y * y + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> is_square(candidate):</span><br><span class="line">            <span class="keyword">return</span> math.isqrt(candidate)</span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_66</span><span class="params">(limit)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    找出不大于limi的D中，使find_x的返回值最大的那一个数字。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_D = <span class="keyword">None</span></span><br><span class="line">    max_x = <span class="keyword">None</span></span><br><span class="line">    D = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> D &lt;= limit:</span><br><span class="line">        <span class="keyword">if</span> is_square(D):</span><br><span class="line">            D += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        x = find_x(D)</span><br><span class="line">        <span class="keyword">if</span> max_x <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> x &gt; max_x:</span><br><span class="line">            max_D = D</span><br><span class="line">            max_x = x</span><br><span class="line">        D += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_D, max_x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    D, x = solve_66(<span class="number">7</span>)</span><br><span class="line">    print(<span class="string">'D is &#123;&#125; and x is &#123;&#125;'</span>.format(D, x))</span><br></pre></td></tr></table></figure><p>但如果将上限<code>limit</code>提升为1000，这个算法在有生之年是算不出结果的。</p><p>要想解决这一题，需要借助数学的力量。</p><h1 id="佩尔方程"><a href="#佩尔方程" class="headerlink" title="佩尔方程"></a>佩尔方程</h1><p>八年前第一次做这一题的时候，经过一番搜索，我从<a href="https://eli.thegreenplace.net/2009/06/19/project-euler-problem-66-and-continued-fractions/" target="_blank" rel="noopener">这篇文章</a>中知道了题目中的方程叫做<a href="https://zh.wikipedia.org/wiki/%E4%BD%A9%E5%B0%94%E6%96%B9%E7%A8%8B" target="_blank" rel="noopener">佩尔方程。</a>它有标准的解法，但需要用到连分数。那么什么是连分数呢？</p><p>连分数不是一种新的数系，只是小数的另一种写法。例如可以把分数45除以16写成下面的形式</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210211/一个连分数的例子.jpg" alt=""></p><p>就像定义递归的数据结构一样，可以给连分数一个递归的定义。连分数要么是一个整数，要么是一个整数加上另一个连分数的倒数。除了上面的形式，连分数也可以写成更节省篇幅的样子。比如把45除以16写成<code>[2;1,4,3]</code>，即把原本的式子中所有的整数部分按顺序写在一对方括号之间。这种记法，看起来就像是编程语言中的数组一般。</p><p>如果用数组<code>[2;1,4,3]</code>的不同前缀来构造分式，那么结果依次为<code>2/1</code>、<code>3/1</code>、<code>14/5</code>。它们是这个连分数的渐进连分数，而佩尔方程的一组解，就来自于渐进连分数的分子和分母。</p><p>以系数为7的佩尔方程为例，先计算出根号7的连分数，然后依次尝试它的渐进连分数。前三个分别为<code>2/1</code>、<code>3/1</code>、<code>5/2</code>，都不是方程的解。第四个渐进连分数<code>8/3</code>才是方程的解。如果继续提高连分数的精度，还会找到第二个解<code>127/48</code>。继续找，还有更多，而8则是其中最小的x。</p><p>所以，想要快速算出佩尔方程的解，最重要的是找到计算一个数的平方根的连分数的算法。</p><h1 id="计算平方根的连分数的错误方法"><a href="#计算平方根的连分数的错误方法" class="headerlink" title="计算平方根的连分数的错误方法"></a>计算平方根的连分数的错误方法</h1><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210211/连分数的通用形式.jpg" alt=""></p><p>要计算一个数字的连分数，最重要的便是要算出所有的整数部分（<code>a0</code>、<code>a2</code>、<code>a2</code>等）。它们都可以依据定义直接计算</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210211/整数部分的计算方法.png" alt=""></p><p>推广到一半情况，如果用变量<code>n</code>存储开平方的数字，用<code>numbers</code>存储所有已知的整数，那么用Python可以写出下面的算法来计算出下一个整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算连分数数列的下一个数字</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_next_integer_part</span><span class="params">(n, numbers)</span>:</span></span><br><span class="line">    v = math.sqrt(n)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> numbers:</span><br><span class="line">        v = <span class="number">1</span> / (v - a)</span><br><span class="line">    <span class="keyword">return</span> int(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = <span class="number">14</span></span><br><span class="line">    numbers = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    v = compute_next_integer_part(n, numbers)</span><br><span class="line">    print(<span class="string">'下一个数字为&#123;&#125;'</span>.format(v))</span><br></pre></td></tr></table></figure><p>遗憾的是，这个算法算出来的数字会因为计算上的精度误差而导致失之毫厘谬以千里。</p><h1 id="计算平方根的连分数的正确方法"><a href="#计算平方根的连分数的正确方法" class="headerlink" title="计算平方根的连分数的正确方法"></a>计算平方根的连分数的正确方法</h1><p>要想计算出正确的结果，就需要尽可能地消除在计算<code>1 / (v - a)</code>的时候引入的误差，因此必须把浮点数从分母中除去。</p><p>在<a href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cfINTRO.html#section6.2.2" target="_blank" rel="noopener">这个网站</a>中，作者以计算根号14的连分数为例，列出了一个表格</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210211/计算根号14连分数的过程.jpeg" alt=""></p><p>可以看到<code>x1</code>、<code>x2</code>，以及<code>x3</code>都是形如<code>(sqrt(n)+a)/b</code>这样的格式，这样的式子更利于控制误差。那么是否每一个待计算的<code>x</code>都符合这种格式呢？答案是肯定的，可以用数学归纳法予以证明（为了方便写公式，用LaTeX写好后截了图）</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210211/数学归纳法过程.jpg" alt=""></p><p>在这个证明过程中，还得到了分子中的<code>a</code>以及分母中的<code>b</code>的递推公式，现在可以写出正确的计算连分数整数部分的代码了。</p><h1 id="用Common-Lisp实现上述算法"><a href="#用Common-Lisp实现上述算法" class="headerlink" title="用Common Lisp实现上述算法"></a>用Common Lisp实现上述算法</h1><p>为了在实现这个算法的同时还要写出优雅的代码，我会用上Common Lisp的面向对象特性。首先是定义一个类来表示一个可以不断提高精度的连分数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defpackage</span> #<span class="symbol">:com</span>.liutos.cf</span><br><span class="line">  (<span class="symbol">:use</span> #<span class="symbol">:cl</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">in-package</span> #<span class="symbol">:com</span>.liutos.cf)</span><br><span class="line"></span><br><span class="line">(<span class="name">defclass</span> &lt;cf&gt; ()</span><br><span class="line">  ((<span class="name">a</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"数学归纳法中、分子中与平方根相加的数"</span></span><br><span class="line">    <span class="symbol">:initform</span> <span class="number">0</span>)</span><br><span class="line">   (<span class="name">b</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"数学归纳法中的分母"</span></span><br><span class="line">    <span class="symbol">:initform</span> <span class="number">1</span>)</span><br><span class="line">   (<span class="name">numbers</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"连分数中的整数部分依次组成的数组。"</span></span><br><span class="line">    <span class="symbol">:initform</span> <span class="literal">nil</span>)</span><br><span class="line">   (<span class="name">origin</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"被开平方的数字"</span></span><br><span class="line">    <span class="symbol">:initarg</span> <span class="symbol">:origin</span>))</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"表示整数ORIGIN的平方根的连分数。"</span>))</span><br></pre></td></tr></table></figure><p>接着再定义这个类需要实现的“接口”</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defgeneric</span> advance (<span class="name">cf</span>)</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"让连分数CF提高到下一个精度。"</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defgeneric</span> into-rational (<span class="name">cf</span>)</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"将连分数CF转换为有理数类型的值。"</span>))</span><br></pre></td></tr></table></figure><p>最后来实现上述两个接口</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmethod</span> advance ((<span class="name">cf</span> &lt;cf&gt;))</span><br><span class="line">  <span class="string">"根据递推公式计算出下一批a、b，以及连分数的整数部分。"</span></span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">a</span> (<span class="name">slot-value</span> cf 'a))</span><br><span class="line">         (<span class="name">b</span> (<span class="name">slot-value</span> cf 'b))</span><br><span class="line">         (<span class="name">n</span> (<span class="name">slot-value</span> cf 'origin))</span><br><span class="line">         (<span class="name">m</span> (<span class="name">truncate</span> (<span class="name">+</span> (<span class="name">sqrt</span> n) a) b)))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">a</span> (<span class="name">-</span> (<span class="name">*</span> b m) a))</span><br><span class="line">          (<span class="name">b</span> (<span class="name">/</span> (<span class="name">-</span> n (<span class="name">expt</span> (<span class="name">-</span> a (<span class="name">*</span> b m)) <span class="number">2</span>)) b)))</span><br><span class="line">      (<span class="name">setf</span> (<span class="name">slot-value</span> cf 'a) a</span><br><span class="line">            (<span class="name">slot-value</span> cf 'b) b</span><br><span class="line">            (<span class="name">slot-value</span> cf 'numbers) (<span class="name">append</span> (<span class="name">slot-value</span> cf 'numbers) (<span class="name">list</span> m))))</span><br><span class="line">    (<span class="name">values</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmethod</span> into-rational ((<span class="name">cf</span> &lt;cf&gt;))</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">numbers</span> (<span class="name">reverse</span> (<span class="name">slot-value</span> cf 'numbers)))</span><br><span class="line">         (<span class="name">v</span> (<span class="name">first</span> numbers)))</span><br><span class="line">    (<span class="name">dolist</span> (<span class="name">n</span> (<span class="name">rest</span> numbers))</span><br><span class="line">      (<span class="name">setf</span> v</span><br><span class="line">            (<span class="name">+</span> n (<span class="name">/</span> <span class="number">1</span> v))))</span><br><span class="line">    v))</span><br></pre></td></tr></table></figure><p>在实现<code>into-rational</code>方法上，Common Lisp的有理数数值类型给我带来了极大的便利，它使我不必担心计算<code>(/ 1 v)</code>的时候会引入误差，代码写起来简单直白。</p><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>乘胜追击，用Common Lisp解答第66题</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> find-min-x (<span class="name">D</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">cf</span> (<span class="name">make-instance</span> '&lt;cf&gt; <span class="symbol">:origin</span> D)))</span><br><span class="line">    (<span class="name">loop</span></span><br><span class="line">       (<span class="name">advance</span> cf)</span><br><span class="line">       (<span class="name">let*</span> ((<span class="name">ratio</span> (<span class="name">into-rational</span> cf))</span><br><span class="line">              (<span class="name">x</span> (<span class="name">numerator</span> ratio))</span><br><span class="line">              (<span class="name">y</span> (<span class="name">denominator</span> ratio)))</span><br><span class="line">         (<span class="name">when</span> (<span class="name">=</span> (<span class="name">-</span> (<span class="name">*</span> x x) (<span class="name">*</span> D y y)) <span class="number">1</span>)</span><br><span class="line">           (<span class="name">return-from</span> find-min-x x))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> square-p (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">rt</span> (<span class="name">sqrt</span> n)))</span><br><span class="line">    (<span class="name">=</span> rt (<span class="name">truncate</span> rt))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> pro66 (<span class="name">&amp;optional</span> (<span class="name">bnd</span> <span class="number">1000</span>))</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">target-d</span>)</span><br><span class="line">(<span class="name">max-x</span> <span class="number">0</span>))</span><br><span class="line">    (<span class="name">loop</span> <span class="symbol">:for</span> i <span class="symbol">:from</span> <span class="number">2</span> <span class="symbol">:to</span> bnd</span><br><span class="line">       <span class="symbol">:when</span> (<span class="name">not</span> (<span class="name">square-p</span> i))</span><br><span class="line">       <span class="symbol">:do</span> (<span class="name">let</span> ((<span class="name">x</span> (<span class="name">find-min-x</span> i)))</span><br><span class="line">     (<span class="name">if</span> (<span class="name">&gt;</span> x max-x)</span><br><span class="line"> (<span class="name">setf</span> target-d i</span><br><span class="line">       max-x x))))</span><br><span class="line">    (<span class="name">values</span> target-d max-x)))</span><br></pre></td></tr></table></figure><p>答案的D是多少就不说了，不过作为答案的x是16421658242965910275055840472270471049。有兴趣的读者可以试一下暴力解法要花多久才能算到这个数字。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://liutos.github.io/tags/algorithm/"/>
    
      <category term="project euler" scheme="https://liutos.github.io/tags/project-euler/"/>
    
      <category term="算法" scheme="https://liutos.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://liutos.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
  </entry>
  
  <entry>
    <title>format，不只是格式化</title>
    <link href="https://liutos.github.io/2021/01/29/format%EF%BC%8C%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://liutos.github.io/2021/01/29/format，不只是格式化/</id>
    <published>2021-01-29T15:05:51.000Z</published>
    <updated>2021-01-29T15:07:32.506Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《实战Common Lisp》系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。MAKE COMMON LISP GREAT AGAIN。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>写了一段时间的Python后，总觉得它跟Common Lisp（下文简称CL）有亿点点像。例如，Python和CL都支持可变数量的函数参数。在Python中写作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(* args)</span>:</span></span><br><span class="line">    print(args)</span><br></pre></td></tr></table></figure><p>而在CL中则写成</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foo (<span class="name">&amp;rest</span> args)</span><br><span class="line">  (<span class="name">print</span> args))</span><br></pre></td></tr></table></figure><p>Python的语法更紧凑，而CL的语法表意更清晰。此外，它们也都支持关键字参数。在Python中写成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(*, a=None, b=None)</span>:</span></span><br><span class="line">    print(<span class="string">'a=&#123;&#125;\tb=&#123;&#125;'</span>.format(a, b))</span><br></pre></td></tr></table></figure><p>而在CL中则是</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> bar (<span class="name">&amp;key</span> (<span class="name">a</span> <span class="literal">nil</span>) (<span class="name">b</span> <span class="literal">nil</span>))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"a=~A~8Tb=~A~%"</span> a b))</span><br></pre></td></tr></table></figure><p>尽管CL的<code>&amp;key</code>仍然更清晰，但声明参数默认值的语法确实是Python更胜一筹。</p><p>细心的读者可能发现了，在Python中有一个叫做<code>format</code>的方法（属于字符串类），而在CL则有一个叫做<code>format</code>的函数。并且，从上面的例子来看，它们都负责生成格式化的字符串，那么它们有相似之处吗？</p><p>答案是否定的，CL的<code>format</code>简直就是格式化打印界的一股泥石流。</p><h1 id="format的基本用法"><a href="#format的基本用法" class="headerlink" title="format的基本用法"></a><code>format</code>的基本用法</h1><p>不妨从上面的示例代码入手介绍CL中的<code>format</code>（下文在不引起歧义的情况下，简称为<code>format</code>）的基本用法。首先，它需要至少两个参数：</p><ul><li>第一个参数控制了<code>format</code>将会把格式化后的字符串打印到什么地方。<code>t</code>表示打印到标准输出；</li><li>第二个参数则是本文的主角，名为控制字符串（control-string）。它指导<code>format</code>如何格式化。</li></ul><p>听起来很神秘，但其实跟C语言的<code>fprintf</code>也没什么差别。</p><p>在控制字符串中，一般会有许多像占位符一般的命令（directive）。正如Python的<code>format</code>方法中，有各式各样的<a href="https://docs.python.org/3/library/string.html#formatspec" target="_blank" rel="noopener">format_spec</a>能够格式化对应类型的数据，控制字符串中的命令也有很多种，常见的有：</p><ul><li>打印二进制数字的<code>~B</code>，例如<code>(format t &quot;~B&quot; 5)</code>会打印出101；</li><li>打印八进制数字的<code>~O</code>，例如<code>(format t &quot;~O&quot; 8)</code>会打印出10；</li><li>打印十进制数字的<code>~D</code>；</li><li>打印十六进制数字的<code>~X</code>，例如<code>(format t &quot;~X&quot; 161)</code>会打印出A1；</li><li>打印任意一种类型的<code>~A</code>，一般打印字符串的时候会用到。</li></ul><p>另外，<code>format</code>的命令也支持参数。在Python中，可以用下列代码打印右对齐的、左侧填充字符0的、二进制形式的数字5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'&#123;:0&gt;8b&#125;'</span>.format(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p><code>format</code>函数也可以做到同样的事情</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~8,'0B"</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>到这里为止，你可能会觉得<code>format</code>的控制字符串，不过就是将花括号去掉、冒号换成波浪线，以及参数语法不一样的<code>format</code>方法的翻版罢了。</p><p>接下来，让我们进入<code>format</code>的黑科技领域。</p><h1 id="format的高级用法"><a href="#format的高级用法" class="headerlink" title="format的高级用法"></a><code>format</code>的高级用法</h1><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>前面列举了打印二、八、十，以及十六进制的命令，但<code>format</code>还支持其它的进制。使用命令<code>~R</code>搭配参数，<code>format</code>可以打印数字从2到36进制的所有形态。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~3R~%"</span> <span class="number">36</span>)   <span class="comment">; 以 3进制打印数字36，结果为1100</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~5R~%"</span> <span class="number">36</span>)   <span class="comment">; 以 5进制打印数字36，结果为 121</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~7R~%"</span> <span class="number">36</span>)   <span class="comment">; 以 7进制打印数字36，结果为  51</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~11R~%"</span> <span class="number">36</span>)  <span class="comment">; 以11进制打印数字36，结果为  33</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~13R~%"</span> <span class="number">36</span>)  <span class="comment">; 以13进制打印数字36，结果为  2A</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~17R~%"</span> <span class="number">36</span>)  <span class="comment">; 以17进制打印数字36，结果为  22</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~19R~%"</span> <span class="number">36</span>)  <span class="comment">; 以19进制打印数字36，结果为  1H</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~23R~%"</span> <span class="number">36</span>)  <span class="comment">; 以23进制打印数字36，结果为  1D</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~29R~%"</span> <span class="number">36</span>)  <span class="comment">; 以29进制打印数字36，结果为  17</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~31R~%"</span> <span class="number">36</span>)  <span class="comment">; 以31进制打印数字36，结果为  15</span></span><br></pre></td></tr></table></figure><p>之所以最大为36进制，是因为十个阿拉伯数字，加上二十六个英文字母正好是三十六个。那如果不给<code>~R</code>加任何参数，会使用0进制吗？非也，<code>format</code>会把数字打印成英文单词</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~R~%"</span> <span class="number">123</span>) <span class="comment">; 打印出one hundred twenty-three</span></span><br></pre></td></tr></table></figure><p>甚至可以让<code>format</code>打印罗马数字，只要加上<code>@</code>这个修饰符即可</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~@R~%"</span> <span class="number">123</span>) <span class="comment">; 打印出CXXIII</span></span><br></pre></td></tr></table></figure><p>天晓得为什么要内置这么冷门的功能。</p><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p>你，作为一名细心的读者，可能留意到了，<code>format</code>的<code>~X</code>只能打印出大写字母，而在Python的<code>format</code>方法中，<code>{:x}</code>可以输出小写字母的十六进制数字。即使你在<code>format</code>函数中使用<code>~x</code>也是无效的，因为命令是大小写不敏感的（case insensitive）。</p><p>那要怎么实现打印小写字母的十六进制数字呢？答案是使用新的命令<code>~(</code>，以及它配套的命令<code>~)</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~(~X~)~%"</span> <span class="number">26</span>) <span class="comment">; 打印1a</span></span><br></pre></td></tr></table></figure><p>配合<code>:</code>和<code>@</code>修饰符，一共可以实现四种大小写风格</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~(hello world~)~%"</span>)   <span class="comment">; 打印hello world</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~:(hello world~)~%"</span>)  <span class="comment">; 打印Hello World</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~@(hello world~)~%"</span>)  <span class="comment">; 打印Hello world</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~:@(hello world~)~%"</span>) <span class="comment">; 打印HELLO WORLD</span></span><br></pre></td></tr></table></figure><h2 id="对齐控制"><a href="#对齐控制" class="headerlink" title="对齐控制"></a>对齐控制</h2><p>在Python的<code>format</code>方法中，可以控制打印出的内容的宽度，这一点在“<code>format</code>的基本用法”中已经演示过了。如果设置的最小宽度（在上面的例子中，是8）超过了打印的内容所占据的宽度（在上面的例子中，是3），那么还可以控制其采用左对齐、右对齐，还是居中对齐。</p><p>在CL的<code>format</code>函数中，不管是<code>~B</code>、<code>~D</code>、<code>~O</code>，还是<code>~X</code>，都没有控制对齐方式的选项，数字总是右对齐。要控制对齐方式，需要用到<code>~&lt;</code>和它配套的<code>~&gt;</code>。例如，下面的CL代码可以让数字在八个宽度中左对齐</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"|~8&lt;~B~;~&gt;|"</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>打印内容为<code>|101     |</code>。<code>~&lt;</code>跟前面提到的其它命令不一样，它不消耗控制字符串之后的参数，它只控制<code>~&lt;</code>和<code>~&gt;</code>之间的字符串的布局。这意味着，即使<code>~&lt;</code>和<code>~&gt;</code>之间是字符串常量，它也可以起作用。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"|~8,,,'-&lt;~;hello~&gt;|"</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面的代码运行后会打印出<code>|---hello|</code>：8表示用于打印的最小宽度；三个逗号（<code>,</code>）之间为空，表示忽略<code>~&lt;</code>的第二和第三个参数；第四个参数控制着打印结果中用于填充的字符，由于<code>-</code>不是数字，因此需要加上单引号前缀；<code>~;</code>是内部的分隔符，由于它的存在，<code>hello</code>成了最右侧的字符串，因此会被右对齐。</p><p>如果<code>~&lt;</code>和<code>~&gt;</code>之间的内容被<code>~;</code>分隔成了三部分，还可以实现左对齐、居中对齐，以及右对齐的效果</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"|~24&lt;left~;middle~;right~&gt;|"</span>) <span class="comment">; 打印出|left    middle     right|</span></span><br></pre></td></tr></table></figure><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>通常情况下，控制字符串中的命令会消耗参数，比如<code>~B</code>和<code>~D</code>等命令。也有像<code>~&lt;</code>这样不消耗参数的命令。但有的命令甚至可以做到“一参多用”，那就是<code>~*</code>。比如，给<code>~*</code>加上冒号修饰，就可以让上一个被消耗的参数重新被消耗一遍</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~8D~:*~8D~8D~%"</span> <span class="number">1</span> <span class="number">2</span>) <span class="comment">; 打印出       1       1       2</span></span><br></pre></td></tr></table></figure><p>在<code>~8D</code>消耗了参数1之后，<code>~:*</code>让下一个被消耗的参数重新指向了1，因此第二个<code>~8D</code>拿到的参数仍然是1，最后一个拿到了2。尽管控制字符串中看起来有三个<code>~D</code>命令而参数只有两个，却依然可以正常打印。</p><p>在<code>format</code>的文档中一个不错的例子，就是让<code>~*</code>和<code>~P</code>搭配使用。<code>~P</code>可以根据它对应的参数是否大于1，来打印出字母<code>s</code>或者什么都不打印。配合<code>~:*</code>就可以实现根据参数打印出单词的单数或复数形式的功能</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~D dog~:*~P~%"</span> <span class="number">1</span>) <span class="comment">; 打印出1 dog</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~D dog~:*~P~%"</span> <span class="number">2</span>) <span class="comment">; 打印出2 dogs</span></span><br></pre></td></tr></table></figure><p>甚至你可以组合一下前面的毕生所学</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~@(~R dog~:*~P~)~%"</span> <span class="number">2</span>) <span class="comment">; 打印出Two dogs</span></span><br></pre></td></tr></table></figure><h2 id="条件打印"><a href="#条件打印" class="headerlink" title="条件打印"></a>条件打印</h2><p>命令<code>~[</code>和<code>~]</code>也是成对出现的，它们的作用是选择性打印，不过比起编程语言中的<code>if</code>，更像是取数组某个下标的元素</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~[~;one~;two~;three~]~%"</span> <span class="number">1</span>) <span class="comment">; 打印one</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~[~;one~;two~;three~]~%"</span> <span class="number">2</span>) <span class="comment">; 打印two</span></span><br><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~[~;one~;two~;three~]~%"</span> <span class="number">3</span>) <span class="comment">; 打印three</span></span><br></pre></td></tr></table></figure><p>但这个特性还挺鸡肋的。想想，你肯定不会无缘无故传入一个数字来作为下标，而这个作为下标的数字很可能本身就是通过<code>position</code>之类的函数计算出来的，而<code>position</code>就要求传入待查找的<code>item</code>和整个列表<code>sequence</code>，而为了用上<code>~[</code>你还得把列表中的每个元素硬编码到控制字符串中，颇有南辕北辙的味道。</p><p>给它加上冒号修饰符之后倒是有点用处，比如可以将CL中的真（<code>NIL</code>以外的所有对象）和假（<code>NIL</code>）打印成单词<code>true</code>和<code>false</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~:[false~;true~]"</span> <span class="literal">nil</span>) <span class="comment">; 打印false</span></span><br></pre></td></tr></table></figure><h2 id="循环打印"><a href="#循环打印" class="headerlink" title="循环打印"></a>循环打印</h2><p>圆括号和方括号都用了，又怎么能少了花括号呢。没错，<code>~{</code>也是一个命令，它的作用是遍历列表。例如，想要打印出一个列表中的每个元素，并且两两之间用逗号和空格分开的话，可以用下列代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~&#123;~D~^, ~&#125;"</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)) <span class="comment">; 打印出1, 2, 3</span></span><br></pre></td></tr></table></figure><p><code>~{</code>和<code>~}</code>之间也可以有不止一个命令，例如下列代码中每次会消耗列表中的两个元素</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"&#123;~&#123;\"~A\": ~D~^, ~&#125;&#125;"</span> '(<span class="symbol">:a</span> <span class="number">3</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>打印结果为<code>{&quot;A&quot;: 3, &quot;B&quot;: 2, &quot;C&quot;: 1}</code>。如果把这两个<code>format</code>表达式拆成用循环写的、不使用<code>format</code>的等价形式，大约是下面这样子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 与(format t "~&#123;~D~^, ~&#125;" '(1 2 3))等价</span></span><br><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">do</span> ((<span class="name">lst</span> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">cdr</span> lst)))</span><br><span class="line">      ((<span class="name">null</span> lst))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">e</span> (<span class="name">car</span> lst)))</span><br><span class="line">      (<span class="name">princ</span> e)</span><br><span class="line">      (<span class="name">when</span> (<span class="name">cdr</span> lst)</span><br><span class="line">        (<span class="name">princ</span> <span class="string">", "</span>))))</span><br><span class="line">  (<span class="name">princ</span> #\Newline))</span><br><span class="line"></span><br><span class="line"><span class="comment">; 与(format t "&#123;~&#123;\"~A\": ~D~^, ~&#125;&#125;" '(:a 3 :b 2 :c 1))等价</span></span><br><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">princ</span> <span class="string">"&#123;"</span>)</span><br><span class="line">  (<span class="name">do</span> ((<span class="name">lst</span> '(<span class="symbol">:c</span> <span class="number">3</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:a</span> <span class="number">1</span>) (<span class="name">cddr</span> lst)))</span><br><span class="line">      ((<span class="name">null</span> lst))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">key</span> (<span class="name">car</span> lst))</span><br><span class="line">          (<span class="name">val</span> (<span class="name">cadr</span> lst)))</span><br><span class="line">      (<span class="name">princ</span> <span class="string">"\""</span>)</span><br><span class="line">      (<span class="name">princ</span> key)</span><br><span class="line">      (<span class="name">princ</span> <span class="string">"\": "</span>)</span><br><span class="line">      (<span class="name">princ</span> val)</span><br><span class="line">      (<span class="name">when</span> (<span class="name">cddr</span> lst)</span><br><span class="line">        (<span class="name">princ</span> <span class="string">", "</span>))))</span><br><span class="line">  (<span class="name">princ</span> <span class="string">"&#125;"</span>)</span><br><span class="line">  (<span class="name">princ</span> #\Newline))</span><br></pre></td></tr></table></figure><p>这么看来，<code>~{</code>确实可以让使用者写出更紧凑的代码。</p><h2 id="参数化参数"><a href="#参数化参数" class="headerlink" title="参数化参数"></a>参数化参数</h2><p>在前面的例子中，尽管用<code>~R</code>搭配不同的参数可以将数字打印成不同进制的形式，但毕竟这个参数是固化在控制字符串中的，局限性很大。例如，如果我想要定义一个函数<code>print-x-in-base-y</code>，使得参数<code>x</code>可以打印为<code>y</code>进程的形式，那么也许会这么写</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> print-x-in-base-y (<span class="name">x</span> y)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">control-string</span> (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"~~~DR"</span> y)))</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> control-string x)))</span><br></pre></td></tr></table></figure><p>但<code>format</code>的灵活性，允许使用者将命令的前缀参数也放到控制字符串之后的列表中，因此可以写成如下更简练的实现</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> print-x-in-base-y (<span class="name">x</span> y)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~VR"</span> y x))</span><br></pre></td></tr></table></figure><p>而且不只一个，你可以把所有参数都写成参数的形式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> print-x-in-base-y (<span class="name">x</span></span><br><span class="line">                          <span class="symbol">&amp;optional</span> y</span><br><span class="line">                          <span class="symbol">&amp;rest</span> args</span><br><span class="line">                          <span class="symbol">&amp;key</span> mincol padchar commachar commainterval)</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> args))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~V,V,V,V,VR"</span></span><br><span class="line">          y mincol padchar commachar commainterval x))</span><br></pre></td></tr></table></figure><p>恭喜你重新发明了<code>~R</code>，而且还不支持<code>:</code>和<code>@</code>修饰符。</p><h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><p>要在CL中打印形如<code>2021-01-29 22:43</code>这样的日期和时间字符串，是一件比较麻烦的事情</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">multiple-value-bind</span> (<span class="name">sec</span> min hour date mon year)</span><br><span class="line">    (<span class="name">decode-universal-time</span> (<span class="name">get-universal-time</span>))</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> sec))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~4D-~2,'0D-~2,'0D ~2,'0D:~2,'0D~%"</span></span><br><span class="line">          year mon date hour min))</span><br></pre></td></tr></table></figure><p>谁让CL没有内置像Python的<code>datetime</code>模块这般完善的功能呢。不过，借助<code>format</code>的<code>~/</code>命令，我们可以在控制字符串中写上要调用的自定义函数，来深度定制打印出来的内容。以打印上述格式的日期和时间为例，首先定义一个后续要用的自定义函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> yyyy-mm-dd-HH-MM (<span class="name">dest</span> arg is-colon-p is-at-p <span class="symbol">&amp;rest</span> args)</span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> args is-at-p is-colon-p))</span><br><span class="line">  (<span class="name">multiple-value-bind</span> (<span class="name">sec</span> min hour date mon year)</span><br><span class="line">      (<span class="name">decode-universal-time</span> arg)</span><br><span class="line">    (<span class="name">declare</span> (<span class="name">ignorable</span> sec))</span><br><span class="line">    (<span class="name">format</span> dest <span class="string">"~4D-~2,'0D-~2,'0D ~2,'0D:~2,'0D~%"</span></span><br><span class="line">            year mon date hour min)))</span><br></pre></td></tr></table></figure><p>然后便可以直接在控制字符串中使用它的名字</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">"~/yyyy-mm-dd-HH-MM/"</span> (<span class="name">get-universal-time</span>))</span><br></pre></td></tr></table></figure><p>在我的机器上运行的时候，打印内容为<code>2021-01-29 22:51</code>。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>format</code>可以做的事情还有很多，CL的HyperSpec中有关于<code>format</code>函数的<a href="http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_22-3.html" target="_blank" rel="noopener">详细介绍</a>，CL爱好者一定不容错过。</p><p>最后，其实Python跟CL并不怎么像。每每看到Python中的<code>__eq__</code>、<code>__ge__</code>，以及<code>__len__</code>等方法的巧妙运用时，身为一名Common Lisp爱好者，我都会流露出羡慕的神情。纵然CL被称为可扩展的编程语言，这些平凡的功能却依旧无法方便地做到呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="实战CommonLisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98CommonLisp/"/>
    
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
      <category term="format" scheme="https://liutos.github.io/tags/format/"/>
    
      <category term="格式化打印" scheme="https://liutos.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>年轻人的第一个VSCode扩展</title>
    <link href="https://liutos.github.io/2021/01/02/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAVSCode%E6%8F%92%E4%BB%B6/"/>
    <id>https://liutos.github.io/2021/01/02/年轻人的第一个VSCode插件/</id>
    <published>2021-01-02T08:18:34.000Z</published>
    <updated>2021-01-02T08:28:06.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>入坑<code>VS Code</code>前，我已经是一名久经考验的<code>Emacs</code>老用户了，因此开始正式使用<code>VS Code</code>后，我第一时间启用了它的<a href="https://marketplace.visualstudio.com/items?itemName=hiro-sun.vscode-emacs" target="_blank" rel="noopener"><code>Emacs Keymap</code></a>。但不久我便发现，这套键映射缺少一个重要的快捷键——<code>ctrl-l</code>。</p><p>在<code>Emacs</code>中，<code>ctrl-l</code>对应的命令是<code>recenter-top-bottom</code>，它用于将光标所在的行轮替地滚动到可视区域（即<code>Emacs</code>中的<code>window</code>）的中间、顶部，以及底部（如下图所示）</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210102/Emacs的ctrl-l效果演示.gif" alt=""></p><p>这是我高频使用的一个功能，尤其是跳转到函数的定义的首行后，我习惯于连按两次，将其滚动到<code>window</code>的顶部以便在一屏中看到尽量多的内容。</p><p>为了避免重复发明轮子，我先搜索了一番，找到了一个宣称实现了该功能的扩展<a href="https://marketplace.visualstudio.com/items?itemName=yeannylam.recenter-top-bottom" target="_blank" rel="noopener"><code>Recenter Top Bottom</code></a>。可惜的是，安装后并不生效。</p><p>难道只能委屈自己用鼠标小心翼翼地将光标所在行滚到顶部了吗？当然不是。既然没有开箱即用的，那便自己写一个<code>VS Code</code>的扩展实现这个功能吧。</p><h1 id="年轻人的第一个VS-Code扩展"><a href="#年轻人的第一个VS-Code扩展" class="headerlink" title="年轻人的第一个VS Code扩展"></a>年轻人的第一个VS Code扩展</h1><h2 id="创建VS-Code扩展的项目"><a href="#创建VS-Code扩展的项目" class="headerlink" title="创建VS Code扩展的项目"></a>创建VS Code扩展的项目</h2><p>要想入门<code>VS Code</code>扩展的开发，官方便提供了一份不错的<a href="https://code.visualstudio.com/api/get-started/your-first-extension" target="_blank" rel="noopener">教程</a>。一个扩展有许多的“八股文”代码，可以用<code>yo</code>和<code>generator-code</code>来快速生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo generator-code</span><br><span class="line">yo code</span><br></pre></td></tr></table></figure><p>到这里，便得到了一个名为<code>helloworld</code>的目录了。用<code>VS Code</code>打开它，接下来要在其中大展身手。</p><h2 id="实现将光标所在行垂直居中的功能"><a href="#实现将光标所在行垂直居中的功能" class="headerlink" title="实现将光标所在行垂直居中的功能"></a>实现将光标所在行垂直居中的功能</h2><p><code>VS Code</code>扩展的核心逻辑定义在文件<code>src/extension.ts</code>中。在<code>yo</code>生成的示例代码中，用<code>registerCommand</code>注册了一个名为<code>helloworld.helloWorld</code>的命令，其逻辑是简单地在右下角弹出一句<code>Hello VS Code from HelloWorld!</code>。这个回调函数，便是业务逻辑的落脚点。</p><p>要想实现将光标所在行滚动到中间的功能，首先要知道<code>VS Code</code>为开发者提供了哪些支持。在摸索了一通从<code>VS Code</code>的<a href="https://code.visualstudio.com/api/references/vscode-api" target="_blank" rel="noopener"><code>API文档</code></a>后，我有了以下的线索：</p><ol><li>通过<code>vscode.window.activeTextEditor</code>可以取得当前聚焦的编辑器——其值可能为空（<code>undefined</code>）；</li><li><code>TextEditor</code>实例的属性<code>.selection.active</code>可以取得当前光标的位置；</li><li><code>TextEditor</code>实例有一个方法<code>revealRange</code>可以滚动文本来改变展示的范围，它需要一个<code>vscode.Range</code>类的实例，以及一个<code>vscode.TextEditorRevealType</code>类型的枚举值；</li><li><code>vscode.TextEditorRevealType.InCenter</code>的效果是将所给定的范围展示在中间，<code>vscode.TextEditorRevealType.AtTop</code>则是置顶。</li></ol><p>有了这些知识储备，实现这样的一个回调函数便是信手拈来的事情了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recenterTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line">  <span class="keyword">if</span> (!editor) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cursorPosition = editor.selection.active;</span><br><span class="line">  editor.revealRange(<span class="keyword">new</span> vscode.Range(cursorPosition, cursorPosition), vscode.TextEditorRevealType.InCenter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于暂时没有配置该命令的快捷键，只能用<code>VS Code</code>的命令面板来调用</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20210102/初步实现居中的效果.gif" alt=""></p><h2 id="实现将光标所在行置顶的功能"><a href="#实现将光标所在行置顶的功能" class="headerlink" title="实现将光标所在行置顶的功能"></a>实现将光标所在行置顶的功能</h2><p>接下来我将实现连续调用两次<code>helloworld.helloWorld</code>命令，把光标所在行滚动到顶部的效果。在<code>Emacs</code>中，可以很轻松地知道一个命令是否被连续运行——<code>Emacs</code>有一个名为<code>last-command</code>的变量存储着上一个命令的名称，只需要检查其是否等于<code>recenter-top-bottom</code>即可。但<code>VS Code</code>没有暴露这么强大的功能，只能另辟蹊径。</p><p>我的策略是，如果调用<code>helloworld.helloWorld</code>时光标的位置，与上一次调用该命令时的位置相同，就认为是连续调用。为此，需要两个在函数<code>recenterTop</code>之外定义的变量：</p><ol><li><code>previousPosition</code>负责记录上一次调用<code>recenterTop</code>时光标的位置，它的初始值为<code>null</code>；</li><li><code>revealType</code>存储着上一次调整展示范围时传递给<code>TextEditor</code>实例的<code>revealRange</code>方法的第二个参数的值，它的初始值也为<code>null</code>。</li></ol><p>我的目标是尽量模拟<code>Emacs</code>中的<code>recenter-top-bottom</code>所具备的、交替使用居中、置顶效果的特点，因此：</p><ol><li>如果<code>revealType</code>为<code>null</code>，意味着这是第一次调用<code>recenterTop</code>，那么效果便是居中。否则；</li><li>如果这一次与上一次的光标位置不同，意味着在上一次调用<code>recenterTop</code>后调用过其它命令，效果依然是居中。否则；</li><li>如果<code>revealType</code>已经是居中了，就改为置顶。否则；</li><li>将<code>revealType</code>改为居中。</li></ol><blockquote><p>Talk is cheap. Show me the code.</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> previousPosition: <span class="literal">null</span>|vscode.Position = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> revealType: <span class="literal">null</span>|vscode.TextEditorRevealType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recenterTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line">  <span class="keyword">if</span> (!editor) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cursorPosition = editor.selection.active;</span><br><span class="line">  <span class="keyword">if</span> (!revealType) &#123;</span><br><span class="line">    revealType = vscode.TextEditorRevealType.InCenter;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previousPosition &amp;&amp; !cursorPosition.isEqual(previousPosition)) &#123;</span><br><span class="line">    revealType = vscode.TextEditorRevealType.InCenter;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (revealType === vscode.TextEditorRevealType.InCenter) &#123;</span><br><span class="line">    revealType = vscode.TextEditorRevealType.AtTop;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    revealType = vscode.TextEditorRevealType.InCenter;</span><br><span class="line">  &#125;</span><br><span class="line">  previousPosition = cursorPosition;</span><br><span class="line">  editor.revealRange(<span class="keyword">new</span> vscode.Range(cursorPosition, cursorPosition), revealType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义快捷键"><a href="#定义快捷键" class="headerlink" title="定义快捷键"></a>定义快捷键</h2><p>通过命令面板来使用不是我的最终目标，通过快捷键才是。根据<code>VS Code</code>的<a href="https://code.visualstudio.com/api/references/contribution-points#contributes.keybindings" target="_blank" rel="noopener">文档</a>可以知道，只要在<code>package.json</code>的<code>contributes</code>对象中，新增名为<code>keybindings</code>的属性，并定义命令及按键序列即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 此处省略其它不必要的属性</span></span><br><span class="line">  <span class="string">"contributes"</span>: &#123;</span><br><span class="line">    <span class="string">"keybindings"</span>:&#123; <span class="comment">// 新增属性</span></span><br><span class="line">      <span class="string">"command"</span>: <span class="string">"helloworld.helloWorld"</span>,</span><br><span class="line">      <span class="string">"key"</span>: <span class="string">"ctrl+l"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果看过我之前的文章<a href="https://liutos.github.io/2020/09/28/%E6%89%8B%E6%8C%87%E7%96%BC%EF%BC%8C%E5%86%99%E7%82%B9%E4%BB%A3%E7%A0%81%E7%BC%93%E8%A7%A3%E4%B8%80%E4%B8%8B/">《手指疼，写点代码缓解一下》</a>的读者应当会记得，我已经从<code>Emacs Keymap</code>“叛逃”到了<code>Vim Keymap</code>了。所以，我并没有真正用上上述的<code>VS Code</code>扩展。相反，目前高频使用的是<code>Vim Keymap</code>内置的<code>z-.</code>以及<code>z-↵</code>了——前者用于垂直居中，后者用于置顶。</p><p>爱护手指，从使用<code>Vim Keymap</code>做起。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="editor" scheme="https://liutos.github.io/tags/editor/"/>
    
      <category term="编辑器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="vscode" scheme="https://liutos.github.io/tags/vscode/"/>
    
      <category term="工具" scheme="https://liutos.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>自己动手丰衣足食——用Hammerspoon控制Emacs的窗口</title>
    <link href="https://liutos.github.io/2020/12/20/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E4%B8%B0%E8%A1%A3%E8%B6%B3%E9%A3%9F%E2%80%94%E2%80%94%E7%94%A8Hammerspoon%E6%8E%A7%E5%88%B6Emacs%E7%9A%84%E7%AA%97%E5%8F%A3/"/>
    <id>https://liutos.github.io/2020/12/20/自己动手丰衣足食——用Hammerspoon控制Emacs的窗口/</id>
    <published>2020-12-20T13:00:07.000Z</published>
    <updated>2020-12-20T13:00:07.698Z</updated>
    
    <content type="html"><![CDATA[<p>有一天，我用<code>Homebrew</code>安装了一些软件——因为已经是一个月前的事情了，所以已经记不清是安装了什么。安装后并没有立即出现什么问题，只是又过了两天我重新启动电脑后，发现同样是由<code>Homebrew</code>安装的<code>Emacs</code>不由分说地无法启动了。这下可麻烦了，毕竟我是<code>org-mode</code>的重度使用者，还需要偶尔用<code>SLIME</code>写点Common Lisp的代码，而它们都运行在<code>Emacs</code>中。</p><p>直觉告诉我，也许重新安装一下<code>Emacs</code>，一切就可以恢复正常。重装了<code>Emacs</code>后，又遇到了别的问题——用<code>BetterTouchTools</code>在Touch Bar中添加的按钮，无法在<code>Emacs</code>已经启动的情况下，切换到它的窗口上。</p><p>非要说，问题其实也不大，毕竟很多时候是将MacBook Pro合上盖子当主机用的，Touch Bar在工作时的使用频率并不高。此外，糊<code>Node.js</code>等语言的代码时也用不到<code>Emacs</code>——还是<code>VSCode</code>更合适。</p><p>但这就是令人不爽，因此我决定要解决它——用<code>Hammerspoon</code>。</p><h1 id="Hammerspoon是什么？"><a href="#Hammerspoon是什么？" class="headerlink" title="Hammerspoon是什么？"></a>Hammerspoon是什么？</h1><p><code>Hammerspoon</code>的<a href="https://www.hammerspoon.org/" target="_blank" rel="noopener">官网</a>很好地说明了这款工具的定位和原理</p><blockquote><p>This is a tool for powerful automation of OS X. At its core, Hammerspoon is just a bridge between the operating system and a Lua scripting  engine. What gives Hammerspoon its power is a set of extensions that expose  specific pieces of system functionality, to the user.</p></blockquote><ol><li>它运行在OS X上——现在应该叫macOS；</li><li>它是用来自动化操作的——就像系统内置的<code>Automator</code>或第三方的<code>Alfred Workflow</code>那样；</li><li>它的原理是将操作系统的功能封装成了可以用<code>Lua</code>代码调用的模块；</li></ol><p>例如下面的代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"E"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  hs.alert.show(<span class="string">"Hello World!"</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>就可以让使用者在按下组合键<code>⌘⌥⌃e</code>的时候，在屏幕正中间显示<code>Hello World!</code>这段文本</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201220/hammerspoon的示例.jpg" alt=""></p><h1 id="为什么用Hammerspoon？"><a href="#为什么用Hammerspoon？" class="headerlink" title="为什么用Hammerspoon？"></a>为什么用Hammerspoon？</h1><p><code>Hammerspoon</code>正好可以解决我的问题，它的<code>hs.window</code>模块既可以让使用者遍历所有打开的窗口（用<a href="https://www.hammerspoon.org/docs/hs.window.html#allWindows" target="_blank" rel="noopener"><code>hs.window.allWindows</code>函数</a>），也可以聚焦到指定的窗口上（用<a href="https://www.hammerspoon.org/docs/hs.window.html#focus" target="_blank" rel="noopener"><code>focus</code>方法</a>）。有了它们，将<code>Emacs</code>调到最前面（front-most）来也就是水到渠成的事情了：</p><ol><li>调用函数<code>hs.window.allWindows</code>函数，获得所有窗口的列表；</li><li>逐个检查列表中的窗口对象，如果属于<code>Emacs</code>的，就调用窗口的方法<code>focus</code>，并跳出循环。</li></ol><p>剩下的两个问题便是：</p><ol><li><code>Emacs</code>的<code>bundle ID</code>是什么；</li><li>如何知道一个窗口对象的<code>bundle ID</code>。</li></ol><h1 id="Emacs的bundle-ID"><a href="#Emacs的bundle-ID" class="headerlink" title="Emacs的bundle ID"></a>Emacs的bundle ID</h1><p><code>Bundle ID</code>可以在macOS中独一无二地标识一个应用。要想知道<code>Emacs</code>的<code>bundle ID</code>是什么，只需要打开文件<code>/Applications/Emacs.app/Contents/Info.plist</code>，看看其中键为<code>CFBundleIdentifier</code>的值即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Contents grep -A 1 <span class="string">'CFBundleIdentifier'</span> Info.plist</span><br><span class="line">&lt;key&gt;CFBundleIdentifier&lt;/key&gt;</span><br><span class="line">&lt;string&gt;org.gnu.Emacs&lt;/string&gt;</span><br><span class="line">➜  Contents</span><br></pre></td></tr></table></figure><p>可以看到，<code>Emacs</code>的<code>bundle ID</code>是<code>org.gnu.Emacs</code>。</p><h1 id="来点Lua代码吧"><a href="#来点Lua代码吧" class="headerlink" title="来点Lua代码吧"></a>来点Lua代码吧</h1><p>有了<code>Emacs</code>的<code>bundle ID</code>，接下来就可以在<code>Hammerspoon</code>中定义快捷键了。由于最后会通过Touch Bar上的按钮来触发这组快捷键，复杂点也不要紧，因此我直接沿用了<code>Hammerspoon</code>的入门指引中作为例子的<code>⌘⌥⌃w</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"W"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>为了在一个循环中逐个遍历窗口对象，将<code>hs.window.allWindows</code>的返回值保存到一个局部变量中</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"W"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">local</span> windows = hs.window.allWindows()</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>照着简书上的<a href="https://www.jianshu.com/p/de5a4b132918" target="_blank" rel="noopener">这篇文章</a>，依葫芦画瓢地用<code>for</code>和<code>pairs</code>来遍历变量<code>windows</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"W"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">local</span> windows = hs.window.allWindows()</span><br><span class="line">      <span class="comment">-- 在Lua中遍历表的方法：https://www.jianshu.com/p/de5a4b132918</span></span><br><span class="line">      <span class="keyword">for</span> _, win <span class="keyword">in</span> <span class="built_in">pairs</span>(windows) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>窗口自身没有<code>bundle ID</code>，为此需要先获取窗口所属的应用。查看文档可以知道，有一个<a href="https://www.hammerspoon.org/docs/hs.window.html#application" target="_blank" rel="noopener"><code>application</code>方法</a>正是用来获取应用对象的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"W"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">local</span> windows = hs.window.allWindows()</span><br><span class="line">      <span class="comment">-- 在Lua中遍历表的方法：https://www.jianshu.com/p/de5a4b132918</span></span><br><span class="line">      <span class="keyword">for</span> _, win <span class="keyword">in</span> <span class="built_in">pairs</span>(windows) <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">local</span> app = win:application()</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>调用<code>allWindows</code>时使用的是英文句号（<code>.</code>），调用<code>application</code>则是用冒号（<code>:</code>），这正是<code>Lua</code>中调用函数与方法时语法上的差异。</p><p>再用应用的<a href="https://www.hammerspoon.org/docs/hs.application.html#bundleID" target="_blank" rel="noopener"><code>bundleID</code></a>方法获得它的<code>bundle ID</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"W"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">local</span> windows = hs.window.allWindows()</span><br><span class="line">      <span class="comment">-- 在Lua中遍历表的方法：https://www.jianshu.com/p/de5a4b132918</span></span><br><span class="line">      <span class="keyword">for</span> _, win <span class="keyword">in</span> <span class="built_in">pairs</span>(windows) <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">local</span> app = win:application()</span><br><span class="line">         <span class="keyword">local</span> bundleID = app:bundleID()</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>现在，只要变量<code>bundleID</code>等于<code>Emacs</code>的<code>bundle ID</code>就可以聚焦到当前遍历的窗口上了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(&#123;<span class="string">"cmd"</span>, <span class="string">"alt"</span>, <span class="string">"ctrl"</span>&#125;, <span class="string">"W"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">local</span> windows = hs.window.allWindows()</span><br><span class="line">      <span class="comment">-- 在Lua中遍历表的方法：https://www.jianshu.com/p/de5a4b132918</span></span><br><span class="line">      <span class="keyword">for</span> _, win <span class="keyword">in</span> <span class="built_in">pairs</span>(windows) <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">local</span> app = win:application()</span><br><span class="line">         <span class="keyword">local</span> bundleID = app:bundleID()</span><br><span class="line">         <span class="keyword">if</span> bundleID == <span class="string">"org.gnu.Emacs"</span> <span class="keyword">then</span></span><br><span class="line">            win:focus()</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><h1 id="让Touch-Bar按钮触发这一切"><a href="#让Touch-Bar按钮触发这一切" class="headerlink" title="让Touch Bar按钮触发这一切"></a>让Touch Bar按钮触发这一切</h1><p>只需要在<code>BetterTouchTools</code>中配置一下即可</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201220/用BTT触发Hammerspoon的快捷键.jpg" alt=""></p><p>这个方法比此前唤起<code>/Applications/Emacs.app</code>的方式更好，因为它只依赖于<code>Emacs</code>逻辑上亘古不变的东西——<code>bundle ID</code>，而不依赖于其物理上的安装位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一箭双雕——org-mode中的ID和CUSTOM_ID字段</title>
    <link href="https://liutos.github.io/2020/11/18/%E4%B8%80%E7%AE%AD%E5%8F%8C%E9%9B%95%E2%80%94%E2%80%94org-mode%E4%B8%AD%E7%9A%84ID%E5%92%8CCUSTOM-ID%E5%AD%97%E6%AE%B5/"/>
    <id>https://liutos.github.io/2020/11/18/一箭双雕——org-mode中的ID和CUSTOM-ID字段/</id>
    <published>2020-11-18T13:44:36.000Z</published>
    <updated>2020-11-19T12:59:04.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><p>在<code>org-mode</code>中，一个条目（entry）可以设置多个属性（<a href="https://orgmode.org/guide/Properties.html" target="_blank" rel="noopener">Properties</a>）。有的属性是<code>org-mode</code>内置的，有它们的特殊用途。有的属性是自定义的，用在一些插件或仅仅用于记录信息。<code>CUSTOM_ID</code>属于前者，而<code>ID</code>属性后者。</p><h1 id="CUSTOM-ID"><a href="#CUSTOM-ID" class="headerlink" title="CUSTOM_ID"></a>CUSTOM_ID</h1><p><code>CUSTOM_ID</code>用于跳转。<code>org-mode</code>支持丰富的<a href="https://orgmode.org/manual/External-Links.html" target="_blank" rel="noopener">外部链接</a>格式，其中之一便是链接到指定<code>.org</code>文件的指定<code>CUSTOM_ID</code>的条目。</p><p>比如在一个<code>.org</code>文件中有<code>file:/Users/liutos/Dropbox/gtd/roles/writer.org::#d1bdc978-a8ce-4266-9ffa-b6041f818431</code>这么一段文本，那么当光标置于这个文本中时，按下快捷键<code>C-c C-o</code>，Emacs便会打开文件<code>/Users/liutos/Dropbox/gtd/roles/writer.org</code>，并将光标对应的条目上。</p><h1 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h1><p><code>ID</code>用于联系两个条目。一个名叫<code>org-edna</code>的第三方插件能够实现两个条目间的依赖，其中一个要素便是条目的<code>ID</code>属性。</p><p>比如我有一个<code>讲解Ada语言</code>的任务（以一个条目的形式存在），同时也有一个<code>学习Ada语言</code>的任务（另一个条目）。显然，必须先学习一番才能讲给他人听，所以第一个条目依赖于第二个条目，于是我先给<code>学习Ada语言</code>的条目设置一个<code>ID</code>属性，值为<code>905fc2f4-4e28-4966-84fa-84c9e6bae96c</code>，然后再为<code>讲解Ada语言</code>的条目中设置一个<code>BLOCKER</code>属性，值为<code>ids(905fc2f4-4e28-4966-84fa-84c9e6bae96c)</code>。如此一来，当<code>讲解Ada语言</code>的条目出现在<code>*Org Agenda*</code>中时，Emacs会将其置灰显示，代表它处于阻塞的状态，必须先处理它的依赖才行。</p><h1 id="自动填充CUSTOM-ID和ID"><a href="#自动填充CUSTOM-ID和ID" class="headerlink" title="自动填充CUSTOM_ID和ID"></a>自动填充CUSTOM_ID和ID</h1><p>建立依赖和跳转都是很常用的功能，因此我会给每一个条目都设置<code>CUSTOM_ID</code>和<code>ID</code>属性。为了免除每次都手动设置的麻烦，我用<code>org-mode</code>的<a href="https://orgmode.org/manual/Capture-templates.html" target="_blank" rel="noopener">capture-template</a>特性来实现自动填充。</p><p>capture-template是<code>org-mode</code>的又一项利器，用于生成条目间共性的内容，比如行首的星号、关键字，以及写入到哪一个文件的哪一个层级中。<code>org-mode</code>的官网便有一个例子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+headline <span class="string">"~/org/gtd.org"</span> <span class="string">"Tasks"</span>)</span><br><span class="line">         <span class="string">"* TODO %?\n  %i\n  %a"</span>)</span><br><span class="line">        (<span class="string">"j"</span> <span class="string">"Journal"</span> entry (file+datetree <span class="string">"~/org/journal.org"</span>)</span><br><span class="line">         <span class="string">"* %?\nEntered on %U\n  %i\n  %a"</span>)))</span><br></pre></td></tr></table></figure><p>在capture-template中除了可以用预置的<a href="https://orgmode.org/manual/Template-expansion.html" target="_blank" rel="noopener">占位符</a>（比如上文的<code>%U</code>、<code>%i</code>，以及<code>%a</code>），还可以调用任意的Elisp函数——这正适合填充<code>ID</code>和<code>CUSTOM_ID</code>这类不重复，并且有一定的格式要求的属性。<code>ID</code>属性的值可以用来自于第三方插件<code>uuidgen</code>的<code>uuidgen-4</code>函数来生成</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+headline <span class="string">"~/org/gtd.org"</span> <span class="string">"Tasks"</span>)</span><br><span class="line">         <span class="string">"* TODO %?  :PROPERTIES:\n  :CUSTOM_ID: %(uuidgen-4)\n  :ID: %(uuidgen-4)\n  :END:"</span>)))</span><br></pre></td></tr></table></figure><p>美中不足的是，<code>CUSTOM_ID</code>和<code>ID</code>的值是不同的，因为<code>uuidgen-4</code>每次都会返回不同的字符串。有没有什么办法能够让它们一样的呢？答案是肯定的。</p><h1 id="一式两份"><a href="#一式两份" class="headerlink" title="一式两份"></a>一式两份</h1><p>既然两次调用<code>uuidgen-4</code>的结果不同，那么就将第一次调用后的结果保存起来，然后重复使用即可。思路很简单，实现代码也很直白</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> (<span class="name">lt-org-capture--uuid</span>)</span><br><span class="line">  (<span class="name">defun</span> lt-org-capture-uuidgen ()</span><br><span class="line">    <span class="string">"生成一个UUID并填充到词法作用域的变量中。"</span></span><br><span class="line">    (<span class="name">setf</span> lt-org-capture--uuid (<span class="name">uuidgen-4</span>))</span><br><span class="line">    lt-org-capture--uuid)</span><br><span class="line">  (<span class="name">defun</span> lt-org-capture-uuidclr ()</span><br><span class="line">    <span class="string">"返回生成好的UUID并清空它。"</span></span><br><span class="line">    lt-org-capture--uuid))</span><br></pre></td></tr></table></figure><p>capture-template也是水到渠成的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+headline <span class="string">"~/org/gtd.org"</span> <span class="string">"Tasks"</span>)</span><br><span class="line">         <span class="string">"* TODO %?  :PROPERTIES:\n  :CUSTOM_ID: %(lt-org-capture-uuidgen)\n  :ID: %(lt-org-capture-uuidclr)\n  :END:"</span>)))</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>在上面的函数定义中，我试图利用词法作用域特性，使得<code>lt-org-capture--uuid</code>只能被<code>lt-org-capture-uuidgen</code>和<code>lt-org-capture-uuidclr</code>读写。遗憾的是，Elisp并不支持词法作用域，<code>lt-org-capture--uuid</code>实际上是一个全局变量——完全可以用<code>C-h v</code>来审视它。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
  </entry>
  
  <entry>
    <title>精确之美——用TikZ画硬盘示意图</title>
    <link href="https://liutos.github.io/2020/10/29/%E7%B2%BE%E7%A1%AE%E4%B9%8B%E7%BE%8E%E2%80%94%E2%80%94%E7%94%A8TikZ%E7%94%BB%E7%A1%AC%E7%9B%98%E7%A4%BA%E6%84%8F%E5%9B%BE/"/>
    <id>https://liutos.github.io/2020/10/29/精确之美——用TikZ画硬盘示意图/</id>
    <published>2020-10-29T05:42:17.000Z</published>
    <updated>2020-10-29T14:07:17.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>备考某等级考试的时候，在教材中碰到了几个一直不太理解的、关于硬盘的概念：磁道、柱面号、扇区。然而教材没有配图，无法直观地了解这些概念的物理形态。维基百科的<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" target="_blank" rel="noopener">硬盘</a>词条页中倒是有一副不错的示意图，我截图搬运了过来</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/维基百科机械硬盘示意图.png" alt="机械硬盘示意图"></p><p>原图是一张SVG图片，本质上是一堆指令——也就是所谓的语绘啦。我是一个语绘爱好者，也想试试看能否用代码画一幅差不多的图出来。</p><p>在旧文<a href="https://liutos.github.io/2020/05/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%89%B9%E6%9C%89%E7%9A%84%E7%94%BB%E5%9B%BE%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E8%AF%AD%E7%BB%98%E5%B7%A5%E5%85%B7%E5%B0%8F%E5%85%A5%E9%97%A8/">《程序员特有的画图方式——语绘工具小入门》</a>中，我演示过几款写代码画图的工具，但它们都不适合用来绘制几何图形，所以这次它们没有用武之地。</p><p>本来我想试试用<a href="https://zh.wikipedia.org/wiki/MetaPost" target="_blank" rel="noopener">MetaPost</a>来画的，但鉴于“入门”了太多次，这次还是换点新花样吧。这一次，我用LaTeX+TikZ来画。</p><h1 id="TikZ是什么及光速入门"><a href="#TikZ是什么及光速入门" class="headerlink" title="TikZ是什么及光速入门"></a>TikZ是什么及光速入门</h1><p>著名的<del>压泡面神器、麻将桌脚垫</del>《TAOCP》的作者发明了<a href="https://zh.wikipedia.org/wiki/TeX" target="_blank" rel="noopener">TeX</a>，知名的<del>Raft竞品</del>Paxos算法的作者在此基础上创造了<a href="https://zh.wikipedia.org/wiki/LaTeX" target="_blank" rel="noopener">LaTeX</a>，它们都是<del>程序员简历</del>论文排版的好帮手。而TikZ则是如虎添翼地在LaTeX中实现了简单易懂的绘图功能的一个<del>红包</del>宏包（macro package，TeX的术语）。简而言之，TikZ自定义了一套“语言”，可以在用LaTeX编写的文档中画出各种图形。</p><p>百闻不如一见，我演示一下如何用TikZ画一条线段、一个圆，以及一段圆弧。先将下列的代码保存到一个文件<code>three_in_one.tex</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;standalone&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes.geometric, arrows&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;[scale=2]</span><br><span class="line">  %% 画一条从原点指向(1, 1)的线段</span><br><span class="line">  \draw (0, 0) -- (1, 1);</span><br><span class="line">  %% 画一个以(1, 1)为圆心，半径为2的圆。</span><br><span class="line">  \draw (1, 1) circle (2);</span><br><span class="line">  %% 画一段以原点为圆心，半径为1，张开角度为30度的圆弧。</span><br><span class="line">  \draw (1, 0) arc (0:30:1);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>再使用<code>xelatex</code>将其编译成PDF文件（<code>xelatex</code>可以通过安装TeXLive 2020获得）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex three_in_one.tex</span><br></pre></td></tr></table></figure><p>此时便得到了<code>three_in_one.pdf</code>文件。为了可以在文章中显示，我用ImageMagick将其转换为PNG文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert three_in_one.pdf /tmp/three_in_one.png</span><br></pre></td></tr></table></figure><p>最终的图片如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/three_in_one.png" alt=""></p><p>简单，就像画一匹马一样简单。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/怎样画马.jpeg" alt=""></p><p>现在该来试试用TikZ复刻维基百科上的硬盘示意图了。</p><h1 id="来点同心圆"><a href="#来点同心圆" class="headerlink" title="来点同心圆"></a>来点同心圆</h1><p>在原图中最引人注目的，当属那十几个同心圆了。简单起见，我只画六个圆。这六个圆的半径相差<code>1pt</code>（<code>pt</code>是TikZ默认的长度单位），从<code>3pt</code>一直递增到<code>8pt</code>，它们的圆心都在坐标原点<code>(0, 0)</code>上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%% 为了节省篇幅，只给出TikZ部分的代码。</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_circle.png" alt=""></p><h1 id="来点等分线"><a href="#来点等分线" class="headerlink" title="来点等分线"></a>来点等分线</h1><p>原图中有12根线段，将每一个圆等分成了全等的12份。从前一节的内容可知，要用<code>\draw</code>命令绘制线段，需要的是线段两端的坐标，那么这批坐标要怎么计算呢？尽管可以用三角函数计算出这些点的笛卡尔坐标，但在TikZ中可以用更方便的极坐标来指定这些点。</p><p>以原图中从X轴开始逆时针旋转遇到的第一条线段为例，它在半径为<code>3pt</code>的圆上的点的坐标为<code>(30:3)</code>（30是极坐标中的角度，3是半径长度），而在半径为<code>8pt</code>的圆上的点的坐标为<code>(30:8)</code>，因此可以用<code>\draw (30:3) -- (30:8)</code>来画出这根线段。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_30.png" alt=""></p><p>通过调整其中的角度可以画出剩余的其它线段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line"></span><br><span class="line">  \draw (0:3) -- (0:8);</span><br><span class="line">  \draw (30:3) -- (30:8);</span><br><span class="line">  \draw (60:3) -- (60:8);</span><br><span class="line">  \draw (90:3) -- (90:8);</span><br><span class="line">  \draw (120:3) -- (120:8);</span><br><span class="line">  \draw (150:3) -- (150:8);</span><br><span class="line">  \draw (180:3) -- (180:8);</span><br><span class="line">  \draw (210:3) -- (210:8);</span><br><span class="line">  \draw (240:3) -- (240:8);</span><br><span class="line">  \draw (270:3) -- (270:8);</span><br><span class="line">  \draw (300:3) -- (300:8);</span><br><span class="line">  \draw (330:3) -- (330:8);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_split.png" alt=""></p><h1 id="来张色图"><a href="#来张色图" class="headerlink" title="来张色图"></a>来张色图</h1><p>原图大致的骨架已经画完了，现在来尝试给它上色。在TikZ中，可以用<code>\fill</code>命令给一段封闭的曲线上色。比如用<code>\fill[red] (0, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- cycle</code>可以将左下角在原点、边长为<code>1pt</code>的正方形涂成红色。</p><p>先给原图中的区域B上色。区域B是一个扇形，它由两根长度为<code>8pt</code>的半径和一段夹角为30度的圆弧构成。要描述这段封闭曲线，可以借助入门一节中介绍的<code>arc</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  %% 给区域B上色。</span><br><span class="line">  \fill[blue] (0, 0) -- (30:8) arc (30:60:8) -- cycle;</span><br><span class="line"></span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line"></span><br><span class="line">  \draw (0:3) -- (0:8);</span><br><span class="line">  \draw (30:3) -- (30:8);</span><br><span class="line">  \draw (60:3) -- (60:8);</span><br><span class="line">  \draw (90:3) -- (90:8);</span><br><span class="line">  \draw (120:3) -- (120:8);</span><br><span class="line">  \draw (150:3) -- (150:8);</span><br><span class="line">  \draw (180:3) -- (180:8);</span><br><span class="line">  \draw (210:3) -- (210:8);</span><br><span class="line">  \draw (240:3) -- (240:8);</span><br><span class="line">  \draw (270:3) -- (270:8);</span><br><span class="line">  \draw (300:3) -- (300:8);</span><br><span class="line">  \draw (330:3) -- (330:8);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_B.png" alt=""></p><p><code>\fill</code>命令那一行最后的<code>cycle</code>的意思，是让曲线回到起点组成一个封闭的形状。另外，<code>\fill</code>命令需要写在<code>\draw</code>命令之前，是为了避免蓝色颜料将区域内的圆弧给盖住了。</p><p>对于区域C和区域D，方法是一样的，只是描述封闭曲线的坐标不同罢了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  %% 给区域B上色。</span><br><span class="line">  \fill[blue] (0, 0) -- (30:8) arc (30:60:8) -- cycle;</span><br><span class="line">  %% 给区域C上色。</span><br><span class="line">  \fill[purple] (30:4) -- (30:5) arc (30:60:5) -- (60:4) -- (60:4) arc (60:30:4);</span><br><span class="line">  %% 给区域D上色。</span><br><span class="line">  \fill[green] (240:6) -- (240:7) arc (240:330:7) -- (330:6) -- (330:6) arc (330:240:6);</span><br><span class="line"></span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line"></span><br><span class="line">  \draw (0:3) -- (0:8);</span><br><span class="line">  \draw (30:3) -- (30:8);</span><br><span class="line">  \draw (60:3) -- (60:8);</span><br><span class="line">  \draw (90:3) -- (90:8);</span><br><span class="line">  \draw (120:3) -- (120:8);</span><br><span class="line">  \draw (150:3) -- (150:8);</span><br><span class="line">  \draw (180:3) -- (180:8);</span><br><span class="line">  \draw (210:3) -- (210:8);</span><br><span class="line">  \draw (240:3) -- (240:8);</span><br><span class="line">  \draw (270:3) -- (270:8);</span><br><span class="line">  \draw (300:3) -- (300:8);</span><br><span class="line">  \draw (330:3) -- (330:8);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_CD.png" alt=""></p><h1 id="给环形上色"><a href="#给环形上色" class="headerlink" title="给环形上色"></a>给环形上色</h1><p>聪明的读者也许已经发现了，区域A的环形没办法用这种方式来描述。不过没关系，只要将其视为上下半两部分，再分别上色即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  %% 环的上半部分</span><br><span class="line">  \fill[red] (4, 0) -- (5, 0) arc (0:180:5) -- (-4, 0) -- (-4, 0) arc (180:0:4);</span><br><span class="line">  %% 环的下半部分</span><br><span class="line">  \fill[red] (4, 0) -- (5, 0) arc (360:180:5) -- (-4, 0) -- (-4, 0) arc (180:360:4);</span><br><span class="line">  %% 给区域B上色。</span><br><span class="line">  \fill[blue] (0, 0) -- (30:8) arc (30:60:8) -- cycle;</span><br><span class="line">  %% 给区域C上色。</span><br><span class="line">  \fill[purple] (30:4) -- (30:5) arc (30:60:5) -- (60:4) -- (60:4) arc (60:30:4);</span><br><span class="line">  %% 给区域D上色。</span><br><span class="line">  \fill[green] (240:6) -- (240:7) arc (240:330:7) -- (330:6) -- (330:6) arc (330:240:6);</span><br><span class="line"></span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line"></span><br><span class="line">  \draw (0:3) -- (0:8);</span><br><span class="line">  \draw (30:3) -- (30:8);</span><br><span class="line">  \draw (60:3) -- (60:8);</span><br><span class="line">  \draw (90:3) -- (90:8);</span><br><span class="line">  \draw (120:3) -- (120:8);</span><br><span class="line">  \draw (150:3) -- (150:8);</span><br><span class="line">  \draw (180:3) -- (180:8);</span><br><span class="line">  \draw (210:3) -- (210:8);</span><br><span class="line">  \draw (240:3) -- (240:8);</span><br><span class="line">  \draw (270:3) -- (270:8);</span><br><span class="line">  \draw (300:3) -- (300:8);</span><br><span class="line">  \draw (330:3) -- (330:8);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_ring.png" alt=""></p><h1 id="润色一下"><a href="#润色一下" class="headerlink" title="润色一下"></a>润色一下</h1><p>用macOS的“数码测色计”看了一下原图中各个区域的颜色的RGB值，区域A大概是<code>(236, 133, 130)</code>、区域B大概是<code>(122, 127, 237)</code>、区域C大概是<code>(131, 132, 139)</code>、区域D大概是<code>(0, 151, 27)</code>。接下来我让TikZ以这四种指定的颜色填充图中的四个区域，先用LaTeX的<code>\definecolor</code>命令定义四个新的颜色的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%% 下列四行代码置于document环境之前</span><br><span class="line">\definecolor&#123;areaA&#125;&#123;RGB&#125;&#123;236,133,130&#125;</span><br><span class="line">\definecolor&#123;areaB&#125;&#123;RGB&#125;&#123;122,127,237&#125;</span><br><span class="line">\definecolor&#123;areaC&#125;&#123;RGB&#125;&#123;131,32,139&#125;</span><br><span class="line">\definecolor&#123;areaD&#125;&#123;RGB&#125;&#123;0,151,27&#125;</span><br></pre></td></tr></table></figure><p>再替换掉<code>\fill</code>命令中的颜色名即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  %% 环的上半部分</span><br><span class="line">  \fill[areaA] (4, 0) -- (5, 0) arc (0:180:5) -- (-4, 0) -- (-4, 0) arc (180:0:4);</span><br><span class="line">  %% 环的下半部分</span><br><span class="line">  \fill[areaA] (4, 0) -- (5, 0) arc (360:180:5) -- (-4, 0) -- (-4, 0) arc (180:360:4);</span><br><span class="line">  %% 给区域B上色。</span><br><span class="line">  \fill[areaB] (0, 0) -- (30:8) arc (30:60:8) -- cycle;</span><br><span class="line">  %% 给区域C上色。</span><br><span class="line">  \fill[areaC] (30:4) -- (30:5) arc (30:60:5) -- (60:4) -- (60:4) arc (60:30:4);</span><br><span class="line">  %% 给区域D上色。</span><br><span class="line">  \fill[areaD] (240:6) -- (240:7) arc (240:330:7) -- (330:6) -- (330:6) arc (330:240:6);</span><br><span class="line"></span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line"></span><br><span class="line">  \draw (0:3) -- (0:8);</span><br><span class="line">  \draw (30:3) -- (30:8);</span><br><span class="line">  \draw (60:3) -- (60:8);</span><br><span class="line">  \draw (90:3) -- (90:8);</span><br><span class="line">  \draw (120:3) -- (120:8);</span><br><span class="line">  \draw (150:3) -- (150:8);</span><br><span class="line">  \draw (180:3) -- (180:8);</span><br><span class="line">  \draw (210:3) -- (210:8);</span><br><span class="line">  \draw (240:3) -- (240:8);</span><br><span class="line">  \draw (270:3) -- (270:8);</span><br><span class="line">  \draw (300:3) -- (300:8);</span><br><span class="line">  \draw (330:3) -- (330:8);</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_color.png" alt=""></p><h1 id="图文并茂"><a href="#图文并茂" class="headerlink" title="图文并茂"></a>图文并茂</h1><p>剩下的需要复刻的东西就是原图中的文字以及标注用的线了。线很容易画，只要规定了坐标后用<code>\draw</code>命令即可。比如说，我可以把四条线定义如下，其中的坐标和线段的长度纯粹是个人偏好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\draw (75:4.5) -- (75:9);</span><br><span class="line">\draw (40:7.5) -- (40:9);</span><br><span class="line">\draw (50:4.5) -- (50:9);</span><br><span class="line">\draw (285:6.5) -- (285:9);</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_line.png" alt=""></p><p>线画完了，再到每一根线的“终点”标上文字说明，这需要用到TikZ的<code>node</code>功能。用法很简单，就是在需要标注文字的坐标后，紧跟着关键字<code>node</code>，以及一段用花括号包裹的文本即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;standalone&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;xeCJK&#125;</span><br><span class="line">\setCJKmainfont&#123;Songti TC&#125;</span><br><span class="line">\usetikzlibrary&#123;shapes.geometric, arrows&#125;</span><br><span class="line">\definecolor&#123;areaA&#125;&#123;RGB&#125;&#123;236,133,130&#125;</span><br><span class="line">\definecolor&#123;areaB&#125;&#123;RGB&#125;&#123;122,127,237&#125;</span><br><span class="line">\definecolor&#123;areaC&#125;&#123;RGB&#125;&#123;131,32,139&#125;</span><br><span class="line">\definecolor&#123;areaD&#125;&#123;RGB&#125;&#123;0,151,27&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;tikzpicture&#125;</span><br><span class="line">  %% 环的上半部分</span><br><span class="line">  \fill[areaA] (4, 0) -- (5, 0) arc (0:180:5) -- (-4, 0) -- (-4, 0) arc (180:0:4);</span><br><span class="line">  %% 环的下半部分</span><br><span class="line">  \fill[areaA] (4, 0) -- (5, 0) arc (360:180:5) -- (-4, 0) -- (-4, 0) arc (180:360:4);</span><br><span class="line">  %% 给区域B上色。</span><br><span class="line">  \fill[areaB] (0, 0) -- (30:8) arc (30:60:8) -- cycle;</span><br><span class="line">  %% 给区域C上色。</span><br><span class="line">  \fill[areaC] (30:4) -- (30:5) arc (30:60:5) -- (60:4) -- (60:4) arc (60:30:4);</span><br><span class="line">  %% 给区域D上色。</span><br><span class="line">  \fill[areaD] (240:6) -- (240:7) arc (240:330:7) -- (330:6) -- (330:6) arc (330:240:6);</span><br><span class="line"></span><br><span class="line">  \draw (0, 0) circle (3);</span><br><span class="line">  \draw (0, 0) circle (4);</span><br><span class="line">  \draw (0, 0) circle (5);</span><br><span class="line">  \draw (0, 0) circle (6);</span><br><span class="line">  \draw (0, 0) circle (7);</span><br><span class="line">  \draw (0, 0) circle (8);</span><br><span class="line"></span><br><span class="line">  \draw (0:3) -- (0:8);</span><br><span class="line">  \draw (30:3) -- (30:8);</span><br><span class="line">  \draw (60:3) -- (60:8);</span><br><span class="line">  \draw (90:3) -- (90:8);</span><br><span class="line">  \draw (120:3) -- (120:8);</span><br><span class="line">  \draw (150:3) -- (150:8);</span><br><span class="line">  \draw (180:3) -- (180:8);</span><br><span class="line">  \draw (210:3) -- (210:8);</span><br><span class="line">  \draw (240:3) -- (240:8);</span><br><span class="line">  \draw (270:3) -- (270:8);</span><br><span class="line">  \draw (300:3) -- (300:8);</span><br><span class="line">  \draw (330:3) -- (330:8);</span><br><span class="line"></span><br><span class="line">  \draw (75:4.5) -- (75:9) node &#123;磁道&#125;;</span><br><span class="line">  \draw (40:7.5) -- (40:9) node &#123;扇面&#125;;</span><br><span class="line">  \draw (50:4.5) -- (50:9) node &#123;扇区&#125;;</span><br><span class="line">  \draw (285:6.5) -- (285:9) node &#123;簇&#125;;</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201029/hdd2_text.png" alt=""></p><p>需要留意的是，我在源代码开头的位置，引入了<code>xeCJK</code>宏包（<code>\usepackage{xeCJK}</code>），并且指定了中文内容用的字体为宋体（<code>\setCJKmainfont{Songti TC}</code>），这样才能成功编译。</p><p>至此，复刻算是完成了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本文只是管中窥豹，TikZ还可以画出其它更复杂更美轮美奂的图形，有兴趣的读者可以移步<a href="https://texample.net/tikz/examples/" target="_blank" rel="noopener">这里</a>观赏。此外，TikZ也可以“编程”，比如下面的两行代码便足矣画出上文中12行代码才完成的等分线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\foreach \x in &#123;0,30,60,90,120,150,180,210,240,270,300,330&#125;</span><br><span class="line">\draw (\x:3) -- (\x:8);</span><br></pre></td></tr></table></figure><p>TikZ的更多潜力和乐趣，就由各位读者自己探索吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="工具" scheme="https://liutos.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="语绘" scheme="https://liutos.github.io/tags/%E8%AF%AD%E7%BB%98/"/>
    
      <category term="latex" scheme="https://liutos.github.io/tags/latex/"/>
    
      <category term="tikz" scheme="https://liutos.github.io/tags/tikz/"/>
    
      <category term="绘图" scheme="https://liutos.github.io/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Emacs的avy插件</title>
    <link href="https://liutos.github.io/2020/10/11/Emacs%E7%9A%84avy%E6%8F%92%E4%BB%B6/"/>
    <id>https://liutos.github.io/2020/10/11/Emacs的avy插件/</id>
    <published>2020-10-11T02:07:27.000Z</published>
    <updated>2020-10-11T02:56:12.431Z</updated>
    
    <content type="html"><![CDATA[<p>用Emacs的时候，我习惯将它分成“四个部分”</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201011/Emacs分成四部分.jpg" alt=""></p><p>怎么弄的呢？一般是先按<code>C-x 3</code>分出左右两个window，再到各个window中用<code>C-x 2</code>分出上下两个window——这不是我的笔误，在Emacs的术语中，用来显示一个buffer的区域就叫做一个<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Windows.html" target="_blank" rel="noopener">window</a>。而常常被人们冠名为window的、最外层的窗体，则叫做<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html#Frames" target="_blank" rel="noopener">frame</a>。</p><p>这样划分后，多次按下<code>C-Tab</code>（我把这个快捷键绑定到了命令<code>other-window</code>上），便可以按照左上、左下、右上、右下的顺序轮换当前聚焦的window了。</p><p>如果需要从其它window中复制内容到当前window中粘贴，操作会麻烦一点。以右上角需要左下角的内容为例：</p><ol><li>按三次<code>C-Tab</code>换到左下角的window中——用快捷键是因为我不想去挪鼠标；</li><li>按<code>k</code>或<code>j</code>上下移动光标到目标行——用<code>k</code>和<code>j</code>是因为用了<code>evil-mode</code>插件（参见<a href="https://liutos.github.io/2020/09/28/%E6%89%8B%E6%8C%87%E7%96%BC%EF%BC%8C%E5%86%99%E7%82%B9%E4%BB%A3%E7%A0%81%E7%BC%93%E8%A7%A3%E4%B8%80%E4%B8%8B/">这篇文章</a>）；</li><li>复制内容，再按一次<code>C-Tab</code>回到原来的window中粘贴。</li></ol><p>听起来可麻烦了。</p><p>好在Emacs有一个非常好用的插件，可以把第1和第2个步骤合在一起完成。</p><h1 id="avy"><a href="#avy" class="headerlink" title="avy"></a>avy</h1><p>这个非常好用的插件就是<a href="https://github.com/abo-abo/avy" target="_blank" rel="noopener">avy</a>，它提供的<code>avy-goto-line</code>函数可以一步到位地完成上面的第1和第2个步骤。</p><p>用Emacs的包管理器就可以安装它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x package-install RET avy RET</span><br></pre></td></tr></table></figure><p>接着要为命令<code>avy-goto-line</code>绑定一个喜欢的快捷键</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"M-g f"</span>) 'avy-goto-line)</span><br></pre></td></tr></table></figure><p>至此便可以在Emacs中愉快地使用<code>M-g f</code>来快速跳转到当前或其它window中的行了。百闻不如一见，我来演示一番。</p><h1 id="avy-goto-line"><a href="#avy-goto-line" class="headerlink" title="avy-goto-line"></a>avy-goto-line</h1><p><del>众所周知，</del>我用org-mode来跟踪自己的学习计划，还会将摸索过程中的一些半成品代码保存到org-mode的条目中。例如，我想要将左下角的window中的三个函数的定义，复制到右上角的代码块中去</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201011/移动前的景象.jpg" alt=""></p><p>于是我先按下<code>M-g f</code>，让<code>avy</code>为每一行赋予一个标记</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201011/按下快捷键之后的景象.jpg" alt=""></p><p>因为希望切换到左下角的window的第一行，所以我先按下<code>j</code></p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201011/按下字母j之后的景象.jpg" alt=""></p><p>此时，在前一幅截图中不以字母<code>j</code>开始的标记统统消失了，而以字母<code>j</code>开始的标记则只留下了从第二个字符开始的部分。</p><p>再按下字母<code>l</code>，就可以将焦点切换到左下角的window，并且将光标移动到第一行的行首了。然后只需要选中内容、复制，并返回原来的window中粘贴即可。完整的过程如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20201011/使用avy-goto-line的全过程.gif" alt=""></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果在按下组合键<code>M-g f</code>后，接着按下的是数字键的话，<code>avy-goto-line</code>会认为使用者打算跳转到指定的行。它将在Emacs的minibuffer中继续等待输入更多的数字或按下回车。不过我不怎么用这个功能，因为我没有让Emacs显示行号，按行号来跳转对我并不方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="editor" scheme="https://liutos.github.io/tags/editor/"/>
    
      <category term="编辑器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="效率" scheme="https://liutos.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>手指疼，写点代码缓解一下</title>
    <link href="https://liutos.github.io/2020/09/28/%E6%89%8B%E6%8C%87%E7%96%BC%EF%BC%8C%E5%86%99%E7%82%B9%E4%BB%A3%E7%A0%81%E7%BC%93%E8%A7%A3%E4%B8%80%E4%B8%8B/"/>
    <id>https://liutos.github.io/2020/09/28/手指疼，写点代码缓解一下/</id>
    <published>2020-09-28T14:29:09.000Z</published>
    <updated>2020-09-28T14:39:01.897Z</updated>
    
    <content type="html"><![CDATA[<p>我经常使用Emacs来干写字的活——有时候是写代码、有时候是用org-mode管理待办事项、有时候是用restclient-mode来测试HTTP API。Emacs丰富的快捷键让我可以双手不离主键盘区就做到很多事情，不过这也带来了别样的烦恼：快捷键按多了，手容易累。</p><p>导致手累的第一个因素，是Emacs的不少快捷键需要按住<code>ctrl</code>来使用，而<code>ctrl</code>常常不容易按到。以我的键盘为例，<code>ctrl</code>键分布在主键盘区的最外侧</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200928/我所用的美式键盘举例.jpeg" alt=""></p><p>为了便于尾指按到两侧的<code>ctrl</code>键，我在macOS中交换了<code>command</code>和<code>control</code>键的效果</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200928/交换了command和control.jpg" alt=""></p><p>当需要按住两边的<code>ctrl</code>键（实际按下的是上面照片中的Windows图标键）时，手腕需要往外拐过去。这个问题在使用VSCode时同样存在，因为我在VSCode中用的也是Emacs的键映射。</p><p>第二个因素是Emacs的一些快捷键太繁琐，导致使用时双手像在键盘上起舞一般到处按来按去，敲击次数过多。例如，让光标上下左右移动的快捷键分别是<code>ctrl-p</code>、<code>ctrl-n</code>、<code>ctrl-b</code>，以及<code>ctrl-f</code>，这比直接用键盘上的方向键麻烦得多。有一些功能甚至要按三组快捷键，比如<code>org-clock-out</code>要先按<code>ctrl-c</code>，再按<code>ctrl-x</code>，最后按<code>ctrl-o</code>。</p><p>有没有办法既可以保留快捷键的高效，又尽量地减少击键导致的手腕和手指的疲劳呢？</p><p>当然有。</p><h1 id="在Emacs中改用Vim的快捷键"><a href="#在Emacs中改用Vim的快捷键" class="headerlink" title="在Emacs中改用Vim的快捷键"></a>在Emacs中改用Vim的快捷键</h1><p>既然Emacs默认的快捷键不容易按，那么不妨换成Vim风格的快捷键。同样是上下左右移动光标，在Vim中只需要单击<code>k/j/h/l</code>这四个按键即可，不仅能够单手操作，而且这四个键正好是右手”触手可及“的位置。其它的功能，例如在文件内搜索、保存文件等，也只需要按<code>/</code>和<code>:w</code>即可，比起Emacs真是”finger-friendly“得多了。</p><p>那么如何才能在Emacs中用上Vim的快捷键呢？答案是用<code>evil</code>插件。先用包管理器安装它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x package-install RET evil RET</span><br></pre></td></tr></table></figure><p>然后在Emacs的启动配置文件中添加启用<code>evil-mode</code>的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">require</span> 'evil)</span><br><span class="line">(<span class="name">evil-mode</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>现在便可以在Emacs中使用Vim风格的快捷键了</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200928/在Emacs中用Vim快捷键.gif" alt=""></p><h1 id="定制evil-mode"><a href="#定制evil-mode" class="headerlink" title="定制evil-mode"></a>定制<code>evil-mode</code></h1><p>只是简单地启用<code>evil-mode</code>还不足以将双手从频繁的按<code>ctrl</code>中解放出来，因为在Emacs中还有不少其它的高频快捷键依赖于<code>ctrl</code>，例如用<code>ctrl-x b</code>来切换到其它的buffer中、用<code>ctrl-x ctrl-f</code>来打开或新建一个文件，甚至是用<code>ctrl-c ctrl-x ctrl-o</code>来停止一个任务的计时器。</p><p>就像在数据压缩中，用较短的串来代替出现频率较高的原始字符串一样，对于高频使用且快捷键较长的功能，可以为它们绑定较短的快捷键。在<code>evil-mode</code>中，<code>g</code>是一个前缀键并且也很好按，所以我把一些重度使用的功能都绑定了在了以它为前缀的快捷键上</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; evil-mode相关的键绑定</span></span><br><span class="line">(<span class="name">evil-global-set-key</span> 'normal (<span class="name">kbd</span> <span class="string">"g b"</span>) 'ido-switch-buffer)</span><br><span class="line">(<span class="name">evil-global-set-key</span> 'normal (<span class="name">kbd</span> <span class="string">"g f"</span>) 'ido-find-file)</span><br><span class="line">(<span class="name">evil-global-set-key</span> 'normal (<span class="name">kbd</span> <span class="string">"g o"</span>) 'org-clock-out)</span><br><span class="line">(<span class="name">evil-global-set-key</span> 'normal (<span class="name">kbd</span> <span class="string">"g s"</span>) 'cuckoo-org-schedule)</span><br><span class="line">(<span class="name">evil-global-set-key</span> 'normal (<span class="name">kbd</span> <span class="string">"g t"</span>) 'org-todo)</span><br><span class="line">(<span class="name">evil-global-set-key</span> 'normal (<span class="name">kbd</span> <span class="string">"s"</span>) 'save-buffer)</span><br></pre></td></tr></table></figure><h1 id="在VSCode中改用Vim的快捷键"><a href="#在VSCode中改用Vim的快捷键" class="headerlink" title="在VSCode中改用Vim的快捷键"></a>在VSCode中改用Vim的快捷键</h1><p>搬砖的工具是VSCode，用来写Node.js的项目，主要是因VSCode在写Node.js代码这方面确实比Emacs的<code>js-mode</code>、<code>js2-mode</code>，以及<code>tide-mode</code>之流要好用那么一点。在VSCode中我也改用了Vim的键映射，只需要在插件市场中点击安装即可</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200928/VSCode自带的键映射.jpg" alt=""></p><p>VSCode的Vim键映射实际上是一个独立的插件<a href="https://github.com/VSCodeVim/Vim" target="_blank" rel="noopener">Vim</a>，它也支持进一步地自定义快捷键。出于个人喜好，我把<code>s</code>绑定为保存文件的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSCode的配置文件setting.json</span></span><br><span class="line"><span class="string">"vim.normalModeKeyBindings"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"before"</span>: [<span class="string">"s"</span>],</span><br><span class="line">    <span class="string">"commands"</span>: [</span><br><span class="line">      <span class="string">"workbench.action.files.save"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h1 id="用BetterTouchTools补充evil-mode的不足"><a href="#用BetterTouchTools补充evil-mode的不足" class="headerlink" title="用BetterTouchTools补充evil-mode的不足"></a>用BetterTouchTools补充evil-mode的不足</h1><p>尽管在Emacs中可以将常用的功能绑定到一系列的、以<code>g</code>开头的较短的快捷键上，但这一招并不能用来处理所有的快捷键，因为太多的自定义快捷键也会带来记忆上的负担。但我不会就此止步。</p><p>仔细观察就会发现，多数较长的快捷键是以<code>ctrl-c</code>或<code>ctrl-x</code>作为前缀的。因此，如果能够让<code>ctrl-c</code>和<code>ctrl-x</code>更容易按——比如替换为单个按键，也有利于减少尾指按<code>ctrl</code>键的负担。</p><p>要用单键来代替<code>ctrl-c</code>，光凭Emacs其实也可以做到。比如可以让<code>F10</code>被按下的时候相当于按下<code>ctrl-c</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> simulate-C-c ()</span><br><span class="line">  <span class="string">"模拟输入C-c"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">setq</span> unread-command-events (<span class="name">listify-key-sequence</span> <span class="string">"\C-c"</span>)))</span><br><span class="line">(<span class="name">global-set-key</span> [f10] 'simulate-C-c)</span><br></pre></td></tr></table></figure><p>问题在于它不可组合。</p><p>例如，先按<code>F10</code>再按<code>ctrl-x</code>，等价于按下<code>ctrl-c ctrl-x</code>。但如果先按<code>ctrl-x</code>再按<code>F10</code>，则Emacs不会再将<code>F10</code>转换为<code>ctrl-c</code>，它只会认为我按下的是<code>ctrl-x F10</code>的键序列。</p><p>既要用<code>F10</code>代替<code>ctrl-c</code>，又要具备可组合性，怎么办？我的答案是使用<a href="https://folivora.ai/" target="_blank" rel="noopener">BetterTouchTool</a>。我用BTT将<code>F9</code>到<code>F12</code>都重定义了一遍</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200928/用BTT重定义Fn键.jpg" alt=""></p><p>如此一来，当我需要输入复杂的、含有<code>ctrl-c</code>或<code>ctrl-x</code>的快捷键的时候，只需要单击一次<code>F10</code>或<code>F11</code>就足够了，轻而易举！</p><p>遗憾的是，BTT是一款macOS only的软件。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>或许脑机接口才是缓解手指劳损的终极解决方案吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="editor" scheme="https://liutos.github.io/tags/editor/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="vscode" scheme="https://liutos.github.io/tags/vscode/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="tool" scheme="https://liutos.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>那么，Prolog，告诉我怎么走</title>
    <link href="https://liutos.github.io/2020/09/09/%E9%82%A3%E4%B9%88%EF%BC%8CProlog%EF%BC%8C%E5%91%8A%E8%AF%89%E6%88%91%E6%80%8E%E4%B9%88%E8%B5%B0/"/>
    <id>https://liutos.github.io/2020/09/09/那么，Prolog，告诉我怎么走/</id>
    <published>2020-09-09T13:42:32.000Z</published>
    <updated>2020-09-09T13:56:51.995Z</updated>
    
    <content type="html"><![CDATA[<p>今年四月左右，我心血来潮地为自己立了一个学习Prolog的目标——对，就是那门以逻辑编程和人工智能为卖点的语言。不仅要学会它的基本用法，还妄想用它像朋友圈广告里的Python那样，用来处理Excel文件中的大数据！</p><p>尽管处理大数据是开个玩笑，但学习Prolog的目标是真的。既然要学习一门编程语言，就必须找一本靠谱的教材。在无中生友之后，我选择了<del>由谭浩强老先生主编的</del><a href="http://www.learnprolognow.org/lpnpage.php?pageid=online" target="_blank" rel="noopener">《Learn Prolog Now》</a>作为入门读物。</p><p>尽管《Learn Prolog Now》的内容一点也不real world，却循序渐进、非常地适合初学者，每一章的结尾还准备了“上机题”。出人意料的是，仅仅在第三章就遇到了不会做的题目。在焦急地苦战一番未果后，我拖着疲惫的身躯搁置了它，继续学习后面的章节。</p><p>时隔五个月，我再次尝试解答这道题目。却惊喜地发现，只需要冷静地分析再仔细运用前三章学过的知识，解决这道题目也就是水到渠成的事情了。</p><h1 id="所以到底是个什么题？"><a href="#所以到底是个什么题？" class="headerlink" title="所以到底是个什么题？"></a>所以到底是个什么题？</h1><p>讲了这么多，是时候揭晓这它的真面目了。由于第三题以第二题为基础，因此一并搬运了过来</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200909/第二第三题的描述.jpg" alt=""></p><p>感兴趣的朋友也可以直接移步<a href="http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse12#x25-38066x2" target="_blank" rel="noopener">源网页</a>查看。</p><p>看完上面的题目，只学过主流编程语言的朋友大概会是一头雾水，毕竟无论是代码还是术语，都与平日里使用的大相径庭。我来试着解释一下。像<code>byCar(auckland, hamilton)</code>和<code>byTrain(metz, frankfurt)</code>这样的代码，用Prolog的术语来讲叫做“事实”。就像数学中的公理一样，它们总是成立的。如果向Prolog提问，它会给出肯定的回答</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200909/向Prolog查询事实.jpg" alt=""></p><p><code>byCar</code>和<code>byTrain</code>被称为“谓词”，<code>auckland</code>和<code>hamilton</code>则是“原子”。</p><p>第二题要求定义<code>travel/2</code>，第三题要求定义<code>travel/3</code>。<code>travel</code>是谓词的名字，2和3则是它所接受的参数的个数。定义一个谓词就是给出描述它何时成立的“规则”，举个例子，可以定义一个名为<code>len</code>的谓词，只有当第二个参数等于第一个参数的长度时才成立</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200909/定义计算长度的谓词的例子.jpg" alt=""></p><p>以大写字母开头的标识符（如题目中的<code>X</code>，上图中的<code>T</code>、<code>L</code>）是变量，在归一化（unification）时Prolog能够为它们赋值使得查询成立。</p><p>鉴于本文不是Prolog的入门教程，各位读者如果想进一步了解Prolog，还请移步《Learn Prolog Now》的相关章节。</p><h1 id="先解决第二题吧"><a href="#先解决第二题吧" class="headerlink" title="先解决第二题吧"></a>先解决第二题吧</h1><p>讲了这么多，该进入正题了。第二题其实不难，细心的读者应该已经发现，这题可以用递归来解决（就像上文的<code>len</code>一样）。</p><p>设谓词<code>travel</code>的两个参数分别叫做<code>S</code>和<code>E</code>，各代表起点和终点。显然，<code>travel(S, E)</code>成立，当且仅当：</p><ol><li>可以从<code>S</code>搭乘汽车（<code>byCar</code>）、火车（<code>byTrain</code>），或飞机（<code>byPlane</code>）抵达<code>E</code>，或者；</li><li>存在另一个城市<code>M</code>，可以从<code>S</code>搭乘汽车、火车，或飞机抵达<code>M</code>，并且<code>travel(M, E)</code>也成立。</li></ol><p>上述算法可以轻松地写成Prolog代码</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">byCar(auckland,hamilton).</span><br><span class="line">byCar(hamilton,raglan).</span><br><span class="line">byCar(valmont,saarbruecken).</span><br><span class="line">byCar(valmont,metz).</span><br><span class="line"></span><br><span class="line">byTrain(metz,frankfurt).</span><br><span class="line">byTrain(saarbruecken,frankfurt).</span><br><span class="line">byTrain(metz,paris).</span><br><span class="line">byTrain(saarbruecken,paris).</span><br><span class="line"></span><br><span class="line">byPlane(frankfurt,bangkok).</span><br><span class="line">byPlane(frankfurt,singapore).</span><br><span class="line">byPlane(paris,losAngeles).</span><br><span class="line">byPlane(bangkok,auckland).</span><br><span class="line">byPlane(singapore,auckland).</span><br><span class="line">byPlane(losAngeles,auckland).</span><br><span class="line"></span><br><span class="line">travel(<span class="symbol">S</span>, <span class="symbol">E</span>) :- just_go(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br><span class="line">travel(<span class="symbol">S</span>, <span class="symbol">E</span>) :- just_go(<span class="symbol">S</span>, <span class="symbol">M</span>), travel(<span class="symbol">M</span>, <span class="symbol">E</span>).</span><br><span class="line"></span><br><span class="line">just_go(<span class="symbol">S</span>, <span class="symbol">E</span>) :- byCar(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br><span class="line">just_go(<span class="symbol">S</span>, <span class="symbol">E</span>) :- byTrain(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br><span class="line">just_go(<span class="symbol">S</span>, <span class="symbol">E</span>) :- byPlane(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br></pre></td></tr></table></figure><p>让Prolog告诉咱们这个<code>travel/2</code>写得对不对</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200909/travel2效果演示.jpg" alt=""></p><p>精彩！</p><h1 id="你话我猜？"><a href="#你话我猜？" class="headerlink" title="你话我猜？"></a>你话我猜？</h1><p>Prolog不仅知道一个查询是否成立，还知道这个查询在什么参数下成立。例如，可以让Prolog告诉咱们，从<code>valmont</code>可以抵达哪一些城市，以及哪一些城市可以抵达<code>auckland</code></p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200909/让Prolog回答起点和终点.jpg" alt=""></p><p>这正是在接下来的题目中需要发扬光大的能力。</p><h1 id="终于来到第三题"><a href="#终于来到第三题" class="headerlink" title="终于来到第三题"></a>终于来到第三题</h1><p>第三题所要求的<code>travel</code>是一个接受三个参数的谓词，第三个参数由从起点到终点的途径城市构成。设这个新的变量为<code>R</code>，那么<code>travel(S, E, R)</code>成立当且仅当：</p><ol><li>可以从<code>S</code>抵达<code>E</code>，并且<code>R</code>为<code>go(S, E)</code>，或者；</li><li>存在另一个城市<code>M</code>，以及另一条路径<code>R2</code>。可以从<code>S</code>抵达<code>M</code>，并且<code>travel(M, E, R2)</code>成立，并且<code>R</code>为<code>go(S, M, R2)</code>。</li></ol><p>那么如何在规则中描述<code>R</code>的结构呢？莫非是像上面的谓词<code>len</code>那样，在<code>:-</code>的右侧写上形如<code>R is go(S, M, R2)</code>这样的代码？</p><p>并不是。</p><p>借助Prolog强大的模式匹配能力，只需要在<code>:-</code>的左边声明<code>R</code>的结构即可</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">byCar(auckland,hamilton).</span><br><span class="line">byCar(hamilton,raglan).</span><br><span class="line">byCar(valmont,saarbruecken).</span><br><span class="line">byCar(valmont,metz).</span><br><span class="line"></span><br><span class="line">byTrain(metz,frankfurt).</span><br><span class="line">byTrain(saarbruecken,frankfurt).</span><br><span class="line">byTrain(metz,paris).</span><br><span class="line">byTrain(saarbruecken,paris).</span><br><span class="line"></span><br><span class="line">byPlane(frankfurt,bangkok).</span><br><span class="line">byPlane(frankfurt,singapore).</span><br><span class="line">byPlane(paris,losAngeles).</span><br><span class="line">byPlane(bangkok,auckland).</span><br><span class="line">byPlane(singapore,auckland).</span><br><span class="line">byPlane(losAngeles,auckland).</span><br><span class="line"></span><br><span class="line">travel(<span class="symbol">S</span>, <span class="symbol">E</span>, go(<span class="symbol">S</span>, <span class="symbol">E</span>)) :- just_go(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br><span class="line">travel(<span class="symbol">S</span>, <span class="symbol">E</span>, go(<span class="symbol">S</span>, <span class="symbol">M</span>, <span class="symbol">R</span>)) :- just_go(<span class="symbol">S</span>, <span class="symbol">M</span>), travel(<span class="symbol">M</span>, <span class="symbol">E</span>, <span class="symbol">R</span>).</span><br><span class="line"></span><br><span class="line">just_go(<span class="symbol">S</span>, <span class="symbol">E</span>) :- byCar(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br><span class="line">just_go(<span class="symbol">S</span>, <span class="symbol">E</span>) :- byTrain(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br><span class="line">just_go(<span class="symbol">S</span>, <span class="symbol">E</span>) :- byPlane(<span class="symbol">S</span>, <span class="symbol">E</span>).</span><br></pre></td></tr></table></figure><p>加载这段代码后，就能让Prolog告诉我们，如何从<code>valmont</code>去往<code>losAngeles</code>了</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200909/travel3效果演示.jpg" alt=""></p><p>Prolog不仅找出了题目中所给出的答案（见上图的第二行<code>X =</code>），还找出了另外一条可行的路径。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>确实不难，难怪可以作为第三章的习题。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>没有除法的除法——LeetCode第29题</title>
    <link href="https://liutos.github.io/2020/08/02/%E6%B2%A1%E6%9C%89%E9%99%A4%E6%B3%95%E7%9A%84%E9%99%A4%E6%B3%95%E2%80%94%E2%80%94LeetCode%E7%AC%AC29%E9%A2%98/"/>
    <id>https://liutos.github.io/2020/08/02/没有除法的除法——LeetCode第29题/</id>
    <published>2020-08-02T13:41:22.000Z</published>
    <updated>2020-08-02T14:21:47.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>7月初的时候挑战了一下LeetCode的<a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">第29题</a>（中等难度，似乎没什么值得夸耀的），题目要求在不使用除、乘，以及模运算的情况下，实现整数相除的函数。</p><p>既然被除数和除数都是整数，那么用减法就可以实现除除法了（多么naive的想法）。一个trivial的、用JavaScript编写的函数可以是下面这样的（为了简单起见，只考虑两个参数皆为正整数的情况）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> acc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt;= m) &#123;</span><br><span class="line">    n -= m;</span><br><span class="line">    acc += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此朴素的<code>divide</code>函数提交给LeetCode是不会被接受的的——它会在像2147483648除以2这样的测试用例上超时。可以在本地运行一下感受下究竟有多慢</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  nodejs time node divide.js</span><br><span class="line">2147483648/2=1073741824</span><br><span class="line">node divide.js  1.14s user 0.01s system 99% cpu 1.161 total</span><br></pre></td></tr></table></figure><p>那么有没有更快的计算两个整数的商的算法呢？答案当然是肯定的。</p><h1 id="尝试优化"><a href="#尝试优化" class="headerlink" title="尝试优化"></a>尝试优化</h1><p>一眼就可以看出，运行次数最多的是其中的<code>while</code>循环。以2147483648除以2为例，<code>while</code>循环中的语句要被执行1073741824次。为了提升运行速度，必须减少循环的次数。</p><p>既然每次从<code>n</code>中减去<code>m</code>需要执行<code>n/m</code>次，那么如果改为每次从中减去<code>2m</code>，不就只需要执行<code>(n/m)/2</code>次了么？循环的次数一下子就减少了一半，想想都觉得兴奋啊。每次减<code>2m</code>，并且自增2的算法的代码及其运行效果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  nodejs cat divide2.js</span><br><span class="line">function divide(n, m) &#123;</span><br><span class="line">  let acc = 0;</span><br><span class="line">  let m2 = m &lt;&lt; 1; // 因为题目要求不能用乘法，所以用左移来代替乘以2。</span><br><span class="line">  while (n &gt;= m2) &#123;</span><br><span class="line">    n -= m2;</span><br><span class="line">    acc += 2;</span><br><span class="line">  &#125;</span><br><span class="line">  while (n &gt;= m) &#123;</span><br><span class="line">    n -= m;</span><br><span class="line">    acc += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(`2147483648/2=$&#123;divide(2147483648, 2)&#125;`);</span><br><span class="line">➜  nodejs time node divide2.js</span><br><span class="line">2147483648/2=1073741824</span><br><span class="line">node divide2.js  2.65s user 0.01s system 99% cpu 2.674 total</span><br></pre></td></tr></table></figure><p>尽管耗时不降反升，令场面一度十分尴尬，但根据理论分析可知，第一个循环的运行次数仅为原来的一半，而第二个循环的运行次数最多为1次，可以知道这个优化的方向是没问题的。</p><p>如果计算<code>m2</code>的时候左移的次数为2，那么<code>acc</code>的自增步长需要相应地调整为4，第一个循环的次数将大幅下降至268435456，第二个循环的次数不会超过4；如果左移次数为3，那么<code>acc</code>的步长增至8，第一个循环的次数降至134217728，第二个循环的次数不会超过8。</p><p>显然，左移不能无限地进行下去，因为<code>m2</code>的值早晚会超过<code>n</code>。很容易算出左移次数的一个上限为</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200802/N的计算公式small.jpeg" alt=""></p><p>对数符号意味着即便对于很大的<code>n</code>和很小的<code>m</code>，上述公式的结果也不会很大，因此可以显著地提升整数除法的计算效率。</p><p>在开始写代码前，让我先来简单地证明一下这个方法算出来的商与直接计算<code>n/m</code>是相等的。</p><h1 id="一个简单的证明"><a href="#一个简单的证明" class="headerlink" title="一个简单的证明"></a>一个简单的证明</h1><p>记被减数为<code>n</code>，减数为<code>m</code>。显然，存在一个正整数<code>N</code>，使得</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200802/N的存在性small.jpeg" alt=""></p><p>令</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200802/p的计算公式small.jpeg" alt=""></p><p>，再令</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200802/r的定义small.jpeg" alt=""></p><p>，那么<code>n</code>除以<code>m</code>等价于</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200802/n除以m的变换small.jpeg" alt=""></p><p>证明完毕。</p><p>从上面的公式还可以知道，新算法将原本规模为<code>n</code>的问题转换为了一个规模为<code>r</code>的相同问题，这意味着可以用递归的方式来优雅地编写最终的代码。</p><h1 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h1><p>最终的<code>divide</code>函数的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> n2 = n;</span><br><span class="line">  <span class="keyword">let</span> N = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 用右移代替左移，避免溢出。</span></span><br><span class="line">  <span class="keyword">while</span> ((n2 &gt;&gt; <span class="number">1</span>) &gt; m) &#123;</span><br><span class="line">    N += <span class="number">1</span>;</span><br><span class="line">    n2 = n2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `power`表示公式中2的N次幂</span></span><br><span class="line">  <span class="comment">// `product`代表`power`与被除数`m`的乘积</span></span><br><span class="line">  <span class="keyword">let</span> power = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> product = m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    power = power &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    product = product &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> power + divide(n - product, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个可比最开始的<code>divide</code>要快得多了，有图有真相</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  nodejs time node divide3.js</span><br><span class="line">2147483648/2=1073741824</span><br><span class="line">node divide3.js  0.03s user 0.01s system 95% cpu 0.044 total</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果以<code>T(n, m)</code>表示被除数为<code>n</code>，除数为<code>m</code>时的算法时间复杂度，那么它的递推公式可以写成下列的形式</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200802/时间复杂度的递推公式small.jpeg" alt=""></p><p>但这玩意儿看起来并不能用主定理直接求出解析式，所以很遗憾，我也不知道这个算法的时间复杂度究竟如何——尽管我猜测就是<code>N</code>的计算公式。</p><p>如果有哪位好心的读者朋友知道的话，还望不吝赐教。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://liutos.github.io/tags/algorithm/"/>
    
      <category term="算法" scheme="https://liutos.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://liutos.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>如何高效地给多行文本添加前后缀</title>
    <link href="https://liutos.github.io/2020/07/24/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E7%BB%99%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%B7%BB%E5%8A%A0%E5%89%8D%E5%90%8E%E7%BC%80/"/>
    <id>https://liutos.github.io/2020/07/24/如何高效地给多行文本添加前后缀/</id>
    <published>2020-07-24T13:45:36.000Z</published>
    <updated>2020-07-24T14:35:12.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>理论上，开发人员是不允许操作生产环境的，更别说是像商品、订单这样的重要业务数据。不过对小公司来说，后台系统往往不是很完善，总有一些需求让运营或客服部门的同事操作起来捉襟见肘，不得不寻求开发人员的帮助。</p><p>通常这些部门的同事会给过来一批需要处理的商品或订单的ID，我会将它们粘贴到一个脚本中，并将脚本放到生产环境的机器上运行，以实现他们的<em>ad hoc</em>需求。ID一般用<code>Excel</code>文件，或在线文档的方式提供过来，将它们粘贴到脚本的源码中之后，还要为它们添加必要的引号和逗号，以满足所用语言的语法要求。比如下图就是直接粘贴后，VSCode提示错误的样子</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200724/直接粘贴导致语法错误的例子.jpg" alt=""></p><p>那么，怎样才能不失逼格地给这批ID加上前后的引号及行末的逗号呢？</p><h1 id="八仙过海，各显神通"><a href="#八仙过海，各显神通" class="headerlink" title="八仙过海，各显神通"></a>八仙过海，各显神通</h1><p>有很多方法可以完成这个任务，比如借助VSCode<a href="https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor" target="_blank" rel="noopener">multi-cursor</a>功能，手动添加前后缀</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200724/VSCode的multiple_cursor效果s.gif" alt=""></p><p>当要添加光标的位置处于同一列时，更适合用VSCode的另一个功能<code>在下面添加光标</code>（快捷键是<code>command+option+↓</code>）来实现，免去了一遍遍点击鼠标的烦恼。<code>multi-cursor</code>所敲入的每个光标还可以在各自的行上沿同方向移动不同的距离，适合处理每行长度不一致的情况。</p><p>也可以用Vim中的<a href="http://www.uni-koeln.de/~pbogusze/posts/ViM_column_mode_edit.html" target="_blank" rel="noopener">列编辑模式</a>，操作体验差不多，还可以比VSCode按更少的键——起码不需要一直压着<code>option</code>键。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200724/LargeGIF430x248s.gif" alt="Vim列模式的效果"></p><p>但列编辑模式不方便在行末追加内容——必须先在第一行的末尾敲入一个空格，往右移动依次光标，然后才能继续用列编辑模式批量添加后缀。</p><p>Emacs也有类似列编辑模式的功能，它的<code>string-insert-rectangle</code>命令比Vim的更便于添加后缀。但它没有默认的快捷键，需要先按下<code>M-x</code>，再输入命令名并回车，略为繁琐（尽管命令名可以自动补全）。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200724/LargeGIF594x278s.gif" alt="Emacs的string-insert-rectangle的效果"></p><p>除了各家编辑器内置的功能，命令行工具也适合完成这种处理，比如可以用<code>sed</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp cat b</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">5FEB1AE4-239A-4276-8E37-BE913CE6D117</span><br><span class="line">➜  /tmp sed -e "s/^/'/" -i '' b</span><br><span class="line">➜  /tmp sed -e "s/$/',/" -i '' b</span><br><span class="line">➜  /tmp cat b</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br><span class="line">'5FEB1AE4-239A-4276-8E37-BE913CE6D117',</span><br></pre></td></tr></table></figure><p>有些从在线文档上复制下来的ID会有一行空行存在于两两之间，如果是在命令行的话，只需要先用<code>grep</code>筛选一遍即可，可组合性比编辑器更强。</p><p>美中不足的是，用<code>sed</code>处理后需要手动将文件<code>b</code>的内容粘贴到脚本中——如果是用Emacs的话，也可以用<code>C-x i</code>让编辑器在光标处直接插入该文件的内容。</p><p>如果可以寸步不离Emacs，通过简单的命令或快捷键来完成这个操作，岂不美哉？</p><h1 id="自己动手，丰衣足食"><a href="#自己动手，丰衣足食" class="headerlink" title="自己动手，丰衣足食"></a>自己动手，丰衣足食</h1><p>用上自定义的Elisp函数后的效果如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200724/LargeGIF644x338s.gif" alt=""></p><p>其实实现思路很简单：</p><ol><li>首先用户会选中一片要添加前后缀的区域；</li><li>使用<code>buffer-substring-no-properties</code>函数复制这个region中的字符串，绑定为<code>text</code>；</li><li>用<code>read-from-minibuffer</code>提示并读取用户输入待添加的前后缀字符串；</li><li>用<code>split-string</code>将<code>text</code>切割为一行行的字符串，给每一行添加前后缀，再用<code>mapconcat</code>拼回一个字符串；</li><li>用<code>delete-region</code>删除被选中的内容，然后用<code>insert</code>插入新的字符串。</li></ol><p>最终的Elisp函数的定义如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt--insert-at-start-end ()</span><br><span class="line">  <span class="string">"为TEXT中的每一行添加PREFIX前缀和SUFFIX后缀。"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">text</span> (<span class="name">buffer-substring-no-properties</span> (<span class="name">mark</span>) (<span class="name">point</span>)))</span><br><span class="line">         (<span class="name">prefix</span> (<span class="name">read-from-minibuffer</span> <span class="string">"插入的前缀："</span>))</span><br><span class="line">         (<span class="name">suffix</span> (<span class="name">read-from-minibuffer</span> <span class="string">"插入的后缀："</span>))</span><br><span class="line">         (<span class="name">lines</span> (<span class="name">split-string</span> text))</span><br><span class="line">         (<span class="name">decorated-lines</span></span><br><span class="line">          (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">line</span>)</span><br><span class="line">                    (<span class="name">concat</span> prefix line suffix))</span><br><span class="line">                  lines))</span><br><span class="line">         (<span class="name">new-text</span> (<span class="name">mapconcat</span> 'identity decorated-lines <span class="string">"\n"</span>)))</span><br><span class="line">    (<span class="name">delete-region</span> (<span class="name">mark</span>) (<span class="name">point</span>))</span><br><span class="line">    (<span class="name">insert</span> new-text)))</span><br></pre></td></tr></table></figure><p>欢迎读者朋友中的Emacs用户也来使用使用;-)</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>你知道吗？2和10的整数次幂永不相等</title>
    <link href="https://liutos.github.io/2020/07/09/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F2%E5%92%8C10%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82%E6%B0%B8%E4%B8%8D%E7%9B%B8%E7%AD%89/"/>
    <id>https://liutos.github.io/2020/07/09/你知道吗？2和10的整数次幂永不相等/</id>
    <published>2020-07-09T13:45:05.000Z</published>
    <updated>2020-07-09T13:48:55.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><a href="https://book.douban.com/subject/4822685/" target="_blank" rel="noopener">《编码》</a>这本书曾经在我的豆瓣“想读”列表中躺了很久，大概在今年年初才开始看。但读着读着发现书中的电路图越来越多，而我的阅读热情也随之被慢慢浇灭。五月初的时候，终究还是把它合上，并在豆瓣上羞愧难当地将其标注为“读过”。</p><p>抛开晦涩的电路图不谈，书中有一句话吸引了我的注意力</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200709/加了标注后的《编码》一书中的原话.jpg" alt=""></p><p>第一次读到这里时，我想作者应当会在下一段给出具体的证明过程——结果居然没有。难道作者觉得两侧的空白太小了，不足以写下他所发现的美妙证法？</p><p>受好奇心的驱使，我便试着证明书中的这个结论。</p><p>不过正式开始前，还得明确一下命题：对于任意的正整数<code>a</code>和<code>b</code>（<code>a</code>不等于<code>b</code>），10的<code>a</code>次幂和2的<code>b</code>次幂不相等。</p><h1 id="先证明一条引理"><a href="#先证明一条引理" class="headerlink" title="先证明一条引理"></a>先证明一条引理</h1><p>为了证明上面的命题，需要先证明一条引理：对于任意的正整数<code>a</code>，5的<code>a</code>次幂是一个奇数。可以用数学归纳法来证明。</p><p>首先验证<code>a</code>为1时命题成立。由于5的1次幂为5，并且5是一个奇数，所以命题成立；</p><p>接着，假设<code>a</code>为<code>k</code>时命题成立，将5的<code>k</code>次幂写成<code>2n+1</code>的形式，当<code>a</code>为<code>k+1</code>时，</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200709/5的k次幂的变换.jpeg" alt=""></p><p>因此，5的<code>k</code>次幂也是一个奇数。因此，该命题对于任意的正整数<code>a</code>都是成立的。</p><p>同理可证：对于任意的正整数<code>a</code>，2的<code>a</code>次幂是偶数。</p><h1 id="反证法证明原命题"><a href="#反证法证明原命题" class="headerlink" title="反证法证明原命题"></a>反证法证明原命题</h1><p>假设存在正整数<code>a</code>和<code>b</code>（<code>b</code>大于<code>a</code>），使得10的<code>a</code>次幂与2的<code>b</code>次幂相等</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200709/待证明的等式.jpeg" alt=""></p><p>将10分解为2和5的积，再两边同时除以2的<code>a</code>次幂</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200709/变换为存在矛盾的形式.jpeg" alt=""></p><p>等式的左边和右边分别是5的正整数次幂与2的正整数次幂。由前一节的引理可知，左边是奇数，右边是偶数，两者不可能相等，与上述等式产生矛盾。因此，原假设不成立，命题得证。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我最开始的想法很复杂。虽然也是采用反证法，但我将等式做了如下变换</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200709/复杂的方法，基于无理数.jpeg" alt=""></p><p>然后试图证明以2为底的10的对数不是有理数，和等式右边不相等。不过这个方法于我而言太难了，便没有继续尝试下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="数学" scheme="https://liutos.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="math" scheme="https://liutos.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>如何写一个命令行的秒表</title>
    <link href="https://liutos.github.io/2020/07/03/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E7%A7%92%E8%A1%A8/"/>
    <id>https://liutos.github.io/2020/07/03/如何写一个命令行的秒表/</id>
    <published>2020-07-03T12:47:06.000Z</published>
    <updated>2020-07-03T13:26:51.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>相信各位读者对秒表都不陌生，智能手机上通常都有这样一款软件</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/数字秒表.jpg" alt="来自我的小米手机的截图"></p><p>有一天心血来潮，便想要“复刻”一个命令行版本的秒表程序——主要是想尝试一下新学会的、“原地更新”的技能，而不是一行接一行地输出。程序的运行效果如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/stopwatch的演示效果.gif" alt=""></p><p>那么这是怎么做的呢？</p><h1 id="实现思路及代码"><a href="#实现思路及代码" class="headerlink" title="实现思路及代码"></a>实现思路及代码</h1><h2 id="如何获取流逝的时间长度？"><a href="#如何获取流逝的时间长度？" class="headerlink" title="如何获取流逝的时间长度？"></a>如何获取流逝的时间长度？</h2><p>要实现一个秒表，首先要知道从开始计时至今过了多久。在*nix系统中，表示时刻的事实标准是<a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Epoch Time</a>，在<code>shell</code>脚本中要获取Epoch Time可以用<code>date</code>命令。再用首尾时刻相减便得到了期间流逝的秒数了，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin_at=$(date '+%s')</span><br><span class="line"><span class="meta">#</span><span class="bash"> 睡个觉</span></span><br><span class="line">end_at=$(date '+%s')</span><br><span class="line">((interval=$&#123;end_at&#125; - $&#123;begin_at&#125;))</span><br></pre></td></tr></table></figure><p>双圆括号是一种在<code>shell</code>脚本中执行算术运算的语法，其它语法可以参见<a href="http://faculty.salina.k-state.edu/tim/unix_sg/bash/math.html" target="_blank" rel="noopener">Math in Shell Scripts</a>。</p><h2 id="如何换算为时分秒？"><a href="#如何换算为时分秒？" class="headerlink" title="如何换算为时分秒？"></a>如何换算为时分秒？</h2><p>有了<code>interval</code>中存储的总秒数后，换算成时分秒便是轻而易举的事情，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((hours=$&#123;interval&#125; / 3600))</span><br><span class="line">((minutes=($&#123;interval&#125; % 3600) / 60))</span><br><span class="line">((seconds=($&#123;interval&#125; % 3600) % 60))</span><br></pre></td></tr></table></figure><h2 id="如何输出形如hh-mm-ss的格式？"><a href="#如何输出形如hh-mm-ss的格式？" class="headerlink" title="如何输出形如hh:mm:ss的格式？"></a>如何输出形如<code>hh:mm:ss</code>的格式？</h2><p><code>hh:mm:ss</code>的意思是分别用两个十进制数字显示时分秒，并以冒号分隔它们。如果有任何一个单位的数值小于10，便用字符<code>0</code>填充左侧的空白。按这个格式，凌晨1点2分3秒便会显示为<code>01:02:03</code>。</p><p>要在命令行中打印字符串，最容易想到的便是<code>echo</code>命令，只可惜它不能方便地实现填充字符<code>0</code>的需求。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/强人锁男.jpg" alt=""></p><p>强人所难也不是不行，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hours=1</span><br><span class="line">minutes=2</span><br><span class="line">seconds=3</span><br><span class="line"></span><br><span class="line">if [ "$&#123;hours&#125;" -lt '10' ];</span><br><span class="line">then</span><br><span class="line">   echo -n "0$&#123;hours&#125;"</span><br><span class="line">else</span><br><span class="line">   echo -n "$&#123;hours&#125;"</span><br><span class="line">fi</span><br><span class="line">echo -n ':'</span><br><span class="line">if [ "$&#123;minutes&#125;" -lt '10' ];</span><br><span class="line">then</span><br><span class="line">   echo -n "0$&#123;minutes&#125;"</span><br><span class="line">else</span><br><span class="line">   echo -n "$&#123;minutes&#125;"</span><br><span class="line">fi</span><br><span class="line">echo -n ':'</span><br><span class="line">if [ "$&#123;seconds&#125;" -lt '10' ];</span><br><span class="line">then</span><br><span class="line">   echo -n "0$&#123;seconds&#125;"</span><br><span class="line">else</span><br><span class="line">   echo -n "$&#123;seconds&#125;"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>更优雅的方法是用<code>printf</code>命令来自动填充左侧的字符<code>0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf "%02d:%02d:%02d" $&#123;hours&#125; $&#123;minutes&#125; $&#123;seconds&#125;</span><br></pre></td></tr></table></figure><p><code>printf</code>命令类似于C语言中的<code>printf</code>函数——它也支持打印转义的字符，下文会提到。</p><h2 id="如何覆盖已经打印的内容？"><a href="#如何覆盖已经打印的内容？" class="headerlink" title="如何覆盖已经打印的内容？"></a>如何覆盖已经打印的内容？</h2><p>今年以来我在断断续续地看<a href="https://viewsourcecode.org/snaptoken/kilo/index.html" target="_blank" rel="noopener">Build Your Own Text Editor</a>，学习如何开发文本编辑器。在这本小册子的<a href="https://viewsourcecode.org/snaptoken/kilo/03.rawInputAndOutput.html#clear-the-screen" target="_blank" rel="noopener">第三章</a>中，作者讲述了如何使用终端的转义序列（<code>escape sequence</code>）来控制屏幕上显示的东西——这正是秒表程序所需要的。</p><p>例如，在终端输出转义序列<code>\x1b[2J</code>可以清空屏幕，效果如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/演示用转义序列清空屏幕.gif" alt=""></p><p>为了覆盖已经打印出来的时分秒，需要：</p><ol><li>先将光标移动到行首；</li><li>再清除从光标开始到行末的内容。</li></ol><p>查阅<a href="https://vt100.net/docs/vt100-ug/chapter3.html" target="_blank" rel="noopener">《VT100 User Guide》第三章</a>可以知道</p><ol><li>要把光标移动到行首可以用转义序列<code>\x1b[8D</code>。之所以是8，是因为按照<code>hh:mm:ss</code>输出时分秒后光标距离行首8个身位；</li><li>要清除光标到行末内容可以用转义序列<code>\x1b[0K</code>（实际上，将光标移到行首只需要使用回车（<code>carriage return</code>）即可，但它被解释为开启新的一行了）。</li></ol><p>更优雅的方法甚至连转义序列也不需要，只要用<code>tput</code>命令即可，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -n '11:22:33'</span><br><span class="line">tput cr</span><br><span class="line">tput el</span><br><span class="line">echo '44:55:66'</span><br></pre></td></tr></table></figure><p>关于<code>cr</code>和<code>el</code>，以及更多可以传给<code>tput</code>命令的参数，可以参见<code>terminfo</code>的<code>man</code>文档。</p><h2 id="如何每隔一秒钟输出一次？"><a href="#如何每隔一秒钟输出一次？" class="headerlink" title="如何每隔一秒钟输出一次？"></a>如何每隔一秒钟输出一次？</h2><p>这大概是整个程序中最简单的需求了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while [ 1 -eq 1 ]</span><br><span class="line">do</span><br><span class="line">    # 此处可以为所欲为</span><br><span class="line">    sleep 0.5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="完整的秒表实现"><a href="#完整的秒表实现" class="headerlink" title="完整的秒表实现"></a>完整的秒表实现</h2><p>至此，完整的秒表程序就可以实现出来了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 秒表，以hh:mm:ss的格式展示数据</span></span><br><span class="line"></span><br><span class="line">begin_at=$(date '+%s')</span><br><span class="line"></span><br><span class="line">while [ 1 -eq 1 ]</span><br><span class="line">do</span><br><span class="line">    end_at=$(date '+%s')</span><br><span class="line">    # 算术运算：http://faculty.salina.k-state.edu/tim/unix_sg/bash/math.html</span><br><span class="line">    ((interval=$&#123;end_at&#125; - $&#123;begin_at&#125;))</span><br><span class="line">    ((hours=$&#123;interval&#125; / 3600))</span><br><span class="line">    ((minutes=($&#123;interval&#125; % 3600) / 60))</span><br><span class="line">    ((seconds=($&#123;interval&#125; % 3600) % 60))</span><br><span class="line">    tput cr</span><br><span class="line">    tput el</span><br><span class="line">    printf "%02d:%02d:%02d" $&#123;hours&#125; $&#123;minutes&#125; $&#123;seconds&#125;</span><br><span class="line">    sleep 0.5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行后的效果正如本文开头的GIF所示。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="bash" scheme="https://liutos.github.io/tags/bash/"/>
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
      <category term="命令行" scheme="https://liutos.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的NOT EXISTS遭遇战</title>
    <link href="https://liutos.github.io/2020/06/25/MySQL%E7%9A%84NOT-EXISTS%E9%81%AD%E9%81%87%E6%88%98/"/>
    <id>https://liutos.github.io/2020/06/25/MySQL的NOT-EXISTS遭遇战/</id>
    <published>2020-06-25T14:12:40.000Z</published>
    <updated>2020-06-25T14:15:19.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅尝一下NOT-EXISTS"><a href="#浅尝一下NOT-EXISTS" class="headerlink" title="浅尝一下NOT EXISTS"></a>浅尝一下<code>NOT EXISTS</code></h1><p>最近老婆在看视频学习MySQL，然后碰到了这样一道习题：有三个表，分别记录学生、课程，以及学生选修了什么课程的信息，问如何用<code>NOT EXISTS</code>找出选修了所有课程的学生。</p><p>为了避免想破脑袋编造一些尴尬的学生姓名和课程名，我简化了一下习题中的表的结构，只留下它们的ID列。建表语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选修关系</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`elective`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`student`</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`course_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`course`</span>(<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>还需要给它们塞入一些示例数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>), (<span class="number">4</span>), (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> (<span class="string">`id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`elective`</span> (<span class="string">`course_id`</span>, <span class="string">`student_id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>显然，只有<code>id</code>列的值为1和5的学生是选修了全部课程的。用<code>NOT EXISTS</code>写出来的SQL语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>   <span class="string">`student`</span> </span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">                   <span class="keyword">FROM</span>   <span class="string">`course`</span> </span><br><span class="line">                   <span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">                                      <span class="keyword">FROM</span>   <span class="string">`elective`</span> </span><br><span class="line">                                      <span class="keyword">WHERE</span>  <span class="string">`student`</span>.<span class="string">`id`</span> = </span><br><span class="line">                                             <span class="string">`elective`</span>.<span class="string">`student_id`</span> </span><br><span class="line">                                             <span class="keyword">AND</span> <span class="string">`course`</span>.<span class="string">`id`</span> = </span><br><span class="line">                                     <span class="string">`elective`</span>.<span class="string">`course_id`</span>));</span><br></pre></td></tr></table></figure><p>在<a href="https://dbeaver.io/" target="_blank" rel="noopener">DBEaver</a>中运行后的结果为</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200625/双重NOT_EXISTS的执行结果.jpg" alt="在DBEaver中执行的结果"></p><p>正确地找出了两个选修了所有课程的学生的<code>id</code>。</p><h1 id="如何理解双重NOT-EXISTS"><a href="#如何理解双重NOT-EXISTS" class="headerlink" title="如何理解双重NOT EXISTS"></a>如何理解双重<code>NOT EXISTS</code></h1><p>当第一次被请教这道习题的时候，我其实并不能理解<code>NOT EXISTS</code>的含义。直到后来去看<code>EXISTS</code>的<a href="https://dev.mysql.com/doc/refman/8.0/en/exists-and-not-exists-subqueries.html" target="_blank" rel="noopener">文档</a>，才顿悟了上面的SQL。</p><p>我的理解方法是将双重<code>NOT EXISTS</code>转换为三层循环。以上面的SQL为例，转述为人话就是：找出<code>student</code>表中所有的、<strong>没有</strong>任何一门<code>course</code>表中的课程是<strong>没有</strong>选修的、的学生——双重的 <strong>没有</strong>。</p><p>转换为三层循环大概长这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> student <span class="keyword">of</span> students) &#123;</span><br><span class="line">  <span class="comment">// 是否存在学生未选修的课程</span></span><br><span class="line">  <span class="keyword">let</span> existSuchCourse = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> course <span class="keyword">of</span> courses) &#123;</span><br><span class="line">    <span class="keyword">let</span> existSuchElective = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> elective <span class="keyword">of</span> electives) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elective.student_id === student.id &amp;&amp; elective.course_id === course.id) &#123;</span><br><span class="line">        existSuchElective = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完elective表的记录后，existSuchElective仍然为false，说明的确有一门课程是没有选修记录的</span></span><br><span class="line">    <span class="comment">// 那么便意味着“存在至少一门课程，使得当前被遍历的学生与该课程没有选修关系”。</span></span><br><span class="line">    <span class="keyword">if</span> (!existSuchElective) &#123;</span><br><span class="line">      existSuchCourse = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果遍历完一圈后确实没有找到“未选修”的课程，说明这名学生全都选修了</span></span><br><span class="line">  <span class="keyword">if</span> (!existSuchCourse) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(student);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOT-EXISTS的本质"><a href="#NOT-EXISTS的本质" class="headerlink" title="NOT EXISTS的本质"></a><code>NOT EXISTS</code>的本质</h1><p>即使不强行理解，也可以让MySQL明确告知双重<code>NOT EXISTS</code>是怎么运作的。用<code>EXPLAIN</code>解释上面的SQL的结果如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200625/双重NOT_EXISTS的EXPLAIN结果.jpg" alt=""></p><p>MySQL的<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN命令的文档</a>中说明了如何解读执行计划</p><blockquote><p>EXPLAIN returns a row of information for each table used in the SELECT statement. It lists the tables in the output in the order that MySQL would read them while processing the statement. This means that MySQL reads a row from the first table, then finds a matching row in the second table, and then in the third table, and so on. When all tables are processed, MySQL outputs the selected columns and backtracks through the table list until a table is found for which there are more matching rows. The next row is read from this table and the process continues with the next table.</p></blockquote><p>以上面的<code>EXPLAIN</code>为例，MySQL从<code>student</code>表中读出一行，再从<code>course</code>表中读取一行，最后从<code>elective</code>表中读取一行，然后看看<code>WHERE</code>子句是否能够被满足。如果可以，就输出从<code>student</code>表中读出来的这行数据。上图第2和第3行的<code>select_type</code>都是<code>DEPENDENT SUBQUERY</code>，表示它们依赖于“外层”的查询上下文——<code>elective</code>的<code>WHERE</code>子句依赖于<code>student</code>和<code>course</code>中读出来的行。</p><p>似乎和方才的三重循环有异曲同工之妙呢。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>像<code>NOT EXISTS</code>这么“高阶”的功能我从未在业务代码中读过和使用过——别说<code>NOT EXISTS</code>，就算是<code>EXISTS</code>也是从未有之，甚至连子查询也极少。毕竟“正经的互联网公司”只是把MySQL<del>当妹妹</del>当一个具备复杂查询查询功能的key-value数据库来使用（笑</p><p>比起双重<code>NOT EXISTS</code>，我更可能凭直觉写出基于子查询的解决方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>   <span class="string">`student`</span> </span><br><span class="line"><span class="keyword">WHERE</span>  <span class="string">`id`</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="string">`student_id`</span> </span><br><span class="line">                <span class="keyword">FROM</span>   <span class="string">`elective`</span> </span><br><span class="line">                <span class="keyword">GROUP</span>  <span class="keyword">BY</span> <span class="string">`student_id`</span> </span><br><span class="line">                <span class="keyword">HAVING</span>( <span class="keyword">Count</span>(<span class="number">0</span>) ) = <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>我甚至觉得会有人把数据库里的行读进内存然后用应用层代码来找出选修了全部课程的学生！</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="database" scheme="https://liutos.github.io/tags/database/"/>
    
      <category term="mysql" scheme="https://liutos.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://liutos.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>用org-mode管理API测试用例</title>
    <link href="https://liutos.github.io/2020/06/10/%E7%94%A8org-mode%E7%AE%A1%E7%90%86API%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>https://liutos.github.io/2020/06/10/用org-mode管理API测试用例/</id>
    <published>2020-06-10T13:31:58.000Z</published>
    <updated>2020-06-10T13:58:19.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API测试用例是什么？"><a href="#API测试用例是什么？" class="headerlink" title="API测试用例是什么？"></a>API测试用例是什么？</h1><p>在互联网大行其道的今天，身为一名电商平台的程序员，必定经常与HTTP API打交道，一个常见的情况便是做API测试。抛开可以用单元测试代替的，很多时候需要真地发出HTTP请求才行。这些负责发出HTTP请求的东西可能是一行<code>curl</code>命令，可能是一个<code>.js</code>文件，也可能是一个在postman中点击按钮的操作，但不管形态如何，它们便是API测试用例。尽管名字中带有“用例”二字，但很多时候是由人来校验结果的，用例更关注发出怎样的HTTP请求。</p><h1 id="为什么要管理它们？"><a href="#为什么要管理它们？" class="headerlink" title="为什么要管理它们？"></a>为什么要管理它们？</h1><p>不同于每天在浏览器中发生成千上万次的、平凡的HTTP（或HTTPS）请求，API测试用例是值得一番精心管理的，因为：</p><ol><li><p>API测试用例通常会重复使用，因此必须将它们持久化保存。也许是保存成shell脚本，也许是保存成脚本语言源文件，也许是保存为某一款软件的数据文件；</p></li><li><p>需要为多个API编写测试用例，因此必须区分不同的API对应的测试用例。例如，负责管理业务资源的服务（比如一个管理商品数据的、提供RESTful API的服务），起码需要提供增删查改的功能，那么也就需要有增删查改对应的API测试用例；</p></li><li><p>需要为多个服务的API编写用例，因此必须区分不同的服务对应的测试用例集。例如，既然有商品服务，那么极可能还有订单服务、优惠券服务、物流服务，等等，每个服务又都有增删查改的功能，这些不同服务的API也需要各自的测试用例；</p></li><li><p>需要区分不同的运行环境。通常本地、开发、测试，以及生产环境是互相隔离的，一个用例中的参数往往不能照搬到另一个环境中。</p></li></ol><p>API、服务，以及环境这三个维度上的区别，使得测试用例的数量显著增加，如不进行管理，当要用时，要么不得不从零开始再写一遍脚本，要么得翻查很久才能找到所需的用例。</p><h1 id="用org-mode管理"><a href="#用org-mode管理" class="headerlink" title="用org-mode管理"></a>用org-mode管理</h1><h2 id="org-mode是什么？"><a href="#org-mode是什么？" class="headerlink" title="org-mode是什么？"></a>org-mode是什么？</h2><p><code>org-mode</code>是一款Emacs编辑器的扩展，它让使用者能够用快速高效的纯文本方式来记笔记、维护待办事项、安排计划，以及编写文档。<code>org-mode</code>的精髓在于它的大纲组织能力，以及依托于Emacs的扩展能力，两者使其正好可以胜任管理API测试用例的工作。一个<code>.org</code>文件的示例如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/org-mode官网示例.jpg" alt="org-mode官网的示例截图"></p><h2 id="如何用org-mode管理API测试用例？"><a href="#如何用org-mode管理API测试用例？" class="headerlink" title="如何用org-mode管理API测试用例？"></a>如何用org-mode管理API测试用例？</h2><p>尽管<code>org-mode</code>提供了丰富的功能，但只是管理API测试用例的话，并用不上太多花里胡哨的东西，只需要<code>org-mode</code>的大纲功能和<code>org-babel</code>特性即可。</p><p>首先用不同的<code>.org</code>文件区分不同的环境。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/用不同的org文件区分环境.jpg" alt=""></p><p>接着用不同层级的headline区分不同的服务、资源类型，以及API。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/用不同层级的headline管理的示例.jpg" alt=""></p><p>然后用<code>org-mode</code>的<a href="https://orgmode.org/manual/Structure-of-Code-Blocks.html" target="_blank" rel="noopener">代码块</a>语法来编写HTTP请求。以请求<code>https://httpbin.org/uuid</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC restclient</span><br><span class="line">  GET https://httpbin.org/uuid</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure><p><code>#+BEGIN_SRC</code>和<code>#+END_SRC</code>分别表示开启和结束代码块，<code>restclient</code>表示这个代码块内的代码可以用Emacs的<code>restclient-mode</code>来编辑。在代码块中，<code>GET https://httpbin.org/uuid</code>表示以GET方法请求<code>https://httpbin.org/uuid</code>。</p><p>安装了<a href="https://github.com/pashky/restclient.el" target="_blank" rel="noopener"><code>restclient</code></a>后，将光标定位在代码块上并按下<code>ctrl-c &#39;</code>，可以进入一个单独的buffer编辑其中的源代码</p><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/进入restclient模式的buffer.mp4" type="video/mp4"><br></video><p>最后，如果配置了<code>org-babel</code>，甚至可以直接在代码块上按下<code>ctrl-c ctrl-c</code>来发出HTTP请求。</p><p><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/org-mode中发出HTTP请求.mp4" type="video/mp4"><br></video><br>可以看到，HTTP响应的内容会保留在这个<code>.org</code>文件中。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以前我也用过其它的工具来管理API测试用例：</p><ol><li>刚工作的时候用的是Postman，那时候Postman还是Chrome的一个插件；</li><li>后来出于对Firefox浏览器的喜爱，找了一个叫RESTClient的插件来代替postman，久而久之发觉两者的差距蛮大，终究无法代替；</li><li>接着遇到了Emacs中的<code>restclient.el</code>，于是用了好一段时间的纯<code>restclient-mode</code>（没有搭配<code>org-mode</code>）；</li><li>再后来开始用Mac办公了，便开始寻找Mac下的这类工具，遇到了<a href="https://insomnia.rest/" target="_blank" rel="noopener">Insomnia</a>。如果有人找我推荐用于HTTP API测试的GUI工具的话，我会毫无不犹豫地推荐这款。</li></ol><p>再后来，我又回到了Emacs，并用<code>org-mode</code>来管理这些API测试用例。目前这是最适合我的一种方式。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="api" scheme="https://liutos.github.io/tags/api/"/>
    
      <category term="http" scheme="https://liutos.github.io/tags/http/"/>
    
  </entry>
  
</feed>
