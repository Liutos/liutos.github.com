<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小打小闹写点bug</title>
  
  <subtitle>乍听之下，不无道理；仔细揣摩，胡说八道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liutos.github.io/"/>
  <updated>2020-04-14T13:05:46.751Z</updated>
  <id>https://liutos.github.io/</id>
  
  <author>
    <name>Liutos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库schema不是CRUD服务的一切</title>
    <link href="https://liutos.github.io/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93schema%E4%B8%8D%E6%98%AFCRUD%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%B8%80%E5%88%87/"/>
    <id>https://liutos.github.io/2020/04/14/数据库schema不是CRUD服务的一切/</id>
    <published>2020-04-14T05:42:22.000Z</published>
    <updated>2020-04-14T13:05:46.751Z</updated>
    
    <content type="html"><![CDATA[<center>谨以本文向我脑海中那些不成熟的想法致敬。</center><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>受疫情影响呆在家中的这段时间里，我收尾了<a href="https://book.douban.com/subject/26915970/" target="_blank" rel="noopener">《Clean Architecture》</a>。这本书给了我许多新知识和启发，包括本文的中心论点——数据库schema不是CRUD服务的一切，也是在读书过程中想到的。在书中，作者的原话是</p><blockquote><p>But the database is not the data model</p></blockquote><p>它出现在书中第六部分《Details》的第一个章节中。作者认为，从架构的角度来看，数据库不是一个实体而是一个细节，不足以成为架构中的一个元素。他甚至打了个比方：数据库对于架构而言，就好像门把手对于房子一般。并且，作者进一步澄清了他的观点：他口中所说的数据库，不是指的数据模型。应用内的数据结构对架构而言至关重要，但数据库并不是数据模型。</p><p>这不禁让我回忆起了自己早期写设计文档的套路。</p><p>在我的从业生涯早期（说得好像我从业很久了一样），每当需要开发一个新的Web服务时，必须先写一份简要的设计文档，向上级清楚地表达我的实现思路，包括：</p><ol><li>如何与其它服务协作完成产品提出的需求；</li><li>服务的接口描述；</li><li>数据的存储结构；</li><li>关键的算法等。</li></ol><p>那时候的我会先考虑数据的存储结构，然后定义接口，最后才是与其它服务的协作。这些早期设计文档的其中一个特点是：接口的响应格式，与数据的存储结构是相同的。</p><p>比方说我要设计一个网上商城的订单服务，可能会提供如下查询特定订单的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /order/:id</span><br></pre></td></tr></table></figure><p>其响应格式可能如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  order: &#123;</span><br><span class="line">    id: <span class="string">'F122663A-A5DC-451A-9B79-92DCE2EE41F1'</span>,</span><br><span class="line">    price: <span class="string">'100.00'</span>,</span><br><span class="line">    products: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'MacBook Pro'</span>,</span><br><span class="line">        price: <span class="string">'19999.00'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'iPhone'</span>,</span><br><span class="line">        price: <span class="string">'6999.00'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保存这种“不平坦”的对象，将会用MongoDB作为存储——除了文档的主键<code>_id</code>之外，其它字段在接口和存储之间一一对应。</p><p>不仅仅是响应格式，在这个Web服务内所操作的也是同样结构的对象。用<a href="https://mongodb.github.io/node-mongodb-native/" target="_blank" rel="noopener">MongoDB Node.JS Driver</a>获得的订单恰好是一个JS对象，它与collection的文档有着一模一样的结构。之后这些对象会在代码内到处流通，不加修饰地使用。定义了数据库schema（就算是用MongoDB也有一套脑内的schema）后，其它的一切也就跟着确定了。</p><p>业界甚至有工具可以直接从数据库得到API，比如<a href="https://github.com/PostgREST/postgrest" target="_blank" rel="noopener">postgrest</a>。</p><p>很多时候，数据库schema成了一个应用内事实上的数据模型。但是，即便它们可以偶然一样，也不要认为它们总应该一样。</p><h1 id="适合存储，不一定适合计算"><a href="#适合存储，不一定适合计算" class="headerlink" title="适合存储，不一定适合计算"></a>适合存储，不一定适合计算</h1><p>以MySQL为例，在<code>CREATE TABLE</code>语句中某一列的类型实际上决定的是存储时分配的空间的多少。但适合存储的类型，并不一定也适合业务逻辑的运算。</p><p>比如说，要在MySQL中存储“开关型”的数据，即诸如“是否启用”或“是否已支付”这样非此即彼的状态时，通常定义为<code>TINYINT</code>类型，用0表示逻辑假（“未启用”和“未支付”），1表示逻辑真（“已启用”和“已支付”）。但对代码而言，比起用数值类型，布尔类型才是更恰当的选择。尤其是当所选择的语言并没有将0与<code>false</code>、1与<code>true</code>等价起来的时候——在Common Lisp中，<code>(if 0 1 2)</code>的求值结果为1。</p><h1 id="适合计算，不一定适合存储"><a href="#适合计算，不一定适合存储" class="headerlink" title="适合计算，不一定适合存储"></a>适合计算，不一定适合存储</h1><p>通常数据结构在内存中比在磁盘上要容易表达得多，所以代码中使用的数据结构会比数据库中存储的要灵活不少，这同样造成了两者的不匹配。</p><p>以我自己开发的提醒工具<a href="https://github.com/Liutos/cuckoo" target="_blank" rel="noopener"><code>cuckoo</code></a>为例，应用内有两种对象：任务和提醒。任务描述了要做的事情，提醒描述了在什么时候该告诉用户。显然，提醒是一个依赖于任务的弱实体。在cuckoo的代码中，任务是<code>Task</code>类的实例对象，有一个名为<code>remind</code>的成员变量存储着提醒。</p><p>但这样的结构不方便存储在MySQL中。遵照关系型数据库设计的第一范式，任务和提醒分别被存储在<code>t_task</code>和<code>t_remind</code>表中，两者通过<code>t_task.remind_id</code>联系起来。</p><p>当然，也可以在一开始就用MongoDB来存储这些数据（甚至可以用对象数据库？不过我没玩过）。尤其是cuckoo只是一个小玩意儿，MySQL和MongoDB都足以胜任。但作为一名有理想的程序员，在做设计的时候，不应该让低层细节过分干预高层策略。（在《Clean Architecture》中，越是接近I/O的越是low-level，反之则是high-level。）</p><h1 id="面向业务逻辑，而非存储结构"><a href="#面向业务逻辑，而非存储结构" class="headerlink" title="面向业务逻辑，而非存储结构"></a>面向业务逻辑，而非存储结构</h1><p>业务逻辑和规则才是一个服务的核心，应该把更多精力花在实现业务逻辑的数据结构和算法上。</p><p>以网上商城中常见的优惠券功能为例。优惠券服务所管理的优惠券往往有着各种效果、条件，以及限制。为了保持灵活性，优惠券类（下称<code>Coupon</code>）的实例对象中会有三种接口类型的成员变量：</p><ol><li><code>Effect</code>类型的变量<code>effect</code>，负责实现优惠效果的计算逻辑；</li><li><code>Condition</code>数组类型的变量<code>conditions</code>，负责实现使用条件的检查逻辑；</li><li><code>Restriction</code>数组类型的变量<code>restrictions</code>，负责实现使用限制的检查逻辑。</li></ol><p>三个接口可以有各种各样的实现——定额减免、折扣减免、某年月日前可用、不可用于电子产品，等等。如此，优惠券功能具备了极大的灵活性，业务可以随心所欲，产品可以为所欲为，老板数钱数到手软，公司业绩蒸蒸日上。</p><p>那么如何存储<code>Effect</code>、<code>Condition</code>、<code>Restriction</code>、<code>Coupon</code>类的实例对象呢？没有唯一的选择，既可以存储在MySQL中，也可以存储在MongoDB中，或者别的什么数据库中。不管这些数据最终如何持久化，都不会影响作为高层策略的优惠券业务逻辑。反过来，如果在代码中处理的不是类、接口，以及实例对象，而是直接从数据库中取出来的、贫血模型的行（或文档），处理起来就不是很优雅了——可以预见 ，代码中会充斥着许多的<code>if-else</code>判断逻辑。</p><p>数据库只是帮忙从磁盘中读取数据的软件，它的schema不应该直接成为应用的数据模型。</p><h1 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h1><p>不应该在HTTP接口的响应中直接暴露数据库的schema。</p><p>不说别的，光是数据库schema与接口规格所使用的命名规则就足以造成差异了。也许在MySQL中用<a href="https://en.wikipedia.org/wiki/Snake_case" target="_blank" rel="noopener"><code>snake case</code></a>命名一列，却又在HTTP响应的JSON对象中用<a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank" rel="noopener"><code>camel case</code></a>命名字段。</p><p>此外，除非这些接口仅仅实现增删查改、没有任何的业务逻辑或规则，否则一个服务更应当提供与业务需求恰好契合的接口。仍然以上文的优惠券服务为例，尽管内部可能<code>Effect</code>、<code>Condition</code>、<code>Restriction</code>、<code>Coupon</code>等诸多概念，但<del>煮不在乎</del>用户不在乎，他们只想看到用人话说出来的优惠券效果以及使用规则——用户甚至不关心条件和限制有何不同。</p><p>如果优惠券服务直接将数据库中的行（或文档）序列化成JSON返回给调用者，会导致封装的泄露。每一个查询优惠券的调用方，都必须了解优惠券的内部表示形式，必须知道效果由<code>effect</code>描述、用券后的订单金额是多少、<code>conditions</code>中有关于过期与否的信息，等等。每增加一个优惠券服务的使用者，就相应地增加一套描述这些内容的代码。甚至当优惠券服务自身重构的时候，也许牵连到众多的调用方。</p><p>如果直接将存储结构暴露给调用者的话，又何必再做一个Web服务呢。</p><h1 id="切勿矫枉过正"><a href="#切勿矫枉过正" class="headerlink" title="切勿矫枉过正"></a>切勿矫枉过正</h1><p>的确存在这样的例子，数据库schema、数据模型，以及HTTP响应结构三者相同。这是因为比起维护数据库schema与数据模型的转换规则，以及DTO与数据模型的转换规则而言，在领域代码中直接使用数据库schema来表达数据模型的成本更低一点。尽管数据库schema不是Web服务的一切，但很多时候可以因地制宜地妥协一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://liutos.github.io/tags/mysql/"/>
    
      <category term="architecture" scheme="https://liutos.github.io/tags/architecture/"/>
    
      <category term="database" scheme="https://liutos.github.io/tags/database/"/>
    
      <category term="架构" scheme="https://liutos.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="数据库" scheme="https://liutos.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>改良在Emacs中浏览笔记的方式</title>
    <link href="https://liutos.github.io/2020/03/29/%E6%94%B9%E8%89%AF%E5%9C%A8Emacs%E4%B8%AD%E6%B5%8F%E8%A7%88%E7%AC%94%E8%AE%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://liutos.github.io/2020/03/29/改良在Emacs中浏览笔记的方式/</id>
    <published>2020-03-29T08:56:39.000Z</published>
    <updated>2020-03-29T09:00:07.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><p>半年前我在<a href="https://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/">这篇文章</a>中展示了在Emacs中查阅笔记的效果——用<a href="https://github.com/tkf/emacs-request" target="_blank" rel="noopener">emacs-request</a>请求ElasticSearch查询关键字、基于<a href="https://github.com/emacs-helm/helm" target="_blank" rel="noopener">helm</a>以下拉菜单的方式展示查询结果的标题（即问题），最后打开浏览器查看笔记内容。稍加使用就发现一些不足之处：</p><ol><li>需要离开Emacs打开浏览器。我更希望能在Emacs中查看；</li><li>ES的响应内容为JSON，要快速地辨认出<code>question</code>和<code>answer</code>字段比较困难；</li><li>一个问题的答案往往是多行的，但在浏览器中<code>answer</code>字段是以一行的形式展示的，不利于阅读。</li></ol><p>为了解决这些问题，我实现了一种新的查看笔记内容的方式。</p><h1 id="改良后的效果"><a href="#改良后的效果" class="headerlink" title="改良后的效果"></a>改良后的效果</h1><a id="more"></a><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200329/改良后的笔记查阅方式.mp4" type="video/mp4"><br></video><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>我的目标是：</p><ol><li>在不脱离Emacs的情况下浏览笔记内容；</li><li>提供org-mode的语法高亮。</li></ol><p>为此，先用被选中笔记的<code>_id</code>请求ES，取回完整的JSON。接着，将<code>_source</code>中的<code>question</code>和<code>answer</code>字段的内容拼接在一起（以<code>\n</code>作为分隔符）。最后，在Emacs中新建一个buffer、启用org-mode、插入拼接后的内容，并设置该buffer为只读。大功告成！</p><p>完整的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 调用ElasticSearch查询笔记</span></span><br><span class="line">(<span class="name">require</span> 'request)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq (<span class="name">query</span>)</span><br><span class="line">  <span class="string">"向ElasticSearch查询QUERY匹配的笔记"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">response</span>))</span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:9200/faq/_search"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">encode-coding-string</span></span><br><span class="line">            (<span class="name">json-encode</span></span><br><span class="line">             (<span class="name">list</span></span><br><span class="line">              (<span class="name">cons</span> <span class="string">"query"</span> (<span class="name">list</span></span><br><span class="line">                             (<span class="name">cons</span> <span class="string">"multi_match"</span> (<span class="name">list</span></span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"fields"</span> (<span class="name">list</span> <span class="string">"answer"</span> <span class="string">"question"</span>))</span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"query"</span> query)))))))</span><br><span class="line">            'utf-8)</span><br><span class="line">     <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">     <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">setq</span> data (<span class="name">decode-coding-string</span> data 'utf-8))</span><br><span class="line">                 (<span class="name">setq</span> response (<span class="name">json-read-from-string</span> data))))</span><br><span class="line">     <span class="symbol">:sync</span> <span class="literal">t</span>)</span><br><span class="line">    response))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> make-faq-candidates (<span class="name">response</span>)</span><br><span class="line">  <span class="string">"将查询ElasticSearch的结果构造为helm可以识别的candidates格式"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">hits</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits response))))))</span><br><span class="line">    (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">doc</span>)</span><br><span class="line">              (<span class="name">let</span> ((<span class="name">_source</span> (<span class="name">cdr</span> (<span class="name">assoc</span> '_source doc))))</span><br><span class="line">                (<span class="name">cons</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'question _source))</span><br><span class="line">                      <span class="comment">;; (cdr (assoc 'answer (assoc '_source doc)))</span></span><br><span class="line">                      (<span class="name">cdr</span> (<span class="name">assoc</span> '_id doc)))))</span><br><span class="line">            hits)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> faq-query <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq-candidates ()</span><br><span class="line">  (<span class="name">make-faq-candidates</span> (<span class="name">faq</span> faq-query)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;; 创建新的buffer并将ElasticSearch的内容展示在其中</span></span><br><span class="line">(<span class="name">defun</span> show-faq (<span class="name">text</span>)</span><br><span class="line">  <span class="comment">;; 创建一个buffer，显示它并选中这个窗口</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">buffer</span> (<span class="name">get-buffer-create</span> <span class="string">"*FAQ*"</span>)))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">window</span> (<span class="name">display-buffer</span> buffer)))</span><br><span class="line">      (<span class="name">select-window</span> window)</span><br><span class="line">      <span class="comment">;; 用新的内容覆盖原来的内容</span></span><br><span class="line">      (<span class="name">setq</span> inhibit-read-only <span class="literal">t</span>)</span><br><span class="line">      (<span class="name">org-mode</span>)</span><br><span class="line">      (<span class="name">erase-buffer</span>)</span><br><span class="line">      (<span class="name">insert</span> text)</span><br><span class="line">      (<span class="name">read-only-mode</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> faq-helm-sources</span><br><span class="line">      `((name . <span class="string">"FAQ at Emacs"</span>)</span><br><span class="line">        (candidates . faq-candidates)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    (let (response</span><br><span class="line">                          (url (format <span class="string">"http://localhost:9200/faq/_doc/%s"</span> candidate)))</span><br><span class="line">                      (message <span class="string">"url is %s"</span> url)</span><br><span class="line">                      (request</span><br><span class="line">                       url</span><br><span class="line">                       :parser 'buffer-string</span><br><span class="line">                       :success (cl-function</span><br><span class="line">                                 (lambda (&amp;key data &amp;allow-other-keys)</span><br><span class="line">                                   (setq data (decode-coding-string data 'utf-8))</span><br><span class="line">                                   (setq response (json-read-from-string data))))</span><br><span class="line">                       :sync <span class="literal">t</span>)</span><br><span class="line">                      ;; 从文档中提取出问题和答案，拼装成原本在.org文件中的模样</span><br><span class="line">                      (let ((answer (cdr (assoc 'answer (assoc '_source response))))</span><br><span class="line">                            (question (cdr (assoc 'question (assoc '_source response)))))</span><br><span class="line">                        (show-faq</span><br><span class="line">                         (concat question <span class="string">"\n"</span> answer))))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-ask ()</span><br><span class="line">  <span class="string">"交互式地从minibuffer中读取笔记的关键词并展示选项"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">content</span> (<span class="name">read-from-minibuffer</span> <span class="string">"笔记关键词："</span>)))</span><br><span class="line">    (<span class="name">setq</span> faq-query content)</span><br><span class="line">    (<span class="name">helm</span> <span class="symbol">:sources</span> '(faq-helm-sources))))</span><br></pre></td></tr></table></figure><p>与之前版本的差异主要在于：</p><ol><li>变量<code>faq-helm-sources</code>中的<code>action</code>部分多了很多内容，主要是请求ES和拼接字段；</li><li>新增了<code>show-faq</code>函数用于显示问题及其答案。</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>挺好奇各位读者朋友是怎么记笔记和看笔记的XD</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;半年前我在&lt;a href=&quot;https://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/&quot;&gt;这篇文章&lt;/a&gt;中展示了在Emacs中查阅笔记的效果——用&lt;a href=&quot;https://github.com/tkf/emacs-request&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;emacs-request&lt;/a&gt;请求ElasticSearch查询关键字、基于&lt;a href=&quot;https://github.com/emacs-helm/helm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;helm&lt;/a&gt;以下拉菜单的方式展示查询结果的标题（即问题），最后打开浏览器查看笔记内容。稍加使用就发现一些不足之处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要离开Emacs打开浏览器。我更希望能在Emacs中查看；&lt;/li&gt;
&lt;li&gt;ES的响应内容为JSON，要快速地辨认出&lt;code&gt;question&lt;/code&gt;和&lt;code&gt;answer&lt;/code&gt;字段比较困难；&lt;/li&gt;
&lt;li&gt;一个问题的答案往往是多行的，但在浏览器中&lt;code&gt;answer&lt;/code&gt;字段是以一行的形式展示的，不利于阅读。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决这些问题，我实现了一种新的查看笔记内容的方式。&lt;/p&gt;
&lt;h1 id=&quot;改良后的效果&quot;&gt;&lt;a href=&quot;#改良后的效果&quot; class=&quot;headerlink&quot; title=&quot;改良后的效果&quot;&gt;&lt;/a&gt;改良后的效果&lt;/h1&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>我是怎么把笔记导入ElasticSearch的</title>
    <link href="https://liutos.github.io/2020/03/26/%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%85%A5ElasticSearch%E7%9A%84/"/>
    <id>https://liutos.github.io/2020/03/26/我是怎么把笔记导入ElasticSearch的/</id>
    <published>2020-03-26T14:51:56.000Z</published>
    <updated>2020-03-26T15:01:26.980Z</updated>
    
    <content type="html"><![CDATA[<p>尽管我最近开始用<a href="https://github.com/tamlok/vnote" target="_blank" rel="noopener">VNote</a>做读书或读在线文档的笔记，但更多的时候，我把经验型知识都记录在一个名为<code>my_note</code>的Git仓库中。这个仓库中有许多.org`文件：</p><ol><li><code>TeX.org</code>，记录与<code>LaTeX</code>相关的问题和解决方法；</li><li><code>asm.org</code>，记录的是与编写汇编语言程序相关的问题和解决办法；</li><li><code>cl.org</code>，记录的是与编写Common Lisp代码相关的问题和解决办法；</li></ol><p>这些内容被我称为FAQ。尽管不同的文件记载着不同方面的内容，但它们的格式是一致的：</p><ol><li>每个文件都以org-mode的语法书写；</li><li>文件中只有一级条目，没有嵌套；</li><li>每一个条目的标题就是一个问题的表述，下方的文字则是这个问题的答案。</li></ol><p>A picture is worth a thousand words</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200326/TeX笔记中的内容.jpeg" alt=""></p><p>这些问题都比较常见（不然怎么叫FAQ呢——也许上图的不算常见吧），回过头来查找的机率很高。显然，在纷繁复杂的文字中凭肉眼寻找关键字是低效的，即使是祭出<code>grep</code>，用正则表达式这样的大杀器来查找也不是特别称手——因为并不知道怎样的正则表达式可以匹配到寻找的内容——也许多写了关键词，也许少写了，也许顺序不对。</p><p>对于搜索这类非结构的文字资料来说，全文检索是一个更好的选择，因此，我是把这些内容丢进ElasticSearch里再查找的。</p><h1 id="解析并导入到ElasticSearch"><a href="#解析并导入到ElasticSearch" class="headerlink" title="解析并导入到ElasticSearch"></a>解析并导入到ElasticSearch</h1><a id="more"></a><p>FAQ中的每一个条目，都对应ElasticSearch中的一个文档，它们都存储在索引<code>faq</code>中。一个文档有如下的字段：</p><ol><li><code>answer</code>，即问题的答案；</li><li><code>path</code>，文件绝对路径，表示文档来自于哪一个文件中的条目；</li><li><code>question</code>，即问题的描述；</li><li><code>questionLineNum</code>，即问题存在于文件的第几行。</li></ol><p>解析这些文件的逻辑也很简单：每当读入行首为星号的一行后（这一行即为问题），便继续读入后续的每一行直到再次遇到行首为星号的行为止，这些后续读入的行组成了这个问题的答案。有了问题和答案，便可以导入到ElasticSearch中。最终的脚本如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'co-request'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseFaqOrg</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(path).toString(<span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="keyword">const</span> lines = content.split(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">const</span> qas = [];</span><br><span class="line">  <span class="keyword">let</span> answer = [];</span><br><span class="line">  <span class="keyword">let</span> lineNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">let</span> question;</span><br><span class="line">  <span class="keyword">let</span> questionLineNum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">    lineNum += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (line.startsWith(<span class="string">'*'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mode === <span class="string">'answer'</span>) &#123;</span><br><span class="line">        <span class="comment">// 在遇到星号的时候模式已经处于answer中，说明在此之前还有未处理的QA</span></span><br><span class="line">        qas.push(&#123;</span><br><span class="line">          answer: answer.join(<span class="string">'\n'</span>),</span><br><span class="line">          path,</span><br><span class="line">          question,</span><br><span class="line">          questionLineNum</span><br><span class="line">        &#125;);</span><br><span class="line">        answer = [];</span><br><span class="line">        question = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mode = <span class="string">'question'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mode = <span class="string">'answer'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mode === <span class="string">'answer'</span>) &#123;</span><br><span class="line">      answer.push(line);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      question = line;</span><br><span class="line">      questionLineNum = lineNum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (question) &#123;</span><br><span class="line">    qas.push(&#123;</span><br><span class="line">      answer: answer.join(<span class="string">'\n'</span>),</span><br><span class="line">      question</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(JSON.stringify(qas, null, 2));</span></span><br><span class="line">  <span class="keyword">return</span> qas;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dropFaq</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> request(&#123;</span><br><span class="line">    method: <span class="string">'delete'</span>,</span><br><span class="line">    url: <span class="string">'http://localhost:9200/faq'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重建faq索引并写入全量的笔记数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line">  <span class="keyword">await</span> dropFaq();</span><br><span class="line">  <span class="keyword">const</span> dir = <span class="string">'/Users/liutos/Documents/Projects/my_note/faq/'</span>;</span><br><span class="line">  <span class="keyword">const</span> basenames = fs.readdirSync(dir);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> basename <span class="keyword">of</span> basenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> path = dir + basename;</span><br><span class="line">    <span class="keyword">const</span> type = basename.match(<span class="regexp">/(.*)\.org/</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> qas = parseFaqOrg(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> qa <span class="keyword">of</span> qas) &#123;</span><br><span class="line">      <span class="keyword">await</span> request(&#123;</span><br><span class="line">        body: qa,</span><br><span class="line">        json: <span class="literal">true</span>,</span><br><span class="line">        method: <span class="string">'post'</span>,</span><br><span class="line">        url: <span class="string">'http://localhost:9200/faq/_doc'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`文件<span class="subst">$&#123;path&#125;</span>处理完毕`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果想知道我是如何在Emacs中查询这些FAQ的，可以参见<a href="http://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/">《在Emacs中搭建笔记查阅系统的尝试》</a>这篇文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管我最近开始用&lt;a href=&quot;https://github.com/tamlok/vnote&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VNote&lt;/a&gt;做读书或读在线文档的笔记，但更多的时候，我把经验型知识都记录在一个名为&lt;code&gt;my_note&lt;/code&gt;的Git仓库中。这个仓库中有许多.org`文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TeX.org&lt;/code&gt;，记录与&lt;code&gt;LaTeX&lt;/code&gt;相关的问题和解决方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asm.org&lt;/code&gt;，记录的是与编写汇编语言程序相关的问题和解决办法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cl.org&lt;/code&gt;，记录的是与编写Common Lisp代码相关的问题和解决办法；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些内容被我称为FAQ。尽管不同的文件记载着不同方面的内容，但它们的格式是一致的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个文件都以org-mode的语法书写；&lt;/li&gt;
&lt;li&gt;文件中只有一级条目，没有嵌套；&lt;/li&gt;
&lt;li&gt;每一个条目的标题就是一个问题的表述，下方的文字则是这个问题的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A picture is worth a thousand words&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200326/TeX笔记中的内容.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些问题都比较常见（不然怎么叫FAQ呢——也许上图的不算常见吧），回过头来查找的机率很高。显然，在纷繁复杂的文字中凭肉眼寻找关键字是低效的，即使是祭出&lt;code&gt;grep&lt;/code&gt;，用正则表达式这样的大杀器来查找也不是特别称手——因为并不知道怎样的正则表达式可以匹配到寻找的内容——也许多写了关键词，也许少写了，也许顺序不对。&lt;/p&gt;
&lt;p&gt;对于搜索这类非结构的文字资料来说，全文检索是一个更好的选择，因此，我是把这些内容丢进ElasticSearch里再查找的。&lt;/p&gt;
&lt;h1 id=&quot;解析并导入到ElasticSearch&quot;&gt;&lt;a href=&quot;#解析并导入到ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;解析并导入到ElasticSearch&quot;&gt;&lt;/a&gt;解析并导入到ElasticSearch&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>弥补org-refile的不足</title>
    <link href="https://liutos.github.io/2020/03/21/%E5%BC%A5%E8%A1%A5org-refile%E7%9A%84%E4%B8%8D%E8%B6%B3/"/>
    <id>https://liutos.github.io/2020/03/21/弥补org-refile的不足/</id>
    <published>2020-03-21T09:10:57.000Z</published>
    <updated>2020-03-21T09:12:59.657Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A#%E6%90%9C%E9%9B%86" target="_blank" rel="noopener">GTD</a>的第一条原则是“搜集”，为此我有一个<code>inbox.org</code>文件，专门记录所有的新想法、新任务。我会在每晚的固定时间处理其中的内容——有些可以马上开始做并做完，更多的则是移动到其它<code>.org</code>文件中，等待排期。</p><p>org-mode有一个内置的快捷键<code>C-c C-w</code>，专门完成将条目（org-mode的术语，即<code>.org</code>文件中带星号前缀的一行，参见<a href="https://orgmode.org/worg/org-glossary.html#entry" target="_blank" rel="noopener">An Explanation of Basic Org-Mode Concepts</a>）移动到其它<code>.org</code>文件的需求，但它有一个缺陷——不能把条目移动到其它<code>.org</code>文件的顶层，而这是我经常需要做的。</p><p>为了移动到顶层，需要：</p><ol><li>使用<code>org-cut-subtree</code>命令剪切当前条目（其实还会包括条目的子节点，但<code>inbox.org</code>中的条目基本上都没有子节点）；</li><li>打开目标的<code>.org</code>文件；</li><li>将光标定位到文件末尾；</li><li>使用<code>org-paste-subtree</code>命令粘贴条目。</li></ol><p>为了轻松完成上述四个步骤，<code>org-refile-to-eof</code>函数应运而生。</p><a id="more"></a><h1 id="org-refile-to-eof函数"><a href="#org-refile-to-eof函数" class="headerlink" title="org-refile-to-eof函数"></a>org-refile-to-eof函数</h1><p>废话不多说，直接亮相吧</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 定义一个Helm的source，以便选择要粘贴的.org文件</span></span><br><span class="line">(<span class="name">defvar</span> *org-refile-eof--helm-source* <span class="literal">nil</span></span><br><span class="line">  <span class="string">"用于提供目标.org文件下拉菜单的来源"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;; 将当前条目剪切并粘贴到某个目标.org文件的末尾</span></span><br><span class="line">(<span class="name">defun</span> org-refile-to-eof ()</span><br><span class="line">  <span class="string">"将当前条目剪切到一个.org文件的末尾。"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  <span class="comment">;; 先调用Helm获取目标.org文件。这里需要处理没有选中任何文件的情况</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">path</span> (<span class="name">helm</span> <span class="symbol">:sources</span> '(*org-refile-eof--helm-source*))))</span><br><span class="line">    (<span class="name">when</span> path</span><br><span class="line">      (<span class="name">org-cut-subtree</span>)</span><br><span class="line">      (<span class="name">save-excursion</span></span><br><span class="line">        <span class="comment">;; 打开选中的文件的buffer，并移动到最后</span></span><br><span class="line">        (<span class="name">find-file</span> path)</span><br><span class="line">        (<span class="name">end-of-buffer</span>)</span><br><span class="line">        <span class="comment">;; 调用org-paste-subtree粘贴进去</span></span><br><span class="line">        (<span class="name">org-paste-subtree</span>)))))</span><br></pre></td></tr></table></figure><p>变量<code>*org-refile-eof--helm-source*</code>定义了<code>helm</code>函数所要求的下拉列表名称、选项，以及选中后的处理逻辑（Helm的使用可以从<a href="http://wikemacs.org/wiki/How_to_write_helm_extensions" target="_blank" rel="noopener">How to write helm extension</a>入门）。在我的环境中，它的值是</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> *org-refile-eof--helm-source*</span><br><span class="line">      '((name . <span class="string">"refile到下列的哪个文件"</span>)</span><br><span class="line">        (candidates . org-agenda-files)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    candidate))))</span><br></pre></td></tr></table></figure><p>现在，只需要敲入<code>M-: org-refile-to-eof RET</code>便能轻松完成之前繁琐的四个步骤。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果有迫切需求的话，我会考虑将<code>org-refile</code>（也就是<code>C-c C-w</code>对应的命令）和<code>org-refile-to-eof</code>合并在一起。例如，按下<code>C-c C-w</code>时调用的是<code>org-refile</code>，而按下<code>C-u C-c C-w</code>时调用的则是<code>org-refile-to-eof</code>，想想也有点小激动呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A#%E6%90%9C%E9%9B%86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GTD&lt;/a&gt;的第一条原则是“搜集”，为此我有一个&lt;code&gt;inbox.org&lt;/code&gt;文件，专门记录所有的新想法、新任务。我会在每晚的固定时间处理其中的内容——有些可以马上开始做并做完，更多的则是移动到其它&lt;code&gt;.org&lt;/code&gt;文件中，等待排期。&lt;/p&gt;
&lt;p&gt;org-mode有一个内置的快捷键&lt;code&gt;C-c C-w&lt;/code&gt;，专门完成将条目（org-mode的术语，即&lt;code&gt;.org&lt;/code&gt;文件中带星号前缀的一行，参见&lt;a href=&quot;https://orgmode.org/worg/org-glossary.html#entry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;An Explanation of Basic Org-Mode Concepts&lt;/a&gt;）移动到其它&lt;code&gt;.org&lt;/code&gt;文件的需求，但它有一个缺陷——不能把条目移动到其它&lt;code&gt;.org&lt;/code&gt;文件的顶层，而这是我经常需要做的。&lt;/p&gt;
&lt;p&gt;为了移动到顶层，需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;org-cut-subtree&lt;/code&gt;命令剪切当前条目（其实还会包括条目的子节点，但&lt;code&gt;inbox.org&lt;/code&gt;中的条目基本上都没有子节点）；&lt;/li&gt;
&lt;li&gt;打开目标的&lt;code&gt;.org&lt;/code&gt;文件；&lt;/li&gt;
&lt;li&gt;将光标定位到文件末尾；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;org-paste-subtree&lt;/code&gt;命令粘贴条目。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了轻松完成上述四个步骤，&lt;code&gt;org-refile-to-eof&lt;/code&gt;函数应运而生。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>程序员的记账工具——ledger与ledger-mode</title>
    <link href="https://liutos.github.io/2020/03/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%AE%B0%E8%B4%A6%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94ledger%E4%B8%8Eledger-mode/"/>
    <id>https://liutos.github.io/2020/03/19/程序员的记账工具——ledger与ledger-mode/</id>
    <published>2020-03-19T14:40:01.000Z</published>
    <updated>2020-03-19T14:44:49.754Z</updated>
    
    <content type="html"><![CDATA[<p>上大学后不久我开始用挖财记账，当时记得很随意，不会去追究一些不知道花在哪里的钱，不时就要强行修正账户余额，就这么一直用到了2019年中。后来挖财的启动时间越来越长，同时我不想看启动时的广告，便动了换记账软件的念头。</p><p>本想着试试<a href="https://wiz.money/" target="_blank" rel="noopener">MoneyWiz</a>，但其价格令人望而却步，于是决定继续物色免费的记账工具，不久便遇到了<a href="https://www.gnucash.org/index.phtml?lang=zh_CN" target="_blank" rel="noopener">GnuCash</a>。由于它是GNU出品的，让我对其一开始便比较有好感，加上想尝试一下复式记账，便在同年9月份换到了GnuCash上。</p><p>可惜好景不长，我很快便发现了GnuCash的不足：</p><ol><li>启动速度随着录入数据的增多显著变慢；</li><li>UI不够美观；</li><li>比较依赖鼠标操作；</li><li>交易时间的精度只到天，且无法轻松调整一笔交易的位置——这一点是我尤其在意的，因为着意味着一旦我有一笔交易漏记了，再追加回去后，整个账本的交易数据次序也与银行记录的不一致了。</li></ol><p>于是我抛弃了GnuCash，投向了ledger（以及ledger-mode）的怀抱。</p><h1 id="ledger和ledger-mode"><a href="#ledger和ledger-mode" class="headerlink" title="ledger和ledger-mode"></a>ledger和ledger-mode</h1><a id="more"></a><h2 id="ledger"><a href="#ledger" class="headerlink" title="ledger"></a>ledger</h2><p><a href="https://www.ledger-cli.org/" target="_blank" rel="noopener">ledger</a>是一个基于复式记账的、生成财务报表的命令行程序——它不具备录入的功能，它只生成报表。</p><p>要使用ledger，必须先将交易数据按它的语法写在一个文本文件中，然后才用ledger读取这个文件，生成各种各样的报表。百闻不如一见，下图便是ledger生成的报表</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/WX20200308-213943@2x.jpeg" alt=""></p><h2 id="ledger-mode"><a href="#ledger-mode" class="headerlink" title="ledger-mode"></a>ledger-mode</h2><p>记录交易数据的源文件是纯文本格式的，可以用任何文本编辑器（text editor，不是word processor）来编辑。如果打算用Emacs，那么就不容错过<a href="https://github.com/ledger/ledger-mode" target="_blank" rel="noopener">ledger-mode</a>了。</p><p>ledger-mode是一个Emacs主模式，为编辑ledger的源文件（一般以<code>ledger</code>为后缀名）提供诸多便利。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/交易明细源文件.jpeg" alt=""></p><p>比如在上图中，ledger提供了语法高亮：日期（<code>2020-03-04</code>）和描述（<code>利口福</code>）是红色的，金额（<code>-32</code>）和货币（<code>CNY</code>）是紫色的，注释（分号及其后面的内容）是灰色的。ledger-mode还提供自动缩进，在输入了<code>利口福</code>并回车后，光标会自动定位到字母<code>L</code>的位置，下一行也是如此——连续敲入两个回车得到一行空行，标志着一笔交易记录结束。ledger-mode还支持在Emacs内查看ledger输出的报表（见下文）。</p><h1 id="ledger的优势"><a href="#ledger的优势" class="headerlink" title="ledger的优势"></a>ledger的优势</h1><p>用ledger记账至少有以下优势：</p><ol><li>交易数据保存在本地，有利于保护用户的隐私；</li><li>交易数据保存为纯文本文件，用户可以依自己的喜好选择编辑工具（比如我就喜欢用Emacs），即使哪天ledger没法用了，这些数据也依旧可以查看；</li><li>ledger支持自由定制符合个人习惯的资产和支出的层级。例如，我在<code>Assets</code>账户下细分了<code>Checking</code>和<code>Investment</code>子账户分别囊括消费和投资账户；<code>Checking</code>下细分了三个储蓄卡、微信零钱，及支付宝余额账户；<code>Investment</code>下细分了<code>Fund</code>和<code>WMP</code>，分别表示基金和银行理财产品；<code>Expense</code>下有一个<code>Food</code>，从上面的截图中可以看到，<code>Food</code>下进一步分了十个子账户——只要愿意，就可以随意定制账户名称和层级；</li><li>ledger支持给每一笔交易添加<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Metadata" target="_blank" rel="noopener">元数据</a>，其中一种便是<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Metadata-tags" target="_blank" rel="noopener">tag</a>（标签）。tag增强了ledger生成报表的灵活度，比如我给在公司点外卖的支出打上<code>:公司:</code>的tag后，便可以让ledger只生成在公司就餐的支出报表；</li></ol><h1 id="ledger的用法"><a href="#ledger的用法" class="headerlink" title="ledger的用法"></a>ledger的用法</h1><h2 id="初始化账户"><a href="#初始化账户" class="headerlink" title="初始化账户"></a>初始化账户</h2><p>用ledger记账，要先初始化每个账户的余额。基于复式记账的原则，ledger要求每一笔交易中所有账户的金额变化之和为0，因此若要往储蓄卡资产账户中“充值”，就必须从另一个账户中减去等额的钱。在ledger中，这个“另一个账户”便是<code>Equity</code>。（在ledger的在线文档中有一个章节<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Understanding-Equity" target="_blank" rel="noopener">Understanding Equity</a>可以帮助理解）。</p><p>所以，初始化账户余额就是添加一笔交易，将与账户余额等量的钱从<code>Equity:Opening Balance</code>流到<code>Assets</code>下的细分账户中，如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/初始化账户.jpeg" alt=""></p><p>尽管在上图中，金额<code>123</code>后的货币为<code>CNY</code>，但ledger并不理解这三个字母是否真的为合法的货币名称——ledger只要求用户指定了即可。（可以参见ledger在线文档的<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Commodities-and-Currencies" target="_blank" rel="noopener">Commodities and Currencies</a>章节）</p><p>PS：在上图中没有明确写出<code>Equity:Opening Balance</code>的变化为<code>-123 CNY</code>，是因为ledger足够“聪明”，可以自己补足这个信息。</p><p>现在可以用ledger输出报表了</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/第一次查看资产余额.jpeg" alt=""></p><h2 id="记录第一笔交易"><a href="#记录第一笔交易" class="headerlink" title="记录第一笔交易"></a>记录第一笔交易</h2><p>有了钱便可以开始买买买了。假设早餐在楼下肠粉店花了6块钱吃了一份鸡蛋肠，可以记为</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/记录第一笔早餐消费.jpeg" alt=""></p><p>用ledger输出新的资产报表</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/一笔交易后的总资产.jpeg" alt=""></p><p>还可以用ledger输出支出账户的明细，示例代码为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledger -f a.ledger register 'Expense'</span><br></pre></td></tr></table></figure><h2 id="其它报表命令"><a href="#其它报表命令" class="headerlink" title="其它报表命令"></a>其它报表命令</h2><p>除了查看资产余额和支出明细之外，我常用的报表还包括：</p><ol><li><code>ledger -f a.txt balance ^assets and \( not 公积金 \) or ^liabilities</code>，查看不含公积金的资产和负债的余额，主要用于核对账本（<code>a.txt</code>文件）与银行卡、信用卡余额是否一致；</li><li><code>ledger -S &#39;-date&#39; -f ~/Dropbox/Accounting/a.txt register Liabilities</code>，查看信用卡的交易明细，用于在账单日核对银行的信用卡账单明细。参数<code>-S &#39;date&#39;表示按日期由近及远、从上往下排序</code>；</li><li><code>ledger -e 10/01 -f a.txt balance &#39;^Asset&#39; and \( not &#39;公积金&#39; \) or &#39;^Liabilities&#39;</code>，统计至上月末为止的净资产（资产减去负债），用于了解自己的资产是上升还是下降的趋势。参数<code>-e 10/01</code>表示计算范围截止于10月1日——每次运行时需要调整为本月一号；</li><li><code>ledger -b 11/01 -e 11/30 -f a.txt balance &#39;^Expense:Food&#39;</code>，统计上个月在用餐方面的总支出，用于核对上个月的饮食开支是否超支。参数<code>-b 11/01</code>表示计算范围开始于11月1日——每次运行时需要调整为上个月一号。</li></ol><h3 id="在Emacs中查看报表"><a href="#在Emacs中查看报表" class="headerlink" title="在Emacs中查看报表"></a>在Emacs中查看报表</h3><p>ledger-mode允许用户直接在Emacs中查看报表：先按下组合键<code>C-c C-o C-r</code>，然后在minibuffer中输入报表名称，最后输入完整的调用ledger的命令即可。Emacs会打开一个新的buffer展示ledger的输出</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/在Emacs内查看ledger报表的效果.jpeg" alt=""></p><h2 id="账户划分方法"><a href="#账户划分方法" class="headerlink" title="账户划分方法"></a>账户划分方法</h2><p>ledger中划分账户的自由度很高，以下是我划分的一部分，供读者参考。</p><p>首先按照ledger在线文档的<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Structuring-your-Accounts" target="_blank" rel="noopener">Structuring your Accounts</a>的要求，划分出五个顶层的账户：</p><ol><li><code>Assets</code>，表示用户的资产；</li><li><code>Equity</code>，用于初始化时作为账户余额的来源；</li><li><code>Expense</code>，表示用户的支出；</li><li><code>Income</code>，表示用户的收入；</li><li><code>Liabilities</code>，表示用户的负债。</li></ol><p>在<code>Assets</code>账户下，我还划分了</p><ol><li><code>Assets:Checking</code>，表示用于消费的账户，其下还划分了储蓄卡账户、微信零钱、支付宝余额账户；</li><li><code>Assets:Investment:Fund</code>，表示购买的基金，其下为不同的基金划分不同的账户；</li><li><code>Assets:Investment:WMP</code>，表示购买的理财产品，其下按理财产品代号划分不同的账户。</li></ol><p>在<code>Expense</code>账户下，我细分了：</p><ol><li><code>Expense:Clothes</code>，表示衣服鞋饰的支出；</li><li><code>Expense:Education</code>，表示书籍、文具的支出；</li><li><code>Expense:Entertainment</code>，表示电影、游戏等娱乐方面的支出；</li><li><code>Expense:Food</code>，表示买菜、就餐方面的支出。</li></ol><p>还有其它的许多账户，就不一一赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上大学后不久我开始用挖财记账，当时记得很随意，不会去追究一些不知道花在哪里的钱，不时就要强行修正账户余额，就这么一直用到了2019年中。后来挖财的启动时间越来越长，同时我不想看启动时的广告，便动了换记账软件的念头。&lt;/p&gt;
&lt;p&gt;本想着试试&lt;a href=&quot;https://wiz.money/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MoneyWiz&lt;/a&gt;，但其价格令人望而却步，于是决定继续物色免费的记账工具，不久便遇到了&lt;a href=&quot;https://www.gnucash.org/index.phtml?lang=zh_CN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GnuCash&lt;/a&gt;。由于它是GNU出品的，让我对其一开始便比较有好感，加上想尝试一下复式记账，便在同年9月份换到了GnuCash上。&lt;/p&gt;
&lt;p&gt;可惜好景不长，我很快便发现了GnuCash的不足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动速度随着录入数据的增多显著变慢；&lt;/li&gt;
&lt;li&gt;UI不够美观；&lt;/li&gt;
&lt;li&gt;比较依赖鼠标操作；&lt;/li&gt;
&lt;li&gt;交易时间的精度只到天，且无法轻松调整一笔交易的位置——这一点是我尤其在意的，因为着意味着一旦我有一笔交易漏记了，再追加回去后，整个账本的交易数据次序也与银行记录的不一致了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是我抛弃了GnuCash，投向了ledger（以及ledger-mode）的怀抱。&lt;/p&gt;
&lt;h1 id=&quot;ledger和ledger-mode&quot;&gt;&lt;a href=&quot;#ledger和ledger-mode&quot; class=&quot;headerlink&quot; title=&quot;ledger和ledger-mode&quot;&gt;&lt;/a&gt;ledger和ledger-mode&lt;/h1&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="工具" scheme="https://liutos.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="tool" scheme="https://liutos.github.io/tags/tool/"/>
    
      <category term="accounting" scheme="https://liutos.github.io/tags/accounting/"/>
    
      <category term="double-entry accounting" scheme="https://liutos.github.io/tags/double-entry-accounting/"/>
    
      <category term="ledger" scheme="https://liutos.github.io/tags/ledger/"/>
    
      <category term="复式记账" scheme="https://liutos.github.io/tags/%E5%A4%8D%E5%BC%8F%E8%AE%B0%E8%B4%A6/"/>
    
      <category term="记账" scheme="https://liutos.github.io/tags/%E8%AE%B0%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>优化org-mode管理观影进度</title>
    <link href="https://liutos.github.io/2020/02/21/%E4%BC%98%E5%8C%96org-mode%E7%AE%A1%E7%90%86%E8%A7%82%E5%BD%B1%E8%BF%9B%E5%BA%A6/"/>
    <id>https://liutos.github.io/2020/02/21/优化org-mode管理观影进度/</id>
    <published>2020-02-21T14:14:55.000Z</published>
    <updated>2020-02-21T14:16:46.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在之前的<a href="https://liutos.github.io/2020/02/11/%E6%8F%90%E5%8D%87%E6%9D%A1%E7%9B%AE%E4%B8%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9/">文章</a>中，我提到自己用org-mode管理工作日午餐和晚餐要看的动画及其进度。简单来说，就是为每部动画创建同名的二级条目（它们有一个共同的一级条目叫“动画”），每当准备看新一集时，就在对应二级条目下创建形如“观看第X话”的三级条目并设为TODO。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg" alt=""></p><p>按这种方式，在《钢炼FA》下最终会创建出64个三级条目——而可怜的Emacs甚至一屏只能显示50行！这些“阅后即焚”的三级条目浪费了其它（或许）更有价值的内容的展示空间，因此最好将每一个切换至 <code>DONE</code>状态的三级条目藏起来。</p><p>org-mode可以“<a href="https://orgmode.org/manual/Internal-archiving.html" target="_blank" rel="noopener">internal archive</a>”一个条目，但这样仍无法节省它们占据的纵向空间。后来，我想到了org-mode的<a href="https://orgmode.org/manual/Drawers.html" target="_blank" rel="noopener">drawer</a>特性。</p><a id="more"></a><h1 id="思路及函数定义"><a href="#思路及函数定义" class="headerlink" title="思路及函数定义"></a>思路及函数定义</h1><p>基于drawer的方案很直接：在<code>org-after-todo-state-change-hook</code>中新增一个钩子。每当一个条目切换至<code>DONE</code>状态、并满足一些条件（比如条目的heading符合“观看第X话”这个模式）时，就将heading的文本与当前时间一起追加到父级条目下、名为“观看进度”的drawer的末端。</p><p>org-mode没有内置的函数可以往某个条目的某个drawer中追加内容，需要自行利用“移动光标”和“字符串搜索”来实现。最终的成品如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">require</span> 'cl)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-org-move-episode-to-drawer ()</span><br><span class="line">  <span class="string">"往上级heading的drawer中插入一个内容，并删除当前heading。"</span></span><br><span class="line">  <span class="comment">;; 用cl-block来实现nonlocal-exit</span></span><br><span class="line">  (<span class="name">cl-block</span> lt-org-move-episode-to-drawer</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">state</span> org-state))</span><br><span class="line">      (<span class="name">unless</span> (<span class="name">string=</span> state <span class="string">"DONE"</span>)</span><br><span class="line">        (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer)))</span><br><span class="line"></span><br><span class="line">    (<span class="name">let</span> ((<span class="name">tags</span> (<span class="name">org-get-tags-at</span>))</span><br><span class="line">          (<span class="name">text</span> (<span class="name">nth</span> <span class="number">4</span> (<span class="name">org-heading-components</span>))))</span><br><span class="line">      <span class="comment">;; 只处理内容以“观看”开头、带有“动画”标签的heading</span></span><br><span class="line">      (<span class="name">unless</span> (<span class="name">and</span> (<span class="name">or</span> (<span class="name">string-prefix-p</span> <span class="string">"观看"</span> text)</span><br><span class="line">                       (<span class="name">string-prefix-p</span> <span class="string">"继续阅读"</span> text))</span><br><span class="line">                   (<span class="name">or</span> (<span class="name">member</span> <span class="string">"动画"</span> tags)</span><br><span class="line">                       (<span class="name">member</span> <span class="string">"阅读"</span> tags)))</span><br><span class="line">        (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer))</span><br><span class="line"></span><br><span class="line">      (<span class="name">save-excursion</span></span><br><span class="line">        (<span class="name">let</span> (<span class="name">current-position</span>)</span><br><span class="line">          <span class="comment">;; 记下当前的位置，之后搜索的时候到这里为止</span></span><br><span class="line">          (<span class="name">setq</span> current-position (<span class="name">point</span>))</span><br><span class="line">          <span class="comment">;; 往上走一级，以便寻找一个名字叫做“观看进度”的drawer</span></span><br><span class="line">          (<span class="name">widen</span>)</span><br><span class="line">          (<span class="name">outline-up-heading</span> <span class="number">1</span>)</span><br><span class="line">          (<span class="name">unless</span> (<span class="name">search-forward</span> <span class="string">":观看进度:"</span> current-position <span class="literal">t</span>)</span><br><span class="line">            (<span class="name">message</span> <span class="string">"请自行创建“观看进度”的drawer"</span>)</span><br><span class="line">            (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer))</span><br><span class="line"></span><br><span class="line">          <span class="comment">;; 继续往前找到:END:的标记</span></span><br><span class="line">          (<span class="name">unless</span> (<span class="name">search-forward</span> <span class="string">":END:"</span> current-position <span class="literal">t</span>)</span><br><span class="line">            (<span class="name">message</span> <span class="string">"请确保有完整的“观看进度”的drawer"</span>)</span><br><span class="line">            (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer))</span><br><span class="line">          <span class="comment">;; 往左走五步</span></span><br><span class="line">          (<span class="name">backward-char</span> <span class="number">5</span>)</span><br><span class="line">          <span class="comment">;; 开辟一行新的，然后把刚刚完成的任务的内容和时间戳放进来</span></span><br><span class="line">          (<span class="name">org-open-line</span> <span class="number">1</span>)</span><br><span class="line">          (<span class="name">insert</span> (<span class="name">format</span> <span class="string">"“%s” DONE at %s"</span> text (<span class="name">current-time-string</span>)))))</span><br><span class="line">      (<span class="name">org-cut-subtree</span>))))</span><br></pre></td></tr></table></figure><p>别忘了加入到钩子中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'org-after-todo-state-change-hook 'lt-org-move-episode-to-drawer <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>lt-org-move-episode-to-drawer</code>的缺点在于它会删掉切换至<code>DONE</code>状态的条目，因此这个观看记录在<code>*Org Agenda*</code>中会完全消失——这一点尚能接受。</p><p>此外，上面的<code>defun</code>完全可以修改为<code>cl-defun</code>，并移除<code>cl-block</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;在之前的&lt;a href=&quot;https://liutos.github.io/2020/02/11/%E6%8F%90%E5%8D%87%E6%9D%A1%E7%9B%AE%E4%B8%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9/&quot;&gt;文章&lt;/a&gt;中，我提到自己用org-mode管理工作日午餐和晚餐要看的动画及其进度。简单来说，就是为每部动画创建同名的二级条目（它们有一个共同的一级条目叫“动画”），每当准备看新一集时，就在对应二级条目下创建形如“观看第X话”的三级条目并设为TODO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;按这种方式，在《钢炼FA》下最终会创建出64个三级条目——而可怜的Emacs甚至一屏只能显示50行！这些“阅后即焚”的三级条目浪费了其它（或许）更有价值的内容的展示空间，因此最好将每一个切换至 &lt;code&gt;DONE&lt;/code&gt;状态的三级条目藏起来。&lt;/p&gt;
&lt;p&gt;org-mode可以“&lt;a href=&quot;https://orgmode.org/manual/Internal-archiving.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;internal archive&lt;/a&gt;”一个条目，但这样仍无法节省它们占据的纵向空间。后来，我想到了org-mode的&lt;a href=&quot;https://orgmode.org/manual/Drawers.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;drawer&lt;/a&gt;特性。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>免除频繁输入ssh密码的烦恼</title>
    <link href="https://liutos.github.io/2020/02/19/%E5%85%8D%E9%99%A4%E9%A2%91%E7%B9%81%E8%BE%93%E5%85%A5ssh%E5%AF%86%E7%A0%81%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    <id>https://liutos.github.io/2020/02/19/免除频繁输入ssh密码的烦恼/</id>
    <published>2020-02-19T03:40:18.000Z</published>
    <updated>2020-02-19T03:42:19.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在入手MacBook Pro前，我的开发环境主要是一个运行在VirtualBox中的Mint发行版。在这个系统中，只要运行一次<code>git push</code>并输入passphrase（下称密码）后，之后便不再需要输入了——即使ssh登录远程机器也是如此。</p><p>但用上Mac后发现，这里的ssh没有这个方便的特性——每次运行<code>git push</code>或<code>ssh</code>，都需要输入密码，颇不方便。</p><p>为了避免一遍又一遍地输入密码，每次登录后，我都会运行<code>ssh-add</code>来一劳永逸地解决问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>自从升级到macOS Catalina后，如果在合盖睡眠前没有注销的话，下次开盖唤醒极有可能卡死在登录界面。无奈之下，我每天都需要注销并在第二天重新登录，以至于每天都得运行<code>ssh-add</code>并输入密码。久而久之，这也挺烦人的。</p><h1 id="一次失败的优化"><a href="#一次失败的优化" class="headerlink" title="一次失败的优化"></a>一次失败的优化</h1><a id="more"></a><p>为了省却每次都输入长达14个字符的密码的烦恼，我想到了<code>expect(1)</code>，这是一种可以交互式地控制其它命令的脚本语言。遗憾的是，经过一番折腾，仍然没办法成功让expect把密码输入给<code>ssh-add</code>，我只好继续寻找其它的办法。</p><h1 id="一次成功的优化"><a href="#一次成功的优化" class="headerlink" title="一次成功的优化"></a>一次成功的优化</h1><p>某天在阅读<code>ssh-add</code>的<code>man</code>文档时，了解到原来<code>ssh-add</code>有一个<code>-K</code>选项，可以在添加身份到<code>ssh-agent</code>时，将密码存储到用户的keychain中。同时还有一个<code>-A</code>选项，可以让<code>ssh-add</code>使用来自于keychain的密码——这意味着可以不用一遍又一遍地输入！</p><p>那么接下来要做的事情已经很清楚了。先手动运行一次带<code>-K</code>选项的<code>ssh-add</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>并输入密码——这将会是在Mac上的最后一次输入。再用<code>-A</code>选项调用<code>ssh-add</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ssh-add -A ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>我把上面这段代码保存为文件<code>/Users/liutos/SourceCode/shell/auto_ssh_add/auto_ssh_add.sh</code>，它很快就会被用到。最后，写一个Launchd的配置文件<code>~/Library/LaunchAgents/com.liutos.tools.sshAdd.plist</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.liutos.tools.sshAdd<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>Program<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/liutos/SourceCode/shell/auto_ssh_add/auto_ssh_add.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/auto_ssh_add.log<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/auto_ssh_add.err<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从现在起，再也不需要一遍又一遍地输入ssh的密码了——一次也不需要。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>要是有哪些读者朋友成功地用<code>expect</code>实现自动输入密码的，还望不吝赐教;)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;在入手MacBook Pro前，我的开发环境主要是一个运行在VirtualBox中的Mint发行版。在这个系统中，只要运行一次&lt;code&gt;git push&lt;/code&gt;并输入passphrase（下称密码）后，之后便不再需要输入了——即使ssh登录远程机器也是如此。&lt;/p&gt;
&lt;p&gt;但用上Mac后发现，这里的ssh没有这个方便的特性——每次运行&lt;code&gt;git push&lt;/code&gt;或&lt;code&gt;ssh&lt;/code&gt;，都需要输入密码，颇不方便。&lt;/p&gt;
&lt;p&gt;为了避免一遍又一遍地输入密码，每次登录后，我都会运行&lt;code&gt;ssh-add&lt;/code&gt;来一劳永逸地解决问题&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-add ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;自从升级到macOS Catalina后，如果在合盖睡眠前没有注销的话，下次开盖唤醒极有可能卡死在登录界面。无奈之下，我每天都需要注销并在第二天重新登录，以至于每天都得运行&lt;code&gt;ssh-add&lt;/code&gt;并输入密码。久而久之，这也挺烦人的。&lt;/p&gt;
&lt;h1 id=&quot;一次失败的优化&quot;&gt;&lt;a href=&quot;#一次失败的优化&quot; class=&quot;headerlink&quot; title=&quot;一次失败的优化&quot;&gt;&lt;/a&gt;一次失败的优化&lt;/h1&gt;
    
    </summary>
    
    
      <category term="macos" scheme="https://liutos.github.io/tags/macos/"/>
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://liutos.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>重构vertical-let，支持解构</title>
    <link href="https://liutos.github.io/2020/02/12/%E9%87%8D%E6%9E%84vertical-let%EF%BC%8C%E6%94%AF%E6%8C%81%E8%A7%A3%E6%9E%84/"/>
    <id>https://liutos.github.io/2020/02/12/重构vertical-let，支持解构/</id>
    <published>2020-02-12T07:36:46.000Z</published>
    <updated>2020-02-12T07:41:42.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《实战Common Lisp》系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。MAKE COMMON LISP GREAT AGAIN。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>因为觉得Common Lisp原生的<code>let</code>操作符在许多时候不够好用，我编写了<code>vertical-let</code>。（详情可以参见这篇<a href="https://liutos.github.io/2019/03/13/%E6%9B%B4%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%9A%84let%E2%80%94%E2%80%94vertical-let/">文章</a>）比起原生的<code>let</code>，<code>vertical-let</code>的优势在于：</p><ol><li>有效减少代码的缩进——尤其是嵌套使用<code>let</code>的时候；</li><li>方便增减binding，对其余代码的布局没有影响。</li></ol><p>除了<code>let</code>，<code>destructuring-bind</code>也是一个常用的声明binding的语法。但如果用在<code>vertical-let</code>中的话，会打乱原有的代码布局。比如原本的代码为</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line"> <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line"> <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line"> (<span class="name">+</span> a b))</span><br></pre></td></tr></table></figure><p>如果加入<code>destructuring-bind</code>，就会导致从它之后的代码都增加了一级缩进</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line"> <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line"> <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line"> (<span class="name">destructuring-bind</span> (<span class="name">c</span>) '(<span class="number">3</span>)</span><br><span class="line">   (<span class="name">+</span> a b c))) <span class="comment">; &lt;- 这一行开始多了一级缩进，之后的代码全都受到影响</span></span><br></pre></td></tr></table></figure><p>我更希望能写成下面这样</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line"> <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line"> <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line"> <span class="symbol">:with</span> (<span class="name">c</span>) = '(<span class="number">3</span>)</span><br><span class="line"> (<span class="name">+</span> a b c))</span><br></pre></td></tr></table></figure><p>然而<code>vertical-let</code>目前的实现方式很难支持这种新语法。</p><p>在<code>vertical-let</code>内部，将参数分成了“binding”和“form”两种类型，压入到同一个栈中，再逐一弹出处理。如果要支持展开成<code>destructuring-bind</code>，那么：</p><ol><li>如果弹出的是“binding”，就需要决定是将其与旧的合并（都是<code>let</code>的binding的情况），还是先处理已有的变量<code>bindings</code>和<code>forms</code>中的内容（这里又涉及到是组成<code>let</code>还是组成<code>destructuring-bind</code>）；</li><li>如果弹出的是“form”，也要考虑与上述场景类似的情况。</li></ol><p>可想而知，这会让<code>vertical-let</code>的代码膨胀得厉害，并且显得很混乱。因此，必须先优化一番<code>vertical-let</code>。</p><h1 id="重构vertical-let"><a href="#重构vertical-let" class="headerlink" title="重构vertical-let"></a>重构vertical-let</h1><p>新的思路是：</p><ol><li>从尾部开始遍历<code>vertical-let</code>的参数列表；</li><li>如果遍历到的元素不是符号<code>:with</code>，就认为是一个可以求值的表达式，将其压栈。显然，这个栈的元素的顺序，与<code>vertical-let</code>的参数列表的顺序是一致的，可以直接用于合成<code>let</code>表达式；</li><li>如果遍历到的元素是符号<code>:with</code>，就从栈中弹出三个元素（它们依次是变量名、等号、待求值的表达式）；</li><li>将变量名、待求值的表达式，以及栈内所有元素组成只有一个binding的的<code>let</code>表达式，重新压栈。</li></ol><p>当参数列表遍历完后，再看看这个栈：</p><ol><li>如果只有一个元素，就是<code>vertical-let</code>的展开结果；</li><li>否则，将它们作为<code>progn</code>的参数，返回一个<code>progn</code>表达式。</li></ol><h1 id="支持destructuring-bind"><a href="#支持destructuring-bind" class="headerlink" title="支持destructuring-bind"></a>支持destructuring-bind</h1><p>在上面的算法中，遇到符号<code>:with</code>后只需要构造出<code>let</code>表达式即可。为了支持展开成<code>destructuring-bind</code>，需要根据栈顶元素类型来做不同处理：</p><ol><li>如果是<code>cons</code>，就展开为<code>destructuring-bind</code>——毕竟<code>destructuring-bind</code>是无法嵌套的；</li><li>如果是<code>symbol</code>，就展开为<code>let</code>（如果栈只有一个元素并且是<code>let</code>表达式，那么可以将新的binding合并进去，减少展开后代码的缩进）。</li></ol><p>现在，可以完整地实现<code>vertical-let</code>了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> vertical-let/aux (<span class="name">forms</span>)</span><br><span class="line">  <span class="string">"将FORMS转换为基于DESTRUCTURING-BIND和LET*实现的形式。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将:WITH VAR = VAL . FORMS形式的代码转换为(LET* ((VAR VAL)) . FORMS)；</span></span><br><span class="line"><span class="string">将:WITH (VAR1 VAR2) = VAL . FORMS形式的代码转换为(DESTRUCTURING-BIND (VAR1 VAR2) VAL . FORMS)。"</span></span><br><span class="line">  (<span class="name">check-type</span> forms list)</span><br><span class="line">  (<span class="name">setf</span> forms (<span class="name">reverse</span> forms))</span><br><span class="line">  (<span class="name">let</span> (<span class="name">form</span></span><br><span class="line">        (<span class="name">stack</span> '()))</span><br><span class="line">    (<span class="name">block</span> <span class="literal">nil</span></span><br><span class="line">      (<span class="name">loop</span></span><br><span class="line">         (<span class="name">when</span> (<span class="name">null</span> forms)</span><br><span class="line">           (<span class="name">return-from</span> <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">         (<span class="name">setf</span> form (<span class="name">pop</span> forms))</span><br><span class="line">         (<span class="name">cond</span> ((<span class="name">eq</span> form <span class="symbol">:with</span>)</span><br><span class="line">                (<span class="name">let</span> ((<span class="name">place</span> (<span class="name">pop</span> stack)))</span><br><span class="line">                  <span class="comment">;; 下一个元素必须是一个名称为等号的符号</span></span><br><span class="line">                  (<span class="name">let</span> ((<span class="name">e</span> (<span class="name">pop</span> stack)))</span><br><span class="line">                    (<span class="name">assert</span> (<span class="name">symbolp</span> e))</span><br><span class="line">                    (<span class="name">assert</span> (<span class="name">string=</span> (<span class="name">symbol-name</span> e) <span class="string">"="</span>)))</span><br><span class="line">                  (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">pop</span> stack)))</span><br><span class="line">                    (<span class="name">etypecase</span> place</span><br><span class="line">                      (<span class="name">cons</span></span><br><span class="line">                       <span class="comment">;; 展开为DESTRUCTURING-BIND</span></span><br><span class="line">                       (<span class="name">setf</span> stack `((destructuring-bind ,place ,val ,@stack))))</span><br><span class="line">                      (<span class="name">symbol</span></span><br><span class="line">                       <span class="comment">;; 如果STAKC中仅有一个LET*表达式就将新的绑定合并进去，否则创建新的LET*表达式</span></span><br><span class="line">                       (<span class="name">cond</span> ((<span class="name">and</span> (<span class="name">=</span> (<span class="name">length</span> stack) <span class="number">1</span>)</span><br><span class="line">                                   (<span class="name">consp</span> (<span class="name">car</span> stack))</span><br><span class="line">                                   (<span class="name">eq</span> (<span class="name">caar</span> stack) 'let*))</span><br><span class="line">                              (<span class="name">let*</span> ((<span class="name">form</span> (<span class="name">pop</span> stack))</span><br><span class="line">                                     (<span class="name">bindings</span> (<span class="name">second</span> form)))</span><br><span class="line">                                (<span class="name">setf</span> (<span class="name">second</span> form)</span><br><span class="line">                                      `((,place ,val) ,@bindings))</span><br><span class="line">                                (<span class="name">push</span> form stack)))</span><br><span class="line">                             (<span class="name">t</span></span><br><span class="line">                              (<span class="name">setf</span> stack `((let* ((,place ,val)) ,@stack))))))))</span><br><span class="line">                  ))</span><br><span class="line">               (<span class="name">t</span></span><br><span class="line">                (<span class="name">push</span> form stack)))))</span><br><span class="line">    </span><br><span class="line">    (<span class="name">if</span> (<span class="name">=</span> (<span class="name">length</span> stack) <span class="number">1</span>)</span><br><span class="line">        (<span class="name">car</span> stack)</span><br><span class="line">        `(progn ,@stack))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmacro</span> vertical-let* (<span class="name">&amp;body</span> body)</span><br><span class="line">  <span class="string">"不需要不停缩进的LET*"</span></span><br><span class="line">  (<span class="name">vertical-let/aux</span> body))</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>除了<code>let</code>和<code>destructuring-bind</code>，Common Lisp还提供了名为<code>multiple-value-bind</code>的宏，用于捕捉从一个函数返回的多个值。如果又要修改<code>vertical-let</code>的话，多半就是为了支持它了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《实战Common Lisp》系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。MAKE COMMON LISP GREAT AGAIN。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;因为觉得Common Lisp原生的&lt;code&gt;let&lt;/code&gt;操作符在许多时候不够好用，我编写了&lt;code&gt;vertical-let&lt;/code&gt;。（详情可以参见这篇&lt;a href=&quot;https://liutos.github.io/2019/03/13/%E6%9B%B4%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%9A%84let%E2%80%94%E2%80%94vertical-let/&quot;&gt;文章&lt;/a&gt;）比起原生的&lt;code&gt;let&lt;/code&gt;，&lt;code&gt;vertical-let&lt;/code&gt;的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有效减少代码的缩进——尤其是嵌套使用&lt;code&gt;let&lt;/code&gt;的时候；&lt;/li&gt;
&lt;li&gt;方便增减binding，对其余代码的布局没有影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了&lt;code&gt;let&lt;/code&gt;，&lt;code&gt;destructuring-bind&lt;/code&gt;也是一个常用的声明binding的语法。但如果用在&lt;code&gt;vertical-let&lt;/code&gt;中的话，会打乱原有的代码布局。比如原本的代码为&lt;/p&gt;
    
    </summary>
    
      <category term="实战CommonLisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98CommonLisp/"/>
    
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="macro" scheme="https://liutos.github.io/tags/macro/"/>
    
      <category term="宏" scheme="https://liutos.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>提升条目为第一个孩子节点</title>
    <link href="https://liutos.github.io/2020/02/11/%E6%8F%90%E5%8D%87%E6%9D%A1%E7%9B%AE%E4%B8%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9/"/>
    <id>https://liutos.github.io/2020/02/11/提升条目为第一个孩子节点/</id>
    <published>2020-02-11T03:25:46.000Z</published>
    <updated>2020-02-11T08:10:40.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我用Emacs的org-mode来管理看动画的进度</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg" alt="org-mode中的动画清单"></p><p>每个工作日的午餐和晚餐，我都会安排一部下饭动画。为了每顿饭可以看不同的动画，我的做法是：</p><a id="more"></a><ol><li>从清单的尾部选择一部动画（比如选中了《鬼灭之刃》）；</li><li>在这部动画下创建一个子节点（比如“观看第17话”），设置为TODO状态，并设定SCHEDULED属性为第二天的午餐或晚餐的时间；</li><li>把动画的条目移动到当前父节点的第一个孩子节点的位置上（也就是排到《动物狂想曲》的上面），这样接下来就不会立即再选到这部动画来看了。</li></ol><p>要移动到第一个孩子节点，可以先剪切再粘贴，也可以用org-mode提供的快捷键<code>M-↑</code>。但<code>M-↑</code>只能往上移动一级，如果要移动至第一个孩子节点的位置，就需要不停地按这个快捷键。为了简化这个步骤，我定义了一个新的命令和快捷键来代劳。</p><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>这个函数非常简单，只需要持续调用<code>M-↑</code>快捷键对应的命令，直到它出错自己结束即可。为了知道<code>M-↑</code>对应的是哪一个函数，在一个主模式为org-mode的buffer中，按下<code>C-h k</code>，再按下<code>M-↑</code>，可以看到它对应的函数为<code>org-move-subtree-up</code>。</p><p>现在，可以定义这个短小精悍的函数了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> up-to-top ()</span><br><span class="line">  <span class="string">"将当前条目一直移动到最上面"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">loop</span></span><br><span class="line">   (<span class="name">org-move-subtree-up</span>)))</span><br></pre></td></tr></table></figure><p>我把它绑定到了快捷键C-c o u上</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-key</span> org-mode-map <span class="string">"\C-cou"</span> 'up-to-top)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>用org-mode来记录动画的观看进度，会在动画的条目下创建出许多形如“观看XX话”这样的条目。如果是《钢炼》这种六十多集的动画，展开时看到这一大串子条目还是颇为震撼和困扰的。为了解决这个问题，我在org-mode中还定制了一些其它功能，下次再给大家讲解一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;我用Emacs的org-mode来管理看动画的进度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg&quot; alt=&quot;org-mode中的动画清单&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个工作日的午餐和晚餐，我都会安排一部下饭动画。为了每顿饭可以看不同的动画，我的做法是：&lt;/p&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>all-first-registers-to-strings</title>
    <link href="https://liutos.github.io/2020/01/25/all-first-registers-to-strings/"/>
    <id>https://liutos.github.io/2020/01/25/all-first-registers-to-strings/</id>
    <published>2020-01-25T12:38:09.000Z</published>
    <updated>2020-01-27T08:31:27.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《实战Common Lisp》系列的第一篇文章。本系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><del>众所周知，</del>Common Lisp没有内置多少处理字符串的函数，下面的代码便能看到所有以STRING开头的函数名：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">do-external-symbols</span> (<span class="name">s</span> <span class="symbol">:cl</span>)</span><br><span class="line">  (<span class="name">when</span> (<span class="name">and</span> (<span class="name">fboundp</span> s)</span><br><span class="line">             (<span class="name">equal</span> (<span class="name">search</span> <span class="string">"STRING"</span> (<span class="name">symbol-name</span> s)) <span class="number">0</span>))</span><br><span class="line">    (<span class="name">print</span> s)))</span><br></pre></td></tr></table></figure><p>屈指可数，而且大部分是比较两个字符串的！很多其它语言中的“标配”是不存在的，比如想要将多个字符串连接起来这么简单的功能都没有！要么自己实现，要么依赖第三方库，比如<a href="https://github.com/vindarel/cl-str" target="_blank" rel="noopener"><code>cl-str</code></a>提供的<code>join</code>函数。</p><p>标准库也没有内置正则表达式，好在有一个优秀的第三方库可以用：<a href="http://edicl.github.io/cl-ppcre/" target="_blank" rel="noopener"><code>cl-ppcre</code></a>。一种使用正则的常见需求是提取符合某种模式的内容，比如提取一篇Markdown文章中所有的图片链接。图片链接可以由下列正则括号的部分匹配：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"!\\[.*\\]\\((.*)\\)"</span></span><br></pre></td></tr></table></figure><p>在cl-ppcre中这个括号匹配的部分叫做第一个register。我想要写一个能够提取出字符串中所有符合这段正则的第一个register，分两步走：</p><ol><li>先实现一个<code>all-first-registers-to-strings</code>函数，实现通用的、提取一个字符串中所有符合某段正则的子串的第一个register的内容；</li><li>基于<code>all-first-registers-to-strings</code>实现一个<code>extract-image-paths</code>。</li></ol><a id="more"></a><h1 id="all-first-registers-to-strings"><a href="#all-first-registers-to-strings" class="headerlink" title="all-first-registers-to-strings"></a><code>all-first-registers-to-strings</code></h1><p>要实现这个函数，需要借助cl-ppcre的<code>scan</code>函数。根据<a href="http://edicl.github.io/cl-ppcre/#scan" target="_blank" rel="noopener">scan函数的文档</a>，当正则匹配成功时，它的第三、第四个返回值表示正则中register的起点和终点在字符串中的偏移——它们是两个数组，起点和终点一一对应。有了起点和终点的偏移，再使用<code>CL:SUBSEQ</code>便能提取出register对应的子串。如果要把字符串中所有匹配register的内容都拿出来，就反复调用scan函数，直到再也没有匹配成功为止。</p><p><code>all-first-registers-to-strings</code>的定义如下：</p><p><script src="https://gist.github.com/Liutos/045aa43b5b3698d7e7c460d3f0c90858.js"></script></p><ul><li>为了不停地在<code>target-string</code>中前进，用变量<code>pos</code>存储<code>scan</code>函数的第二个返回值，并作为下一次调用<code>scan</code>时的<code>start</code>参数——显然，<code>pos</code>的初始值为0；</li><li>为了跳出<code>loop</code>，使用了<code>return-from</code>直接从函数返回；</li><li>用<code>push</code>收集最终结果，再用<code>nreverse</code>处理成最终的返回值——印象中《On Lisp》也说过这是一种比较常见的手法。</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>有了<code>all-first-registers-to-strings</code>，就可以轻松实现<code>extract-image-paths</code>了：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> extract-image-paths (<span class="name">content</span>)</span><br><span class="line">  <span class="string">"从博文内容CONTENT中提取出图片的绝对路径。"</span></span><br><span class="line">  (<span class="name">all-first-registers-to-strings</span> <span class="string">"!\\[.*\\]\\((.*)\\)"</span> content))</span><br></pre></td></tr></table></figure><p>显然，这个<code>all-first-registers-to-strings</code>函数实现得很糟糕，尤其是<code>loop</code>的用法实在是太不Lispy了。Common Lisp的<code>loop</code>的用法纷繁复杂如天上的星星，多半可以用更优雅的方法来重写一遍，这个就留给各位读者作为私下的乐趣吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是《实战Common Lisp》系列的第一篇文章。本系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;&lt;del&gt;众所周知，&lt;/del&gt;Common Lisp没有内置多少处理字符串的函数，下面的代码便能看到所有以STRING开头的函数名：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;do-external-symbols&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:cl&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;when&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;and&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;fboundp&lt;/span&gt; s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             (&lt;span class=&quot;name&quot;&gt;equal&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;search&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;STRING&quot;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;symbol-name&lt;/span&gt; s)) &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;print&lt;/span&gt; s)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;屈指可数，而且大部分是比较两个字符串的！很多其它语言中的“标配”是不存在的，比如想要将多个字符串连接起来这么简单的功能都没有！要么自己实现，要么依赖第三方库，比如&lt;a href=&quot;https://github.com/vindarel/cl-str&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;cl-str&lt;/code&gt;&lt;/a&gt;提供的&lt;code&gt;join&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;标准库也没有内置正则表达式，好在有一个优秀的第三方库可以用：&lt;a href=&quot;http://edicl.github.io/cl-ppcre/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;cl-ppcre&lt;/code&gt;&lt;/a&gt;。一种使用正则的常见需求是提取符合某种模式的内容，比如提取一篇Markdown文章中所有的图片链接。图片链接可以由下列正则括号的部分匹配：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;!\\[.*\\]\\((.*)\\)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在cl-ppcre中这个括号匹配的部分叫做第一个register。我想要写一个能够提取出字符串中所有符合这段正则的第一个register，分两步走：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先实现一个&lt;code&gt;all-first-registers-to-strings&lt;/code&gt;函数，实现通用的、提取一个字符串中所有符合某段正则的子串的第一个register的内容；&lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;all-first-registers-to-strings&lt;/code&gt;实现一个&lt;code&gt;extract-image-paths&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="实战CommonLisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98CommonLisp/"/>
    
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>快速设置任务的开始时间（下）</title>
    <link href="https://liutos.github.io/2020/01/10/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://liutos.github.io/2020/01/10/快速设置任务的开始时间（下）/</id>
    <published>2020-01-10T15:12:41.000Z</published>
    <updated>2020-02-11T08:10:12.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在<a href="https://liutos.github.io/2020/01/09/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8A%EF%BC%89/">上一篇文章</a>的末尾，我说有一个更优雅的办法实现快速设置任务的开始时间，本文便来揭秘这个办法。</p><a id="more"></a><h1 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h1><blockquote><p>如果说我看得比别人更远些，那是因为我站在巨人的肩膀上。<br>——牛顿</p></blockquote><p>既要支持预设选项，又要能够方便选择，一个显而易见的办法就是使用下拉列表。要在Emacs中弹出下拉列表，不需要从零开始造轮子，只要基于<a href="https://github.com/emacs-helm/helm" target="_blank" rel="noopener">Helm</a>即可轻松做到。Helm是一个增量补全及选择的框架，利用它的API，可以轻松实现带补全功能的下拉列表，并在选中某一项后执行特定的代码。</p><p>这份<a href="https://wikemacs.org/wiki/How_to_write_helm_extensions" target="_blank" rel="noopener">文档</a>清晰地说明了如何使用Helm的API。在展示具体代码前，先看看成品的效果是怎样的</p><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200110/基于Helm快速选择开始时间.mp4" type="video/mp4"><br></video><h1 id="show-the-code"><a href="#show-the-code" class="headerlink" title="show the code"></a>show the code</h1><p>Helm的用法朴实无华，只要调用名为<code>helm</code>的函数即可。<code>helm</code>有一个叫<code>sources</code>的重要参数，它接收一个<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-List-Type.html" target="_blank" rel="noopener">association list</a>，并要求其中有以如下三个符号为<code>car</code>的<code>cons</code>：</p><ol><li><code>name</code>。对应的<code>cdr</code>部分是下拉列表的名字；</li><li><code>candidates</code>。对应的<code>cdr</code>部分是下拉列表的所有候选项；</li><li><code>action</code>。对应的<code>cdr</code>部分是一个函数，代表选中某一项后的处理逻辑。</li></ol><p><code>candidates</code>可以是一个association list（这也是前述的文档以及我接下来的用法），其中每个<code>cons</code>的<code>car</code>部分将作为候选项被展示，<code>cdr</code>部分则是一个“真实值”（就像是HTML的option标签的文本与它的<code>value</code>属性间的关系）。Helm贴心地提供了名为<code>helm-marked-candidates</code>的函数，帮助在这种情况下，获取被选中的候选项对应的<code>cdr</code>部分的内容。为了利用这个便捷的特性，我将候选项定义为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> *schedule-shortcuts*</span><br><span class="line">      '((<span class="string">"午餐"</span> . (<span class="number">12</span> <span class="number">0</span>))</span><br><span class="line">        (<span class="string">"午休"</span> . (<span class="number">13</span> <span class="number">0</span>))</span><br><span class="line">        (<span class="string">"晚餐"</span> . (<span class="number">18</span> <span class="number">35</span>))</span><br><span class="line">        (<span class="string">"晚上在家"</span> . (<span class="number">22</span> <span class="number">5</span>))))</span><br></pre></td></tr></table></figure><p>要传给<code>helm</code>函数的<code>sources</code>参数的值为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> *helm-quick-schedule-source*</span><br><span class="line">  `((name . <span class="string">"设置TODO的SCHEDULED属性"</span>)</span><br><span class="line">    (candidates . *schedule-shortcuts*)</span><br><span class="line">    (action . (lambda (candidate)</span><br><span class="line">                (helm-marked-candidates)))))</span><br></pre></td></tr></table></figure><p>有了<code>*helm-quick-schedule-source*</code>，便可以一窥Helm的风采。按下<code>M-:</code>并输入<code>(helm :sources *helm-quick-schedule-source*)↵</code>，会打开一个新的buffer，其中纵向列出了“午餐”、“午休”、“晚餐”，以及“晚上在家”四个选项。可以上下移动，也可以输入目标选项的部分内容，Helm会根据输入过滤候选项。按下回车后，<code>helm</code>函数返回一个列表，装载着所选中的项对应的<code>cdr</code>部分——这是因为在<code>*helm-quick-schedule-source*</code>中<code>action</code>的部分就是直接返回这个<code>cdr</code>。</p><p>最后，只需将<code>helm</code>与上一篇文章中定义的<code>lt-next-todo</code>结合起来即可：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> helm-quick-schedule ()</span><br><span class="line">  <span class="string">"从下拉列表选择完后SCHEDULED模式后修改当前TODO条目的SCHEDULED属性。"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">spec</span> (<span class="name">car</span> (<span class="name">helm</span> <span class="symbol">:sources</span> '(*helm-quick-schedule-source*)))))</span><br><span class="line">    (<span class="name">when</span> spec</span><br><span class="line">      (<span class="name">apply</span> 'lt-next-todo spec))))</span><br></pre></td></tr></table></figure><p>把它绑定到<code>C-c l s</code>上</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-key</span> org-mode-map <span class="string">"\C-cls"</span> 'helm-quick-schedule)</span><br></pre></td></tr></table></figure><p>现在，当处于<code>org-mode</code>模式下的buffer时，只需要按下<code>C-c l s</code>，便可以轻松选择一个开始时间并在眨眼间设置为光标所在任务的SCHEDULED属性。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Emacs的Helm插件本身已经提供了非常丰富的功能，例如<code>helm-bufferss-list</code>。我还利用Helm实现查询笔记的入口，待时机成熟了，一定将这方面的心得分享出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://liutos.github.io/2020/01/09/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;上一篇文章&lt;/a&gt;的末尾，我说有一个更优雅的办法实现快速设置任务的开始时间，本文便来揭秘这个办法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>快速设置任务的开始时间（上）</title>
    <link href="https://liutos.github.io/2020/01/09/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://liutos.github.io/2020/01/09/快速设置任务的开始时间（上）/</id>
    <published>2020-01-09T12:53:16.000Z</published>
    <updated>2020-01-09T14:35:53.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“实战Elisp”系列的第一篇。本系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>用Emacs的org-mode安排业余时间颇有些时日，渐渐地开始编写一些Elisp函数来改善自己的使用体验。</p><p>日程管理中一个常见的需求，便是给任务设定一个开始时间。在org-mode中，这可以调用函数org-schedule实现：将光标移动到一个任务上，再按下C-c C-s，会出现一个日历界面，帮助选择日期和时间来作为日程的开始时间。具体效果如下图所示</p><a id="more"></a><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200109/org-mode设定任务开始时间.mp4" type="video/mp4"><br></video><p>久而久之发现，设置的开始时间不外乎是中午12点、下午1点、晚上10点等。这是因为业余时间是相对固定的，比如午饭、午休，以及晚上在家洗完澡等。有规律便有优化的空间。既然每次输入的内容都一样，干脆预设几个开始时间，直接选择即可。</p><h1 id="平凡的实现"><a href="#平凡的实现" class="headerlink" title="平凡的实现"></a>平凡的实现</h1><p>一个朴素的想法，是为这些固定的时间点各自编写一个Elisp函数，并绑定到不同的快捷键上，每次设置开始时间时就按下对应的快捷键。循着这个思路，我定义了如下的Elisp函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt-lunch-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为中午12点"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">12</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name">defun</span> lt-rest-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为下午1点"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">13</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name">defun</span> lt-supper-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为傍晚6点35分"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">18</span> <span class="number">35</span>))</span><br><span class="line">(<span class="name">defun</span> lt-night-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为晚上10点"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">22</span> <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>lt-next-todo的定义如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt-next-todo (<span class="name">hour</span> minute)</span><br><span class="line">  <span class="string">"设置光标所在行为一个TODO条目，并设置其SCHEDULED为HOUR:MINUTE。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果当前的时间已经晚于HOUR:MINUTE，那么将会设定为明天的目标小时。"</span></span><br><span class="line">  (<span class="name">cl-assert</span> (<span class="name">integerp</span> hour))</span><br><span class="line">  (<span class="name">cl-assert</span> (<span class="name">integerp</span> minute))</span><br><span class="line">  (<span class="name">org-todo</span> <span class="string">"TODO"</span>)</span><br><span class="line">  (<span class="name">org-set-tags</span> <span class="literal">nil</span> <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">current-hour</span> (<span class="name">string-to-number</span> (<span class="name">format-time-string</span> <span class="string">"%H"</span>)))</span><br><span class="line">        scheduled)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">&gt;</span> current-hour hour)</span><br><span class="line">           (<span class="name">setf</span> scheduled (<span class="name">format</span> <span class="string">"+1d %02d:%02d"</span> hour minute)))</span><br><span class="line">          (<span class="name">t</span> (<span class="name">setf</span> scheduled (<span class="name">format</span> <span class="string">"%02d:%02d"</span> hour minute))))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"scheduled: %s"</span> scheduled)</span><br><span class="line">    (<span class="name">org-schedule</span> <span class="literal">nil</span> scheduled)))</span><br></pre></td></tr></table></figure><p>除了绑定不同快捷键，也可以直接调用：将光标移动到任务标题上，按下M-:，输入lt-lunch-todo，最后按下回车。鉴于每次都按这么多键实在是太麻烦，我又编写了四个AppleScript脚本代劳键盘操作，再用BetterTouchTools定制了四个Touchbar按钮，以便一键调用这四个AppleScript脚本。举个例子，负责调用lt-lunch-todo的AppleScript脚本的内容为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Emacs"</span></span><br><span class="line"><span class="built_in">activate</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"System Events"</span></span><br><span class="line">keystroke <span class="string">":"</span> using &#123;option down&#125;</span><br><span class="line">keystroke <span class="string">"(lt-lunch-todo)"</span></span><br><span class="line">keystroke <span class="literal">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure><p>BetterTouchTools中的按钮的设置如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200109/BTT的四个快捷按钮.jpeg" alt=""></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这套方法用久后发现缺陷蛮多：</p><ol><li>要定义很多高度雷同的Elisp函数；</li><li>要编写很多高度雷同的AppleScript脚本；</li><li>要定制很多高度雷同的BetterTouchTools按钮；</li></ol><p>高度雷同、高度雷同、高度雷同，重要的事情说三遍。有规律便有优化的空间，于是我换了一种更好的方式，实现了可扩展的、优雅的快速设置任务开始时间的办法。</p><p>欲知后事如何，且听下回分解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“实战Elisp”系列的第一篇。本系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;用Emacs的org-mode安排业余时间颇有些时日，渐渐地开始编写一些Elisp函数来改善自己的使用体验。&lt;/p&gt;
&lt;p&gt;日程管理中一个常见的需求，便是给任务设定一个开始时间。在org-mode中，这可以调用函数org-schedule实现：将光标移动到一个任务上，再按下C-c C-s，会出现一个日历界面，帮助选择日期和时间来作为日程的开始时间。具体效果如下图所示&lt;/p&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="https://liutos.github.io/2020/01/02/2019%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://liutos.github.io/2020/01/02/2019年总结/</id>
    <published>2020-01-02T14:06:19.000Z</published>
    <updated>2020-01-02T14:17:07.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>9102年都已经过去好几天了，现在才来产出年终总结。</p><h1 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h1><h2 id="cuckoo——定时提醒工具"><a href="#cuckoo——定时提醒工具" class="headerlink" title="cuckoo——定时提醒工具"></a>cuckoo——定时提醒工具</h2><p>在<a href="https://liutos.github.io/2018/12/29/2018%E5%B9%B4%E5%BA%A6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">18年的总结</a>中，我提到自己开发了一个名为<code>cuckoo</code>的工具，用来代替macOS的提醒事项、日历，以及由crontab调用的shell脚本。这个目标在19年得以实现，<code>cuckoo</code>已经完全取代了它们。</p><p><code>cuckoo</code>实现了以下功能：</p><ol><li>创建一次性和周期性的提醒。<code>cuckoo</code>甚至可以在正确的二月最后一天弹出提醒——不管是平年还是闰年；</li><li>利用<a href="https://github.com/vjeantet/alerter" target="_blank" rel="noopener"><code>alerter</code></a>，<code>cuckoo</code>可以在提醒弹出后推迟它（5分钟、10分钟），或推迟到指定的时刻；</li><li>利用<a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">Server酱</a>，<code>cuckoo</code>可以把提醒以微信消息推给手机；</li><li>利用<a href="https://www.controlplaneapp.com/" target="_blank" rel="noopener"><code>ControlPlane</code></a>，实现按场景提醒——比如10点钟若在公司就提醒自己开晨会，若在家则绝不弹出。</li></ol><p>我还提供了给Emacs用的minor mode和Alfred Workflow，以提高易用性：</p><ol><li>在Emacs的org-mode中启用这个minor mode后，只需要按下<code>C-c r</code>便可为光标所在的条目创建提醒；</li><li>一个条目切换至<code>DONE</code>或<code>CANCELLED</code>状态时，也会自动更改<code>cuckoo</code>中任务的状态（感兴趣的读者可以移步<a href="http://liutos.github.io/2019/02/05/%E6%8B%BFEmacs%E5%AF%B9%E6%8E%A5%E6%88%91%E7%9A%84cuckoo/">之前的文章</a>）；</li><li>Alfred Workflow便于创建一次性提醒——比如提醒自己在25分钟后打开支付宝的蚂蚁庄园看看有没有鸡贼。</li></ol><h2 id="wa——Alfred-Workflow脚本"><a href="#wa——Alfred-Workflow脚本" class="headerlink" title="wa——Alfred Workflow脚本"></a>wa——Alfred Workflow脚本</h2><p>在18年入手MBP后不久，我便入手了<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>，并购买了<a href="https://www.alfredapp.com/powerpack/" target="_blank" rel="noopener">Powerpack</a>。平均每天使用Alfred 110次，大多是Snippets（auto expansion真香）、Clipboard（临时存储文字和图片的绝佳位置）、Workflow。常用的Workflow都是我自己开发的：</p><ol><li><code>unit</code>用于快速输入不同时间长度的秒数的，例如输入6天的秒数<code>6 * 24 * 60 * 60 * 1000</code>；</li><li><code>upload</code>用于上传图片到GitHub，把GitHub当图床用（感兴趣的读者可以移步这篇<a href="https://liutos.github.io/2018/12/07/%E6%8A%8AGitHub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/">文章</a>）；</li><li><code>gt</code>用于获取指定日期的UNIX时间戳、<code>int</code>用于获取一些预设的时间戳（例如“昨天0点”）；</li><li><code>yl</code>用于精确设定macOS的音量；</li><li><code>bqb</code>用于斗图（感兴趣的读者可以移步<a href="https://liutos.github.io/2019/12/16/%E8%AE%A9%E6%96%97%E5%9B%BE%E8%B5%A2%E5%9C%A8%E8%B5%B7%E8%B7%91%E7%BA%BF%E4%B8%8A/">这里</a>）。</li></ol><p>这些脚本都收集在名为wa的私有仓库中。由于需求比较稳定，这个仓库的迭代不多。</p><h2 id="jjcc——将LISP语言编译为x64汇编"><a href="#jjcc——将LISP语言编译为x64汇编" class="headerlink" title="jjcc——将LISP语言编译为x64汇编"></a>jjcc——将LISP语言编译为x64汇编</h2><p>不害臊地说，<code>jjcc</code>是一个用Common Lisp写就的编译器，运行在<a href="https://common-lisp.net/project/slime/" target="_blank" rel="noopener">SLIME</a>中，如果投喂它某种LISP方言代码，就可以编译出跑在macOS上的x64汇编代码。这是我的第一款生成汇编指令的编译器，为此还恶补了不少汇编语言知识，尤其是x64的calling convention。这款编译器的开发过程写成了文章发表在博客和知乎上，感兴趣的读者可以移步这个<a href="https://zhuanlan.zhihu.com/lessmore" target="_blank" rel="noopener">专栏</a>。</p><p>在完成了蹩脚的自定义函数特性后，我读了《An Incremental Approach to Compiler Construction》这篇论文，它循序渐进地开发一个Scheme语言到x86汇编的编译器，并且阶段划分得更好，后来我也按照论文的思路重新实现了一遍。</p><h2 id="savemoney——未完待续的RescueTime代替品"><a href="#savemoney——未完待续的RescueTime代替品" class="headerlink" title="savemoney——未完待续的RescueTime代替品"></a>savemoney——未完待续的RescueTime代替品</h2><p>19年10月份时RescueTime Premium到期，由于太鸡肋了便不再续费。我仍然有time-tracking的需求，于是打算自己动手写一个代替品。皇天不负有心人，我找到了<a href="https://www.npmjs.com/package/active-win" target="_blank" rel="noopener"><code>active-win</code></a>这个库，它可以获取当前有焦点的窗口的元信息。基于这个库我写了两个脚本：</p><ol><li><code>savemoney.js</code>，每隔一秒调用<code>active-win</code>获取当前激活窗口的元信息，然后写入到Redis中；</li><li><code>accounting.js</code>，不停地从Redis中取出数据，运算后写入到MySQL中。</li></ol><p>目前仅仅是将数据记录在了MySQL中，没有做报表和统计。这两个脚本通过Launchd在每次登录后自动运行。</p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>19年在GitHub博客一共发表了28篇博文，数量差强人意，质量亟待提高。在读了<a href="https://maxoxo.me/pyramid-theory/" target="_blank" rel="noopener">利用金字塔原理写出好文章</a>后，我逐渐改进自己的写作方法，以期写得更有条理。</p><p>除了GitHub博客和SegmentFault，我还在知乎上发表了一些文章，大多是关于jjcc编译器的。刚才我说文章的质量亟待提高，如果你看过jjcc编译器系列的文章的话，一定会很同意我的观点。</p><p>博客和SegmentFault的受众很小，于是我又开通了微信订阅号，希望可以在技术圈子里更多的展示自己——有没有值得展示的内容另说。在订阅号上发表文章多了一种无形的压力，毕竟这些内容更容易被同学、同事、同行看到（前提是人家乐意看）。万一写的很糟糕，可就糗大了。目前订阅号关注者寥寥，有兴趣的可以微信搜索“小打小闹写点bug”关注。</p><h1 id="学习、进修"><a href="#学习、进修" class="headerlink" title="学习、进修"></a>学习、进修</h1><p>19年读完的书不多：</p><ol><li>《MongoDB in Action》，没什么太大的收获；</li><li>《High Performance MySQL》，看过后确实有些帮助，切实根据书中的指导调优过生产环境的MySQL；</li><li>《Algorithms》，光看没练手；</li><li>《Linux Shell Scripting Cookbook》，看着看着幡然醒悟这东西只要用到的时候查阅就足够了，遂弃之。</li></ol><p>还有许多在读经典书籍，如《Clean Architecture》、《重构》。刚开始我会在上下班搭地铁时读这些书，后来将看书时间固定在了每天下午一点至一点半。这些在读的书像一条队列，我每天会读队头的书，然后放到队尾。这样一来，每天都在涉猎不同领域的内容。</p><p>在18年9月，我闭门造车地整理了一份Web后端软件工程师的技能树，再据此来寻找要读的书。例如，上述的《MongoDB in Action》是依据“后端知识/文档数据库/MongoDB”找的，《Linux Shell Scripting Cookbook》是依据“后端知识/命令行操作”找的。技能树整理得好不好暂且按下不表，但渐渐地我忘记了看书的初衷，成了“为看而看”。看似每天中午都在学习，实际上由于目的性不强，收获不大。由于每天读不同类型的书，同一个主题的学习过程也变得支离破碎。这个学习方法已经到了迫切需要优化的地步。</p><h1 id="macOS更新换代——AppleScript来袭、Chrome上位"><a href="#macOS更新换代——AppleScript来袭、Chrome上位" class="headerlink" title="macOS更新换代——AppleScript来袭、Chrome上位"></a>macOS更新换代——AppleScript来袭、Chrome上位</h1><p>19年10月升级到macOS Catalina，然后问题便接踵而至。首当其冲的是<code>alerter</code>和<code>terminal-notifier</code>没法用了，无法在右上角弹出提醒。一番折腾后不见起色，只好先用AppleScript代替，让<code>cuckoo</code>可以弹出提醒。AppleScript的<code>display notification</code>功能远不及<code>alerter</code>那么丰富，聊胜于无吧。</p><p>Firefox也开始闹别扭。只要打开Firefox稍微用两下，就会有一个名为FirefoxWebCP Extension的进程疯狂地使用CPU，Firefox内的各标签页也纷纷失灵转圈，几天下来都是如此。没办法，只好起用Chrome。稍微磨合后发现Chrome其实挺不错，各方面都今非昔比。以前之所以一直坚守在Firefox的阵营，主要是因为：</p><ol><li>Firefox的Pocket插件更好用——早年间不需要打开Pocket的网站即可查看自己的列表，不过自从Firefox集成Pocket后，这个优势已经荡然无存；</li><li>Firefox的Vimperator更好用——这也一样，Vimperator逝者已逝，继承者Vim vixen和Chrome的Vimium大同小异；</li><li>Firefox的地址栏搜索浏览历史更好用，这一点迄今未被Chrome超越——Chrome的地址栏要么搜不到，要么必须输入更多关键词，然后还是搜不到。</li></ol><p>希望Mozilla在2020年可以修复这个问题，让我重回Firefox的怀抱。</p><h1 id="CL虐我千万遍，我待CL如初见"><a href="#CL虐我千万遍，我待CL如初见" class="headerlink" title="CL虐我千万遍，我待CL如初见"></a>CL虐我千万遍，我待CL如初见</h1><p>2019年的Common Lisp依然让人哀其不幸怒其不争，我也依然痴迷于这门古怪的语言。但痴迷不能当饭吃，要将CL投入到实际应用实在太难。且不说<a href="https://www.quicklisp.org/beta/" target="_blank" rel="noopener">Quicklisp</a>上库的数量远不及PyPI和NPM，质量也令人抓狂。这不，都9102年了，访问一个返回JSON数据的HTTP接口，还得先用<a href="https://edicl.github.io/drakma/" target="_blank" rel="noopener"><code>drakma</code></a>发出请求（也许不支持HTTP/2），再用<code>flexi-streams</code>将字节数组转换为UTF-8编码的字符串，再用<code>cl-json</code>解析一番。拿到一个列表对象后，再用<code>car</code>、<code>cdr</code>、<code>assoc</code>一顿操作猛如虎，才能拿到需要的数据。</p><p>2020年，MAKE CL GREAT AGAIN！</p><h1 id="记账"><a href="#记账" class="headerlink" title="记账"></a>记账</h1><p>在年中的时候，萌生了换记账软件的想法，因为挖财用起来越来越不爽了，而且整天记流水账也没什么收获。一番摸索后，我决定尝试一下复式记账法，并选择了GNU Cash——早年间用过一次，但没看入门手册就开始用，根本玩不转。这一次倒是读了<a href="https://www.gnucash.org/viewdoc.phtml?rev=3&amp;lang=C&amp;doc=guide" target="_blank" rel="noopener">手册</a>，但GNU Cash的UI和操作方式还是无法让我心动；之后知道了<a href="http://furius.ca/beancount/" target="_blank" rel="noopener">beancount</a>，却无法在我的系统中顺利运行；最终我选择了<a href="https://www.ledger-cli.org/" target="_blank" rel="noopener">ledger</a>，它是一个命令行程序，不负责记录，只负责读取手打显诚意的交易明细，然后产出报表。Emacs有一个<a href="https://github.com/ledger/ledger-mode" target="_blank" rel="noopener">ledger-mode</a>插件，两者配合用来记账超痛快。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>在2020年我希望至少能完成：</p><ol><li>发布<code>cuckoo</code>；</li><li>发布<code>wa</code>；</li><li>开发一个<code>alerter</code>的代替品；</li><li>写更多的博文，让微信订阅号的粉丝涨到130；</li><li>给CL写一些库解决一些常见的需求</li></ol><p>最后</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/2020%E5%B9%B4%E4%BC%9A%E5%92%8C2019%E5%B9%B4%E4%B8%80%E6%A0%B7%E7%83%82.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="总结" scheme="https://liutos.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2019" scheme="https://liutos.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>当我们git merge的时候到底在merge什么</title>
    <link href="https://liutos.github.io/2019/12/21/%E5%BD%93%E6%88%91%E4%BB%ACgit-merge%E7%9A%84%E6%97%B6%E5%80%99%E5%88%B0%E5%BA%95%E5%9C%A8merge%E4%BB%80%E4%B9%88/"/>
    <id>https://liutos.github.io/2019/12/21/当我们git-merge的时候到底在merge什么/</id>
    <published>2019-12-21T07:26:36.000Z</published>
    <updated>2019-12-21T07:29:23.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我在上大学的时候并没有接触过VCS（版本控制系统）。虽然曾经在Google Code发布过去项目，但是以压缩包的形式发布的；与室友合作开发计算机网络这门课的课程设计时，也没有用上。直到入职第一家公司后才真正开始使用，当时用的是Git，此后也始终没用过其它的VCS——SVN仅仅耳闻未曾使用——转眼间已经用了六年多的Git了。</p><p>尽管日常使用问题不大，但对于Git的内部运行原理我仍然是一知半解——也不是我谦虚，基本就是不懂吧。例如，使用<code>git add</code>、<code>git commit</code>、<code>git branch</code>等命令的时候，Git在背后究竟做了什么，我是答不上来的。好在互联网上有许多这方面的资料可供学习，我硬着头皮看了不少文档和博客后，总算是习得了一些皮毛。</p><p>现在，我试着循序渐进地讲解一遍吧。</p><h1 id="git-add的时候发生了什么？"><a href="#git-add的时候发生了什么？" class="headerlink" title="git add的时候发生了什么？"></a>git add的时候发生了什么？</h1><p>首先创建出一个仓库并向其中添加一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir git-test</span><br><span class="line">cd git-test</span><br><span class="line">git init</span><br><span class="line">echo 'hello' &gt; a</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p>到此为止，暂时不要提交改动。现在，我来看看Git到底在背后做了些什么。Git的秘密都藏在叫做<code>.git</code>的目录中，尤其是其中的<code>objects</code>目录。用<code>tree</code>命令查看这个目录的结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.git/objects</span><br><span class="line">├── ce</span><br><span class="line">│   └── 013625030ba8dba906f756967f9e9ca394464a</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>与运行<code>git add</code>前相比，多出了一个叫<code>ce</code>的目录，以及位于其中的叫<code>013625030ba8dba906f756967f9e9ca394464a</code>的文件。这个文件其实就是<code>a</code>的一个“副本”，其中存储着文件<code>a</code>的内容。但是不能用<code>cat</code>直接查看，因为Git对这个文件做了压缩。可以用<code>pigz</code>来得到压缩前的原文，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pigz -d &lt; .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob 6hello</span><br></pre></td></tr></table></figure><p>Git生成这个文件的规则其实不复杂。首先Git会计算原文件的长度，即6（之所以是6，是因为用<code>echo</code>和重定向写入文件<code>a</code>时，添加了一个换行符）。然后，Git将一个固定的前缀<code>blob</code>（此处有一个空格）、文件长度、一个空字符（ASCII码为0的字符），以及文件内容这四者连接成一个字符串，并计算这个字符串的SHA1摘要。具体到文件<code>a</code>，可以用下面的命令试着计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf "blob 6\0hello\n" | shasum</span><br></pre></td></tr></table></figure><p>或者用Git内置的<code>hash-object</code>子命令会更简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git hash-object a</span><br></pre></td></tr></table></figure><p>不管是哪一个命令，算出来的摘要都是<code>ce013625030ba8dba906f756967f9e9ca394464a</code>。然后Git会取前两个字符（<code>ce</code>）作为目录名，在<code>.git/objects</code>下创建新的目录。以从第三个字符开始的剩余内容（<code>013625030ba8dba906f756967f9e9ca394464a</code>）为文件名，将方才拼接好的内容压缩后写如文件。这种文件用Git的术语来讲叫做<code>blob</code>对象，稍后还会遇到<code>tree</code>类型和<code>commit</code>类型的对象。</p><h1 id="git-commit的时候发生了什么？"><a href="#git-commit的时候发生了什么？" class="headerlink" title="git commit的时候发生了什么？"></a>git commit的时候发生了什么？</h1><p>接下来提交改动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.email &apos;foobar&apos;</span><br><span class="line">git config user.name &apos;foobar&apos;</span><br><span class="line">git commit -m &apos;test&apos;</span><br></pre></td></tr></table></figure><p>此时会发现<code>.git/objects</code>下新增了两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.git/objects</span><br><span class="line">├── 09</span><br><span class="line">│   └── 76950c1fdbcb52435a433913017bf044b3a58f # 新的</span><br><span class="line">├── 14</span><br><span class="line">│   └── c77e71bd06df41e1509280cfba045e1db2aa5f # 新的</span><br><span class="line">├── ce</span><br><span class="line">│   └── 013625030ba8dba906f756967f9e9ca394464a</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>用<code>git cat-file -t</code>可以查看这两个新文件的类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 14c77e71bd06df41e1509280cfba045e1db2aa5f # 输出commit</span><br><span class="line">git cat-file -t 0976950c1fdbcb52435a433913017bf044b3a58f # 输出tree</span><br></pre></td></tr></table></figure><p>也可以用<code>git cat-file -p</code>以可读的方式输出新文件的内容。例如用<code>git cat-file -p 0976950c1fdbcb52435a433913017bf044b3a58f</code>输出<code>tree</code>类型的对象的内容，结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100644 blob ce013625030ba8dba906f756967f9e9ca394464aa</span><br></pre></td></tr></table></figure><p><code>tree</code>类型的对象中记录着Git所追踪的文件的元信息，包括文件的权限、在Git中的对象类型、对象摘要，以及文件名。另一个<code>commit</code>类型的对象中存储着本次提交的信息，用<code>git cat-file -p</code>查看的结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree 0976950c1fdbcb52435a433913017bf044b3a58f</span><br><span class="line">author foobar &lt;foobar&gt; 1576676836 +0800</span><br><span class="line">committer foobar &lt;foobar&gt; 1576676836 +0800</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>第一行表示这个<code>commit</code>对象指向的是哪一个<code>tree</code>对象，从这个<code>tree</code>对象出发，可以遍历仓库中直到本次提交为止、所有被Git追踪的文件。<code>commit</code>指向<code>tree</code>，<code>tree</code>可以指向<code>blob</code>也可以指向其它的<code>tree</code>，<code>blob</code>就像是树中的叶子节点，不再指向其它的对象，它们之间的关系如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/commit_tree_blob.jpeg" alt=""></p><h1 id="git-branch的时候发生了什么？"><a href="#git-branch的时候发生了什么？" class="headerlink" title="git branch的时候发生了什么？"></a>git branch的时候发生了什么？</h1><p>Git的<code>branch</code>子命令用于创建新分支——虽然我平时更多地使用<code>git checkout -b</code>。既然<code>add</code>和<code>commit</code>的时候，Git会创建出<code>blob</code>、<code>tree</code>，以及<code>commit</code>类型的对象，那么创建新分支的时候，Git是不是也会创建名为<code>branch</code>的对象呢？答案是否定的。</p><p>Git的分支非常简单——它仅仅是指向某个<code>commit</code>对象的引用，就像是<code>*nix</code>系统中的符号链接一样。所有分支都存储在<code>.git/refs/heads</code>之下。例如文件<code>.git/refs/heads/master</code>中便存储着<code>master</code>分支上的最新提交的摘要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .git/refs/heads/master # 输出14c77e71bd06df41e1509280cfba045e1db2aa5f</span><br></pre></td></tr></table></figure><p>这就是在Git中创建新分支的成本很低的原因——不过是复制一下当前分支在<code>.git/refs/heads</code>下的同名文件而已。我创建一个新分支<code>develop</code>并提交一个新文件<code>b</code>，<code>.git/objects</code>下会多出三个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b develop</span><br><span class="line">echo 'good' &gt; b</span><br><span class="line">git add b</span><br><span class="line">git commit -m 'new branch'</span><br></pre></td></tr></table></figure><p>三个新文件分别存储着文件<code>b</code>的内容（一个<code>blob</code>对象）、文件<code>b</code>的元信息（一个<code>tree</code>对象），以及本次提交（一个<code>commit</code>对象）。这些文件中没有任何关于<code>develop</code>分支的信息，<code>develop</code>分支仅仅是一个存在于<code>.git/refs/heads/</code>目录下的同名文件。</p><h1 id="git-merge一个子代时发生了什么？"><a href="#git-merge一个子代时发生了什么？" class="headerlink" title="git merge一个子代时发生了什么？"></a>git merge一个子代时发生了什么？</h1><p><code>develop</code>分支是从<code>master</code>分叉出来，将<code>develop</code>合并回<code>master</code>时，Git会进行一次<code>fast-forward</code>的合并。虽然名字很唬人但其实Git做的事情非常简单，只需要将<code>.git/refs/heads/master</code>文件的内容修改为与<code>develop</code>相同的摘要即可。</p><p>也可以要求Git不使用<code>fast-forward</code>。先用<code>git reset --hard HEAD^1</code>将<code>master</code>分支回退到第一次提交的状态，然后使用下列的命令再次将<code>develop</code>合并进来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff develop</span><br></pre></td></tr></table></figure><p>这一次，Git不再简单地修改<code>.git/refs/heads/master</code>文件了事，而是会创建一个新的<code>commit</code>对象。在我的电脑上，这个新的<code>commit</code>对象的摘要为<code>d1403bb629c7a636c724069b22875ed882b54bcc</code>，使用<code>git cat-file -p</code>看看它的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree e960ed43b8e6b5fe9b4e57b806f70796da820056</span><br><span class="line">parent 14c77e71bd06df41e1509280cfba045e1db2aa5f</span><br><span class="line">parent db891542d3e44448433ba86c7cd636d8aec3da54</span><br><span class="line">author foobar &lt;foobar&gt; 1576679608 +0800</span><br><span class="line">committer foobar &lt;foobar&gt; 1576679608 +0800</span><br><span class="line"></span><br><span class="line">Merge branch &apos;develop&apos;</span><br></pre></td></tr></table></figure><p>有趣的是，这个<code>commit</code>对象有两个“父级”的<code>commit</code>，而不像平常所认识的树形数据结构那般只有一个“父节点”。显然，这两个父节点分别是合并前的<code>master</code>分支的最新一次提交，以及<code>develop</code>的最新提交。</p><p>虽然创建了一个新的<code>commit</code>对象，但其实<code>develop</code>分支的最新提交持有的便是整个仓库的最新版本，所以不需要创建新的<code>tree</code>，合并所产生的<code>commit</code>直接与<code>develop</code>分支的最新提交共用同一个<code>tree</code>对象便足够了——在上面输出内容的第一行的摘要，就是<code>develop</code>分支的最新<code>commit</code>所指向的<code>tree</code>对象的摘要。</p><p>至此，终于解决了我一直以来的一个困惑。我曾天真地以为，Git在合并两个分支的时候，会将待合进来的分支中的所有多出来的改动，复制到要合进去的分支中去。这都是因为我没有理解分支的本质，Git的分支并不是一根水管，没有哪一个提交是只能装在一个特定的分支中的。Git合并的时候，就像是在一个immutable的树上做修改，只需要创建不多的新<code>commit</code>和<code>tree</code>对象，再引用已经存在的旧<code>commit</code>和<code>tree</code>对象即可。否则，哪能快速地完成两个分支的合并呢。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>没想到还写了蛮多内容的，经过这么几次试验，我对Git的核心原理也算略知一二了，暂时不打算继续深入。各位读者如果有兴趣，可以试着制造一次有冲突的合并，然后看看冲突解决的前后，<code>.git/objects</code>目录下会有什么变化。</p><p>最后，在摸索Git原理的过程中，我找到了不少优质的参考资料，这里一并奉上：</p><ol><li><a href="https://nfarina.com/post/9868516270/git-is-simpler" target="_blank" rel="noopener">https://nfarina.com/post/9868516270/git-is-simpler</a></li><li><a href="https://maryrosecook.com/blog/post/git-from-the-inside-out" target="_blank" rel="noopener">https://maryrosecook.com/blog/post/git-from-the-inside-out</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/ch08.html" target="_blank" rel="noopener">http://www-cs-students.stanford.edu/~blynn/gitmagic/ch08.html</a></li><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Internals-Git-Objects</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="git" scheme="https://liutos.github.io/tags/git/"/>
    
      <category term="internal" scheme="https://liutos.github.io/tags/internal/"/>
    
      <category term="原理" scheme="https://liutos.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>让斗图赢在起跑线上</title>
    <link href="https://liutos.github.io/2019/12/16/%E8%AE%A9%E6%96%97%E5%9B%BE%E8%B5%A2%E5%9C%A8%E8%B5%B7%E8%B7%91%E7%BA%BF%E4%B8%8A/"/>
    <id>https://liutos.github.io/2019/12/16/让斗图赢在起跑线上/</id>
    <published>2019-12-16T14:16:53.000Z</published>
    <updated>2019-12-16T15:03:26.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>以前用Windows的时候，我在QQ中添加了很多自定义表情，其中有很多我还为它们设置了短语，以便可以便捷地发出去。后来微信用得多了，也在微信中收集了很多的表情。很多时候，表情包真的是一图胜千言，而且比起直白地说出同样的话，发图片显得更有意思。比如说，某一天你的同事在谈论他朋友的一些事情时，你可以发一张</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/你说的这个朋友到底是不是你自己.jpeg" alt=""></p><p>当然了，很多时候可能手头没有这张图片，或者一时找不到，也可以来一句“你说的这个朋友到底是不是你自己.jpg”，异曲同工。每每遇到这些有趣的图片的时候，我便会将它们保存下来以备不时之需。不过收集得多了之后，在想要用的时候便发现找表情也不是一件特别容易的事情。比如说，我的表情包目录中已经有92张图片了，即便我明确地知道我要找的就是上面这张图，文件名也没记错，但要在九十多张图片中一眼看到它，还是颇具难度的。</p><p>好在，咱是程序员，在很多事情上可以动动手指写写代码来予以辅助——找表情图片这件事情，恰好是其中之一。</p><h1 id="准备素材"><a href="#准备素材" class="headerlink" title="准备素材"></a>准备素材</h1><p>首先，我要祭出神器<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>。我会编写一个Alfred的Workflow，它起码要能够方便我按名字找到图片，并且能够复制到粘贴板中。这么一来，我就可以直接在IM软件的聊天窗口中发出选好的表情图。</p><p>其次，正所谓巧妇难为无米之炊，如果没有表情图片的储备，那制作这么个工具也就毫无意义了。因此，我还得准备一个目录，用来存放所有将来可能会用上的图片文件，这个目录便是<code>~/OneDrive/图片/表情包</code>。OneDrive上1TB的存储空间，放点图片也是绰绰有余了——当然了，也不是非要把图片目录放到一个同步网盘里。</p><p>最后，这些搜集回来的图片还不能就这么晾着，必须给它们取一些容易记忆的名字，毕竟之后就靠名字来找它们了。给表情图片文件命名很简单，因为许多图片中含有一两句关键的话。比如说，下面这张图</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/6点后Java程序员继续上班.jpeg" alt=""></p><p>直接用图中的文字来命名即可。</p><h1 id="编写Workflow"><a href="#编写Workflow" class="headerlink" title="编写Workflow"></a>编写Workflow</h1><p>现在可以开始编写Workflow了。它的最终形态是下图这样的</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/表情包工作流的结构.jpeg" alt=""></p><p>作为Workflow入口的是一个keyword为<code>bqb</code>的<a href="https://www.alfredapp.com/help/workflows/inputs/file-filter/" target="_blank" rel="noopener">File Filter</a>。<code>File Filter</code>是一个挺强大的工具，它本身就可以完成我所需要的功能，见如下演示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/FileFilter的效果.gif" alt=""></p><p>可见，<code>File Filter</code>本身便足矣完成搜索图片并复制到粘贴板的需求，本篇文章也就到此为止了——才怪，光有<code>File Filter</code>还不够，因为收集回来的表情图片的尺寸并不统一，直接在IM工具中发送的效果并不好，可能有霸屏之嫌。比如文章开头的图片，用来自<code>ImageMagick</code>套件的<code>identify</code>程序可以看到这张图片足足有527像素宽405像素高，一下子占据了半个聊天窗口——群聊的时候，还是应当照顾一下群里其他人的感受的。</p><p>因此，Workflow中的第二个对象，便负责将图片缩放为合适的尺寸。第二个对象是一个<a href="https://www.alfredapp.com/help/workflows/actions/run-script/" target="_blank" rel="noopener"><code>Run Script Action</code></a>，Alfred在运行后第一个<code>File Filter</code>后便会接着调用这个对象中所指定的外部脚本。这个对象的配置如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/表情包的RunScriptAction.jpeg" alt=""></p><p>其中的脚本内容如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 将图片等比缩放为300像素的宽度</span></span><br><span class="line"></span><br><span class="line">filename=$(basename <span class="string">"<span class="variable">$&#123;1&#125;</span>"</span>)</span><br><span class="line">suffix=<span class="string">"<span class="variable">$&#123;filename##*.&#125;</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;suffix&#125;</span>"</span> = <span class="string">'gif'</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$&#123;1&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sips --resampleWidth 300 <span class="string">"<span class="variable">$&#123;1&#125;</span>"</span> --out /tmp &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"/tmp/<span class="variable">$&#123;filename&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>运行这个脚本后，便可以在<code>/tmp</code>目录下得到与原始图片同名的、宽度缩放为300像素的新图片。刚开始我也打算处理<code>.gif</code>文件，但试验后发现<code>sips</code>把GIF缩放成了一张静态图，于是便不处理GIF文件了。</p><p>第三个对象很简单，是一个<a href="https://www.alfredapp.com/help/workflows/utilities/argument/" target="_blank" rel="noopener"><code>Argument and Variables Utility</code></a>，配置很简单，直接上图比较直观</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/表情包的Argument工具.jpeg" alt=""></p><p>第四个对象又是一个<code>Run Script Action</code>，用于将缩放后的图片复制到粘贴板中——没错，这本来是<code>File Filter</code>完成的工作。这个对象同样会调用一个<code>External Script</code>，内容如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /Users/liutos/SourceCode/applescript/</span><br><span class="line">osascript copy_file_to_clipboard.scpt <span class="variable">$&#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>咦，复制文件到粘贴板的逻辑呢？别着急，在<code>/Users/liutos/SourceCode/applescript/copy_file_to_clipboard.scpt</code>这个文件中，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/osascript</span><br><span class="line"># 方法来自这里：https://superuser.com/questions/1132777/copy-an-image-to-clipboard-from-the-mac-terminal</span><br><span class="line">on run args</span><br><span class="line">set the clipboard to POSIX file (first item of args)</span><br><span class="line">end run</span><br></pre></td></tr></table></figure><p>它借助<code>AppleScrippt</code>来实现复制文件的功能。</p><p>最后一个对象是Alfred内置的<a href="https://www.alfredapp.com/help/workflows/outputs/post-notification/" target="_blank" rel="noopener"><code>Post Notification</code></a>，用于在一切就绪后在右上角弹出提醒，反馈给Workflow的使用者，它的配置如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/表情包的弹出提醒.jpeg" alt=""></p><p>至此，这个集查找、缩放，以及复制图片于一身的Workflow，便大功告成了。怎样？是不是已经跃跃欲试了？</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>等跃跃欲试的感觉褪去后便会发现，这个Workflow还相当地不成熟：</p><ol><li>使用<code>AppleScript</code>复制文件后，只要在IM软件中一粘贴便会立即发送出去，让人有点猝不及防。我希望的效果，是类似于在浏览器中右键复制一张图片那般的；</li><li>它基于Alfred的<code>File Filter</code>来查找目录下的文件，但<code>File Filter</code>的搜索能力并非很强。虽然从上面的动图看来，它支持以拼音来搜索，但很多时候稍微多打几个字母，便什么结果也没有了。如果可以支持模糊查找，甚至全文搜索乃是极好的；</li><li>表情图片的文件名需要自己维护，每次收集到新的表情时都需要自己手打显诚意。若是有一个配套的工具可以从图片中提取出文字来自动命名便更好了——OCR了解一下？；</li><li>最后，当收集的表情图片多起来后，许多图片便不好找了，毕竟谁也无法很容易地记忆九十多张图片的名字。渐渐地，很多图片的使用率也会下降，变成了鸡肋。而当它们真的派上用场的时候，早已忘记了它们正静静地躺在目录下等待召唤。或许，我需要一个可以自动阅读我的聊天内容并向我推荐表情图的AI助理？</li></ol><p>等哪天有空了，说不定我会按上面的思路稍微改进一下吧，哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些适用于Node.js的命名约定</title>
    <link href="https://liutos.github.io/2019/11/30/%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD%E7%9A%84%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A/"/>
    <id>https://liutos.github.io/2019/11/30/一些自我感觉良好的命名约定/</id>
    <published>2019-11-30T12:32:33.000Z</published>
    <updated>2019-12-07T07:59:17.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>There are only two hard things in Computer Science: cache invalidation and naming things.</p><p>– Phil Karlton</p></blockquote><p>我<del>乔鲁诺·乔巴拿</del>有一个梦想，便是要成为程序员巨星。但如果你看过我写的代码，便知道我还远远够不上“巨星”二字。我的代码中有许多不一致的命名：</p><ol><li>常量的命名时而是全大写的（如<code>WAIT_CONFIRM</code>），时而是全小写的；</li><li>某个项目大部分命名用的是camel case（如<code>TaskController</code>），但由于数据库中的列名用了snake case（如<code>context_id</code>），导致项目中与数据库列有关的代码混用了camel case和snake case（如<code>restricted_hours[new Date(timestamp * 1000).getHours()] = 1;</code>）；</li><li>同样是构造复杂对象的函数，它们的前缀可能会是build、create、make，甚至compute中的任何一个；</li><li>明明是一个数组，却用了单数的<code>order</code>作为变量名。</li></ol><p>之所以如此混乱，正是因为我没有遵循一套一致的命名规则。每当我在一个项目中蹦出一些新想法时，便会跃跃欲试——不，我真的就用上了。我不曾整理过自己的命名规则（天哪我已经写了三年的JavaScript了），以至于无从判断“新想法”是否真的新——也许它是一个已经被我抛弃的规则。</p><p>为了不再深陷不一致命名的泥潭，我定下了本篇的命名规则，期望它们为以后的我指点迷津。</p><h1 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h1><h2 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h2><ul><li>变量名使用camel case的命名风格。例如，使用<code>namingConvention</code>，而不是<code>naming_convention</code>；</li><li>在尽量遵循规则的基础上随机应变。</li></ul><h2 id="变量名的单复数规则"><a href="#变量名的单复数规则" class="headerlink" title="变量名的单复数规则"></a>变量名的单复数规则</h2><ul><li>如果一个变量存储的值的类型为数组（即该变量作为<code>Array.isArray</code>方法的参数时结果为真），那么变量的名称就使用复数形式。例如，使用<code>fruits = []</code>而不是<code>fruit = []</code>。</li><li>如果一个变量存储的值的类型为集合（即<code>Set</code>这个类型），那么变量的名称应当使用单词unique为前缀。例如，使用<code>uniqueUserIds</code>而不是<code>userIdSet</code>。</li></ul><h2 id="布尔变量的命名规则"><a href="#布尔变量的命名规则" class="headerlink" title="布尔变量的命名规则"></a>布尔变量的命名规则</h2><p>如果一个变量的值的类型为<code>boolean</code>，那么变量的名称应当以下列单词为前缀：</p><ul><li>is。当变量表达一个二元状态的时候，例如<code>isFull</code>、<code>isEmpty</code>。在is后面的应当是一个形容词；</li><li>has。当变量表达历史上是否发生过某个事件的时候，例如<code>hasPaid</code>、<code>hasArrived</code>。在has后面的应当是一个动词，并且采用过去分词；</li><li>can。当变量表达某种权限的时候，例如<code>canWrite</code>、<code>canExecute</code>。在can后面的应当是一个动词，并且采用现在分词。</li></ul><h2 id="数值变量的命名规则"><a href="#数值变量的命名规则" class="headerlink" title="数值变量的命名规则"></a>数值变量的命名规则</h2><ul><li>如果变量中存储的是一系列数字中的最大值，那么变量的名称应当以max为前缀，例如<code>maxScore</code>。如果是最小值，则是以min为前缀，例如<code>minScore</code>；</li><li>如果变量中存储的是一系列数字的和，那么变量的名称应当以total为前缀，例如<code>totalIncome</code>；</li><li>如果变量中存储的是数组的长度，那么变量的名称可以用numberOf为前缀，例如<code>numberOfUsers</code>。</li></ul><h2 id="字符串变量的命名规则"><a href="#字符串变量的命名规则" class="headerlink" title="字符串变量的命名规则"></a>字符串变量的命名规则</h2><ul><li>如果表达的是人名、品牌名、公司名、数据库中的表名，那么变量的名称可以用单词name结尾，例如<code>customerName</code>、<code>brandName</code>、<code>companyName</code>；</li><li>如果表达的是按键或按钮上刻着的文字、纸质表格或电子表单上输入框左侧的简短说明，那么变量的名称可以用单词label结尾，例如<code>buttonLabel</code>；</li><li>不允许使用单词content</li></ul><h1 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h1><ul><li>函数的名称应当由动词和名词组成，例如<code>readFile</code>、<code>writeFile</code>；</li><li>如果函数的功能是将参数转换为另一种形式的输出（比如进制转换、币种转换），那么函数的名称应当以单词to为前缀，例如<code>toDollar</code>、<code>toHexadecimal</code>；</li><li>如果函数的功能是检验参数并返回一个布尔值，那么函数的名称应当以单词check为前缀，例如<code>checkIsDirectory</code>、<code>checkIsExecutable</code>；</li><li>如果函数的功能是“计数”，那么函数的名称应当以单词count为前缀，并且其中被计数的对象应当为复数形式，例如<code>countPaidOrders</code>。</li></ul><h2 id="构造型函数的命名规则"><a href="#构造型函数的命名规则" class="headerlink" title="构造型函数的命名规则"></a>构造型函数的命名规则</h2><ul><li>如果表达的是从无到有地创造一个对象，那么函数名可以用create作为前缀，例如<code>createObject</code>；</li><li>如果表达的是将一些输入原封不动地放在一起（可能输入之间添加了其它东西）创造出一个对象，那么函数名可以用make作为前缀，例如<code>makeFloor</code>。进一步地，如果函数不改变输入的相对顺序，那么函数名可以用concat，例如<code>concatString</code>；</li><li>如果函数会将根据输入创造出具有不止一个层级的对象，那么函数名可以用build作为前缀，例如<code>buildBinarySearchTree</code>。</li></ul><h2 id="修改型函数的命名规则"><a href="#修改型函数的命名规则" class="headerlink" title="修改型函数的命名规则"></a>修改型函数的命名规则</h2><ul><li>如果函数负责更新数据库中的记录，那么函数名应当以单词update为前缀；</li><li>如果函数修改的是一些可枚举的状态，那么函数名应当以单词change为前缀。</li></ul><h1 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h1><ul><li>类的名称应当采用capital case的命名风格，例如<code>DatabaseConnection</code>；</li><li>类的名称应当以一个名词结尾；</li><li>如果类的存在是为了使用某种设计模式，那么类名应当可以反映在设计模式中所处的位置，例如在State模式中，代表具体状态的类的名称可以是<code>InitialState</code>、<code>UnpaidState</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://hackernoon.com/the-art-of-naming-variables-52f44de00aad" target="_blank" rel="noopener">The art of naming variables</a></li><li><a href="https://google.github.io/styleguide/jsguide.html" target="_blank" rel="noopener">Google JavaScript Style Guide</a></li><li><a href="https://en.wikipedia.org/wiki/Letter_case" target="_blank" rel="noopener">Letter case</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://liutos.github.io/tags/javascript/"/>
    
      <category term="naming convention" scheme="https://liutos.github.io/tags/naming-convention/"/>
    
      <category term="命名约定" scheme="https://liutos.github.io/tags/%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>带你见识一下传说中的Emacs</title>
    <link href="https://liutos.github.io/2019/11/21/Emacs%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/"/>
    <id>https://liutos.github.io/2019/11/21/Emacs走马观花/</id>
    <published>2019-11-21T14:06:51.000Z</published>
    <updated>2019-11-26T14:01:01.475Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过与VSCode作对比，来简单地介绍Emacs的基本功能、特点，以及一些插件。本文所说的Emacs指的是<a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">GNU Emacs</a>，下文简称Emacs。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>Emacs是一个文本编辑器，就像<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a>那样。它可以用来写代码、Markdown，以及其它任何纯文本；</li><li>在Emacs中打开的每个文件都有一个“主模式”（major mode），就像在VSCode中每个文件都可以设置一种语言模式；</li><li>除了主模式，在Emacs中还可以同时启用多个“次模式”（minor mode）。每一个次模式都可以提供自己的个性化功能；</li><li>可以用一门叫ELisp的编程语言为Emacs开发插件，扩展新功能。有许多现成的插件可以安装使用。</li></ul><h1 id="与VSCode对比"><a href="#与VSCode对比" class="headerlink" title="与VSCode对比"></a>与VSCode对比</h1><p>接下来通过与VSCode作对比，来直观地感受一下Emacs的基本功能。</p><h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>Emacs的官网上有一张应用截图</p><p><img src="/images/loading.png" data-original="https://www.gnu.org/software/emacs/images/teaser.png" alt="Emacs的官网截图"></p><p>第一眼看起来和VSCode还是非常不一样的</p><p><img src="/images/loading.png" data-original="https://code.visualstudio.com/assets/home/home-screenshot-mac.png" alt="VSCode的官网截图"></p><p>默认的Emacs界面上也会有菜单栏、工具栏，以及底下的状态栏（在Emacs中其实这一行叫做mode line），这些元素在VSCode上也可以找到。VSCode一般给人的印象还有侧边栏、资源管理器视图，以及minimap视图。Emacs的默认底色是白色，而VSCode则是黑色。</p><h2 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h2><p>Emacs有着丰富的快捷键（在Emacs中称之为key binding），但一些常见的功能的快捷键与VSCode等其它软件并不相同，如下表所示</p><table><thead><tr><th></th><th>Emacs</th><th>VSCode</th></tr></thead><tbody><tr><td>新建文件</td><td><code>C-x C-f</code></td><td><code>⌘n</code></td></tr><tr><td>打开文件或目录</td><td><code>C-x C-f</code></td><td><code>⌘o</code></td></tr><tr><td>保存文件</td><td><code>C-x C-s</code></td><td><code>⌘s</code></td></tr><tr><td>另存为</td><td><code>C-x C-w</code></td><td><code>⇧⌘s</code></td></tr><tr><td>撤销</td><td><code>C-x u</code></td><td><code>⌘z</code></td></tr><tr><td>剪切</td><td><code>C-w</code></td><td><code>⌘x</code></td></tr><tr><td>复制</td><td><code>M-w</code></td><td><code>⌘c</code></td></tr><tr><td>粘贴</td><td><code>C-y</code></td><td><code>⌘v</code></td></tr><tr><td>查找</td><td><code>C-s</code></td><td><code>⌘f</code></td></tr></tbody></table><p>在上表中，<code>C-x</code>表示先按住<code>control</code>键再按<code>x</code>键，<code>M-w</code>表示先按住<code>alt</code>键再按<code>w</code>键；<code>⌘</code>表示Mac上的<code>command</code>键、<code>⇧</code>表示<code>shift</code>键。此外，在Emacs中还可以使用<code>C-p</code>、<code>C-nn</code>、<code>C-b</code>，以及<code>C-f</code>键来往上、下、左、右四个方向移动光标，不需要移动手臂便可以在编辑的文件中到处移动，提高效率。VSCode也可以使用Emacs风格的快捷键，如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/VSCode%E8%AE%BE%E7%BD%AE%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84.png" alt=""></p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>VSCode自带美观大方的标签页功能，此外还可以将编辑器横向及纵向拆分，如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/VSCode%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5.png" alt=""></p><p>Emacs默认是没有标签页的功能的，但也支持切割编辑器，比如在下图中，就将编辑器分为左右两部分，并且左侧还被分为了上下两部分，这三个区域可以展示相同或不同的三个文件。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%88%87%E5%89%B2%E7%BC%96%E8%BE%91%E5%99%A8.png" alt=""></p><h2 id="默认的编程语言支持"><a href="#默认的编程语言支持" class="headerlink" title="默认的编程语言支持"></a>默认的编程语言支持</h2><p>VSCode支持非常多的编程语言，点击窗口右下角的语言模式便可以看到这份清单</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%BC%8F%E5%88%97%E8%A1%A8.png" alt=""></p><p>Emacs虽然没有这么一份清单，但支持的语言的数量也是不遑多让的。不过仅仅是默认的Emacs的话，对编程语言的支持没有VSCode那么开箱即用。例如，比起Emacs，VSCode默认对JavaScript的支持就很好，不仅仅有语法高亮、自动补全，并且还有基于变量类型、函数定义，以及导入的模块等信息实现的智能补全，而Emacs只有平凡的基于文本的语法高亮和自动补全罢了。</p><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>除了按下<code>⌘f</code>在文件内搜索之外，VSCode左侧工具栏中有一个名为搜索的入口，可以实现在打开的项目的所有文件中搜索特定内容的功能，并且还能用于替换。Emacs尽管没有这么一个GUI入口，但提供了<code>grep</code>命令来做到同样的事情。</p><p>在Emacs中按下<code>M-x</code>后输入<code>grep</code>并按回车，便会在minibuffer中等待使用者的进一步输入</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/grep%E5%91%BD%E4%BB%A4.png" alt=""></p><p>显然，这是直接调用了同名的命令行程序<code>grep</code>来实现搜索的，控制选项比VSCode的搜索功能要丰富许多。</p><h2 id="集成git"><a href="#集成git" class="headerlink" title="集成git"></a>集成git</h2><p>git可以说已经成为了日常开发中不可或缺的一个工具，如果能够在编辑器内方便地调用git的话会大大提高效率。VSCode通过左侧工具栏的源代码管理入口提供了这个功能，在Emacs中则是通过一个叫做<code>VC dir</code>的主模式提供这个功能。</p><p>在Emacs中按下快捷键<code>C-x v d</code>，然后输入使用git管理的项目的目录地址，便会打开一个新的编辑区域</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/VCdir%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>当处于这个模式下时，会有一些新的快捷键可以用，比如将光标移动到显示<code>edited</code>的行上按下等号键，可以打开另一个编辑区域查看该文件的修改内容；按下<code>m</code>键可以选中光标所在行的文件，然后按<code>v</code>键打开一个新的编辑区域来填写commit message，写完之后按下<code>C-c C-c</code>提交（即调用<code>git commit</code>命令）；最后按下<code>q</code>键可以退出<code>VC dir</code>模式的编辑区域。</p><h2 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h2><p>在VSCode中通过选中顶部菜单的“查看”，再点击“集成终端”，便可以打开命令行，然后像平时在其它的终端模拟器中那样使用命令。Emacs中也可以打开终端，方法是按下快捷键<code>M-x</code>然后输入<code>eshell</code>并回车，然后Emacs便会在当前窗口中打开一个名为<code>*eshell*</code>的编辑区域，显示命令行提示符和闪烁的光标，并等待使用者的进一步交互。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/eshell%E7%AA%97%E5%8F%A3.png" alt=""></p><p>有意思的是，这不是一个真正的命令行程序。比如在<code>*eshell*</code>中输入<code>which pwd</code>，输出结果是<code>eshell/pwd is a compiled Lisp function in ‘em-dirs.el’.</code>。也就是说，<code>eshell</code>中的某一些命令是Emacs重新实现的；此外，在<code>*eshell*</code>中可以运行Emacs的扩展语言——ELisp。比如输入<code>(+ 1 1)</code>并按下回车，会输出2。</p><h2 id="扩展能力"><a href="#扩展能力" class="headerlink" title="扩展能力"></a>扩展能力</h2><p>VSCode有一个<a href="https://marketplace.visualstudio.com/" target="_blank" rel="noopener">插件市场</a></p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E6%8F%92%E4%BB%B6%E5%B8%82%E5%9C%BA.jpg" alt=""></p><p>Emacs也有<a href="https://melpa.org/#/?q=yy" target="_blank" rel="noopener">一个</a>，不过得承认这个网页确实没有VSCode阵营的吸引人</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/melpa%E9%A6%96%E9%A1%B5.png" alt=""></p><p>在Emacs中按下<code>M-x</code>后输入<code>package-install</code>回车，Emacs会等待用户输入要安装的插件的名字——可以按下<code>⇥</code>键（Mac上的tab键）让Emacs尝试自动补全。确认名字无误后再按回车便可以安装使用了——但一般还需要做一些微调。</p><h1 id="炫酷的特性和插件"><a href="#炫酷的特性和插件" class="headerlink" title="炫酷的特性和插件"></a>炫酷的特性和插件</h1><p>除了上面与VSCode对比的一些基本操作以外，Emacs还有自身的一些特色功能，更有世上的众多优秀程序员为Emacs贡献了不胜枚举的优秀插件，它们极大地扩展了Emacs的能力，提升了文字编辑这项活动的效率，甚至超越了文字编辑。</p><h2 id="内置的功能"><a href="#内置的功能" class="headerlink" title="内置的功能"></a>内置的功能</h2><h3 id="颜色主题"><a href="#颜色主题" class="headerlink" title="颜色主题"></a>颜色主题</h3><p>Emacs也可以安装颜色主题来改变外观。我比较喜欢的一款主题是<code>gruvbox-light-soft</code>，只需要在Emacs的配置文件中写上<code>(load-theme &#39;gruvbox-light-soft t)</code>即可启用。在这个主题的<a href="https://github.com/greduan/emacs-theme-gruvbox" target="_blank" rel="noopener">仓库主页</a>可以看到一些效果图。</p><h3 id="将当前行居中或置顶"><a href="#将当前行居中或置顶" class="headerlink" title="将当前行居中或置顶"></a>将当前行居中或置顶</h3><p>Emacs可以用纯键盘的操作，将光标当前所在的行移到窗口的中间来显示。我特别喜欢这个功能，之前用VSCode时候一直想找这个功能的等价物，可惜没找着。在Emacs中，按下一次<code>control+l</code>，光标所在的行就会移动到窗口的中间；按下第二次，则移动到窗口的顶部展示；再按一次，会去到窗口的底部。如果再按一次，那么就跟第一次一样回到窗口的中间。每当Emacs正在编辑的内容已经去到屏幕上较低的位置时，我便会用这个功能校正一下。</p><p>比起用鼠标拖动滚动条或者用滚轮来滚动，我更喜欢这种表意更清晰的方式。</p><h3 id="纯键盘选中一片区域"><a href="#纯键盘选中一片区域" class="headerlink" title="纯键盘选中一片区域"></a>纯键盘选中一片区域</h3><p>在Emacs中可以用单击鼠标右键的方式来选中一片区域。当按下鼠标右键的时候，从光标所在的位置开始，到鼠标点击的位置结束的内容便会被选中。但我个人更喜欢纯键盘的操作，首先是在要选中的内容的起点按下快捷键<code>C-@</code>，这时候Emacs会在minibuffer中打印一条<code>Mark set</code>的消息。然后移动光标——用方向键还是用一系列的快捷键，甚至直接跳转到某一行也可以——到待选中的内容的终点。这时候加在起点和终点间的内容便会被选中，它们会有特殊的背景色，如下动图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E7%BA%AF%E9%94%AE%E7%9B%98%E9%80%89%E4%B8%AD%E4%B8%80%E7%89%87%E5%8C%BA%E5%9F%9F.gif" alt=""></p><p>因为按<code>C-@</code>实在是太别扭了，所以我将这个快捷键修改为了<code>M-SPC</code>（先按住<code>alt</code>键再按下空格键）。如果更喜欢鼠标操作的话，也可以像在VSCode中那样，在终点按住<code>shift</code>键再单击鼠标左键。</p><h3 id="矩形编辑"><a href="#矩形编辑" class="headerlink" title="矩形编辑"></a>矩形编辑</h3><p>在VSCode中按住<code>shift</code>和<code>option</code>键，再单击鼠标右键并拖动就可以选中一片矩形的区域，在Emacs中也支持这样的矩形编辑的功能。像下图这样，先定位到要选中为矩形区域的左上角按下<code>C-@</code>，再移动光标到目标矩形区域的右下角，最后按下快捷键<code>C-x r k</code>即可。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E7%9F%A9%E5%BD%A2%E7%BC%96%E8%BE%91%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA.gif" alt=""></p><h2 id="惊艳的插件"><a href="#惊艳的插件" class="headerlink" title="惊艳的插件"></a>惊艳的插件</h2><h3 id="快速跳转"><a href="#快速跳转" class="headerlink" title="快速跳转"></a>快速跳转</h3><p>Emacs本身支持跳转到指定的某一行，只需要按下快捷键<code>M-g M-g</code>然后输入行号并回车即可。但我一般是不显示行号的，所以这个功能其实比较少用。我使用一个名为<a href="https://github.com/abo-abo/avy" target="_blank" rel="noopener">avy</a>的插件来增强跳转功能，主要用的是它提供的<code>avy-goto-line</code>函数。依照这个插件的<a href="https://github.com/abo-abo/avy#avy-goto-line" target="_blank" rel="noopener">文档</a>，我为这个函数配置了快捷键<code>M-g f</code>，因此当我想要快速地跳转到屏幕上可见的区域中、离光标所在位置稍微有点远的行时，我便按下这个快捷键，然后按照提示按下相应的英文字母键既可，具体效果参见下面的演示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E4%BD%BF%E7%94%A8avy%E5%9C%A8%E8%A1%8C%E9%97%B4%E8%B7%B3%E8%BD%AC.gif" alt=""></p><h3 id="发出HTTP请求"><a href="#发出HTTP请求" class="headerlink" title="发出HTTP请求"></a>发出HTTP请求</h3><p>VSCode中有一个叫做<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank" rel="noopener">REST Client</a>的插件，Emacs中则是有一个叫做<a href="https://github.com/pashky/restclient.el" target="_blank" rel="noopener">restclient.el</a>的主模式。借助于<code>restclient.el</code>便可以直接在一个文本文件中写好自己要发出的HTTP请求的内容，然后一键触发。之前我是用<a href="https://insomnia.rest/" target="_blank" rel="noopener">Insomnia</a>这个工具的，尽管它很强大，但很多时候我不需要那么强大的功能，而且Insomnia消耗内存比较多，于是我便回到<code>restclient.el</code>上了。<code>restclient.el</code>的效果大致如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E4%BD%BF%E7%94%A8restclient.el%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82.png" alt=""></p><h3 id="增强的git集成功能"><a href="#增强的git集成功能" class="headerlink" title="增强的git集成功能"></a>增强的git集成功能</h3><p>尽管Emacs自带了<code>VC dir</code>这个主模式，但我更喜欢用<a href="https://github.com/magit/magit" target="_blank" rel="noopener">magit</a>这个插件，尤其是它的<code>magit-discard</code>功能，可以在查看代码的差异的过程中方便地舍弃一些不必要的修改（例如添加一行<code>console.log</code>的调用）。例如下图，通过按下<code>n</code>将光标移动到某一片修改上再按下<code>k</code>键，Emacs便会询问使用者是否要“丢弃”这一块改动。如果按下<code>y</code>，那么这一块被选中的区域的内容便会恢复到git当中未修改的状态。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/magit-discard.png" alt=""></p><h3 id="增强的文件内搜索功能"><a href="#增强的文件内搜索功能" class="headerlink" title="增强的文件内搜索功能"></a>增强的文件内搜索功能</h3><p>Emacs默认的搜索使用的是<code>search-forward</code>函数，插件<a href="https://github.com/abo-abo/swiper#swiper" target="_blank" rel="noopener">swiper</a>提供的功能更强大——不仅可以是字符串的完全匹配，也可以基于正则表达式来搜索，并且展示效果更直观，如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/swiper%E7%9A%84%E9%AB%98%E4%BA%AE%E5%92%8C%E9%A2%84%E8%A7%88.png" alt=""></p><h3 id="代码片段工具"><a href="#代码片段工具" class="headerlink" title="代码片段工具"></a>代码片段工具</h3><p>VSCode自带了一个“用户代码片段”的功能（通过顶部菜单“Code”，再选中“首选项”可以看到），可以用来定义一些短语，这些短语会在被选中的时候展开为完整的内容。Emacs有一个名为<a href="https://github.com/joaotavora/yasnippet" target="_blank" rel="noopener">yasnippet</a>的插件也提供了类似的功能，但定义代码片段的语法不同。并且，<code>yasnippet</code>支持在短语的定义中嵌入ELisp代码，扩展性远远高于只能使用字符串及占位符的VSCode的等价功能。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>Emacs还有许多有意思的插件，比如<a href="https://github.com/gonewest818/dimmer.el" target="_blank" rel="noopener">dimmer.el</a>，可以让当前没有获得焦点的窗口显示得黯淡一点；<a href="https://github.com/ledger/ledger-mode" target="_blank" rel="noopener">ledger-mode</a>，可以用Emacs来记账。这里就不一一列举了，各位有兴趣的话可以自己摸索Emacs，相信会遇到自己喜欢的插件的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>比起家大业大的VSCode，Emacs算不上是开箱即用。它没有VSCode那么友好的界面和平易近人的操作方式，人气也没有VSCode那么旺，当遇到问题的时候可能没那么好求助到人，并且学习曲线（小众的预设快捷键、冷门的扩展语言）也比较高。但Emacs的扩展能力很强，现有的插件已经很丰富了，可以满足大部分的需求，遇到问题也可以到有模有样的<a href="https://emacs-china.org/" target="_blank" rel="noopener">论坛</a>求助。如果喜欢折腾的话，Emacs会是一个不错的选择，至少我自己用得很开心。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="vscode" scheme="https://liutos.github.io/tags/vscode/"/>
    
      <category term="对比" scheme="https://liutos.github.io/tags/%E5%AF%B9%E6%AF%94/"/>
    
      <category term="工具" scheme="https://liutos.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>将二叉树写到磁盘上</title>
    <link href="https://liutos.github.io/2019/10/29/%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%8A/"/>
    <id>https://liutos.github.io/2019/10/29/将二叉树写到磁盘上/</id>
    <published>2019-10-29T14:51:29.000Z</published>
    <updated>2019-10-29T15:06:07.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一阵子很好奇一个问题：MySQL到底是如何将内存中的B+树写入到磁盘文件中的。明明是一棵树，要怎样才能存储成线性的字节流呢？干脆自己动手，试着实现一个简单的版本，来帮助自己摸点门道。虽然想法很不错，不过一上来就面对噩梦级别的B+树也太为难人了，因此就先从简单的二叉树入手吧。</p><h2 id="出来吧，二叉搜索树"><a href="#出来吧，二叉搜索树" class="headerlink" title="出来吧，二叉搜索树"></a>出来吧，二叉搜索树</h2><p>本文使用Common Lisp进行开发。</p><p>首先定义这棵二叉搜索树的节点的类型</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defclass</span> &lt;node&gt; ()</span><br><span class="line">  ((<span class="name">data</span></span><br><span class="line">    <span class="symbol">:accessor</span> node-data</span><br><span class="line">    <span class="symbol">:initarg</span> <span class="symbol">:data</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"节点中的数据"</span>)</span><br><span class="line">   (<span class="name">left</span></span><br><span class="line">    <span class="symbol">:accessor</span> node-left</span><br><span class="line">    <span class="symbol">:initarg</span> <span class="symbol">:left</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"左子树"</span>)</span><br><span class="line">   (<span class="name">right</span></span><br><span class="line">    <span class="symbol">:accessor</span> node-right</span><br><span class="line">    <span class="symbol">:initarg</span> <span class="symbol">:right</span></span><br><span class="line">    <span class="symbol">:documentation</span> <span class="string">"右子树"</span>))</span><br><span class="line">  (<span class="symbol">:documentation</span> <span class="string">"二叉搜索树的节点"</span>))</span><br></pre></td></tr></table></figure><p>基于节点进一步定义二叉树的类型</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">deftype</span> &lt;bst&gt; () '(or &lt;node&gt; null))</span><br></pre></td></tr></table></figure><p>如此一来，要创建节点和空树都是浑然天成的事情了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> make-node (<span class="name">data</span> left right)</span><br><span class="line">  <span class="string">"创建一个二叉搜索树的节点"</span></span><br><span class="line">  (<span class="name">check-type</span> data integer)</span><br><span class="line">  (<span class="name">check-type</span> left &lt;bst&gt;)</span><br><span class="line">  (<span class="name">check-type</span> right &lt;bst&gt;)</span><br><span class="line">  (<span class="name">make-instance</span> '&lt;node&gt;</span><br><span class="line">                 <span class="symbol">:data</span> data</span><br><span class="line">                 <span class="symbol">:left</span> left</span><br><span class="line">                 <span class="symbol">:right</span> right))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> make-empty-bst ()</span><br><span class="line">  <span class="string">"创建一颗空树"</span></span><br><span class="line">  <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>要判断一颗二叉树是否为空树只需要简单包装一下<code>cl:null</code>函数即可</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> empty-bst-p (<span class="name">bst</span>)</span><br><span class="line">  <span class="string">"检查BST是否为一个空的二叉搜索树"</span></span><br><span class="line">  (<span class="name">null</span> bst))</span><br></pre></td></tr></table></figure><p>为了生成必要的测试数据，需要提供一个往二叉树中添加数据的功能</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> insert-node (<span class="name">bst</span> data)</span><br><span class="line">  <span class="string">"往一颗现有的二叉搜索树BST中加入一个数据，并返回这颗新的二叉搜索树"</span></span><br><span class="line">  (<span class="name">check-type</span> bst &lt;bst&gt;)</span><br><span class="line">  (<span class="name">check-type</span> data integer)</span><br><span class="line">  (<span class="name">when</span> (<span class="name">empty-bst-p</span> bst)</span><br><span class="line">    (<span class="name">return-from</span> insert-node</span><br><span class="line">      (<span class="name">make-node</span> data</span><br><span class="line">                 (<span class="name">make-empty-bst</span>)</span><br><span class="line">                 (<span class="name">make-empty-bst</span>))))</span><br><span class="line"></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">&lt;</span> data (<span class="name">node-data</span> bst))</span><br><span class="line">         (<span class="name">setf</span> (<span class="name">node-left</span> bst)</span><br><span class="line">               (<span class="name">insert-node</span> (<span class="name">node-left</span> bst) data))</span><br><span class="line">         bst)</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">node-right</span> bst)</span><br><span class="line">               (<span class="name">insert-node</span> (<span class="name">node-right</span> bst) data))</span><br><span class="line">         bst)))</span><br></pre></td></tr></table></figure><p>有了<code>insert-node</code>便可以从空树开始构筑起一棵二叉搜索树</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> create-bst (<span class="name">numbers</span>)</span><br><span class="line">  <span class="string">"根据NUMBERS中的数值构造一棵二叉搜索树。相当于NUMBERS中的数字从左往右地插入到一棵空的二叉搜索树中"</span></span><br><span class="line">  (<span class="name">check-type</span> numbers list)</span><br><span class="line">  (<span class="name">reduce</span> #'(lambda (bst data)</span><br><span class="line">              (insert-node bst data))</span><br><span class="line">          numbers</span><br><span class="line">          <span class="symbol">:initial-value</span> (<span class="name">make-empty-bst</span>)))</span><br></pre></td></tr></table></figure><p>现在来生成稍后测试用的二叉树</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> *bst* (<span class="name">create-bst</span> '(<span class="number">2</span> <span class="number">1</span> <span class="number">3</span>)))</span><br></pre></td></tr></table></figure><p>模仿命令行工具<code>tree</code>的格式，提供一个打印二叉树的功能</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> print-spaces (<span class="name">n</span>)</span><br><span class="line">  <span class="string">"打印N个空格"</span></span><br><span class="line">  (<span class="name">dotimes</span> (<span class="name">i</span> n)</span><br><span class="line">    (<span class="name">declare</span> (<span class="name">ignorable</span> i))</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">" "</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> print-bst (<span class="name">bst</span>)</span><br><span class="line">  <span class="string">"打印二叉树BST到标准输出"</span></span><br><span class="line">  (<span class="name">check-type</span> bst &lt;bst&gt;)</span><br><span class="line">  (<span class="name">labels</span> ((<span class="name">aux</span> (<span class="name">bst</span> depth)</span><br><span class="line">             (<span class="name">cond</span> ((<span class="name">empty-bst-p</span> bst)</span><br><span class="line">                    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"^~%"</span>))</span><br><span class="line">                   (<span class="name">t</span></span><br><span class="line">                    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~D~%"</span> (<span class="name">node-data</span> bst))</span><br><span class="line">                    (<span class="name">print-spaces</span> (<span class="name">*</span> <span class="number">2</span> depth))</span><br><span class="line">                    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"|-"</span>)</span><br><span class="line">                    (<span class="name">aux</span> (<span class="name">node-left</span> bst) (<span class="number">1</span>+ depth))</span><br><span class="line">                    (<span class="name">print-spaces</span> (<span class="name">*</span> <span class="number">2</span> depth))</span><br><span class="line">                    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"`-"</span>)</span><br><span class="line">                    (<span class="name">aux</span> (<span class="name">node-right</span> bst) (<span class="number">1</span>+ depth))))))</span><br><span class="line">    (<span class="name">aux</span> bst <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><p>二叉树<code>*bst*</code>的打印结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">|-1</span><br><span class="line">  |-^</span><br><span class="line">  `-^</span><br><span class="line">`-3</span><br><span class="line">  |-^</span><br><span class="line">  `-^</span><br></pre></td></tr></table></figure><h2 id="接下来终于要写盘了"><a href="#接下来终于要写盘了" class="headerlink" title="接下来终于要写盘了"></a>接下来终于要写盘了</h2><p>总算要开始实现将二叉树写入磁盘文件的功能了。将内存中的二叉树写入到文件中，相当于将树形的数据结构转换为线性的存储结构——毕竟磁盘上的文件可以认为就是线性的字节流。在这块字节流中，除了要保存每一个节点的数据之外，同样重要的还有节点间的父子关系。</p><p>有很多种写盘的方法。比如说，可以模仿<a href="https://www.jianshu.com/p/934d95a80e6d" target="_blank" rel="noopener">树的顺序存储结构</a>将二叉树序列化到磁盘上。以上面的二叉树<code>*bst*</code>为例，它是一棵满二叉树，如果采用顺序存储，那么首先分配一个长度为3的数组，在下标为0的位置存储根节点的数字2，在下标为1的位置存储左孩子的数字1，在下标为2的位置存储右孩子的数字3，如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/bst.png" alt=""></p><p>推广到高度为<code>h</code>的二叉树，则需要长度为$2^h-1$的数组来存储所有节点的数据。假设每一个节点的数据都是32位整数类型，那么一棵高度为<code>h</code>的二叉树在磁盘上便需要占据$4·(2^h-1)$个字节。这个做法虽然可行，但比较浪费存储空间。它将节点间的父子关系用隐式的下标关系来代替，节省了存储左右子树的“指针”所需的空间，比较适合存储满二叉树或接近满的二叉树。</p><p>对于稀疏的二叉树，如果在序列化后的字节流中显式地记录节点间的父子关系，便可以节省很多不存在的节点所占据的存储空间。比如说，对于每一个节点，都序列化为磁盘上的12个字节：</p><ol><li>下标为0到3的4个字节，存储的是节点中的数据；</li><li>下标为4到7的4个字节，存储的是节点的左子树在文件中的偏移；</li><li>下标为8到11的4个字节，存储的是节点的右子树在文件中的偏移</li></ol><p>如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/bst2.png" alt=""></p><p>上面的数组表示磁盘上的一个文件，每一个方格为一个字节，每个方格在文件内的偏移从左往右依次增大。由于采用后序遍历的方式依次序列化二叉树中的节点数据和指针，因此左孩子首先被写入文件，然后是右孩子，最后才是根节点。推广到所有的二叉树，便是先将左右子树追加写入磁盘文件，再将根节点的数据、左子树根节点在文件内的偏移，以及右子树根节点在文件内的偏移追加到文件末尾；如果左右子树是空的，那么以偏移0表示。</p><p>这是一个递归的过程，而每一次递归调用应当返回两个值：</p><ol><li>写入的总字节数<code>bytes</code></li><li>根节点所占据的字节数<code>root-bytes</code></li></ol><p><code>bytes</code>便是右子树开始写入时的文件偏移，必须依靠这个信息确定右子树的每一个节点在文件内的偏移；使用<code>bytes</code>减去<code>root-bytes</code>，再加上左子树开始写入时的偏移量，便可以得知左子树的根节点在文件内的位置。最终实现写盘功能的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 定义序列化二叉树的函数</span></span><br><span class="line">(<span class="name">defun</span> write-fixnum/32 (<span class="name">n</span> stream)</span><br><span class="line">  <span class="string">"将定长数字N输出为32位的比特流"</span></span><br><span class="line">  (<span class="name">check-type</span> n fixnum)</span><br><span class="line">  (<span class="name">check-type</span> stream stream)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">octets</span> (<span class="name">bit-smasher</span><span class="symbol">:octets&lt;-</span> n)))</span><br><span class="line">    (<span class="name">setf</span> octets (<span class="name">coerce</span> octets 'list))</span><br><span class="line">    (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">-</span> <span class="number">4</span> (<span class="name">length</span> octets)))</span><br><span class="line">      (<span class="name">declare</span> (<span class="name">ignorable</span> i))</span><br><span class="line">      (<span class="name">push</span> <span class="number">0</span> octets))</span><br><span class="line">    (<span class="name">dolist</span> (<span class="name">n</span> octets)</span><br><span class="line">      (<span class="name">write-byte</span> n stream))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;; 这是一个递归的函数，写入一棵二叉树的逻辑，就是先写入左子树，再写入右子树，最后写入根节点，也就是后序遍历</span></span><br><span class="line"><span class="comment">;;; 由于要序列化为字节流，因此需要用字节流中的偏移的形式代替内存中的指针，实现从根节点指向左右子树</span></span><br><span class="line"><span class="comment">;;; offset是开始序列化bst的时候，在字节流中所处的偏移，同时也是这颗树第一个被写入的节点在字节流中的偏移</span></span><br><span class="line"><span class="comment">;;; 每次调用write-bst-bytes后的返回值有两个，分别为二叉树一共写入的字节数，以及根节点所占的字节数</span></span><br><span class="line">(<span class="name">defun</span> write-bst-bytes (<span class="name">bst</span> stream offset)</span><br><span class="line">  <span class="string">"将二叉树BST序列化为字节写入到流STREAM中。OFFSET表示BST的第一个字节距离文件头的偏移"</span></span><br><span class="line">  (<span class="name">check-type</span> bst &lt;bst&gt;)</span><br><span class="line">  (<span class="name">check-type</span> stream stream)</span><br><span class="line">  (<span class="name">check-type</span> offset integer)</span><br><span class="line">  (<span class="name">when</span> (<span class="name">empty-bst-p</span> bst)</span><br><span class="line">    (<span class="name">return-from</span> write-bst-bytes</span><br><span class="line">      (<span class="name">values</span> <span class="number">0</span> <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">  <span class="comment">;; 以后序遍历的方式处理整棵二叉树</span></span><br><span class="line">  (<span class="name">multiple-value-bind</span> (<span class="name">left-bytes</span> left-root-bytes)</span><br><span class="line">      (<span class="name">write-bst-bytes</span> (<span class="name">node-left</span> bst) stream offset)</span><br><span class="line"></span><br><span class="line">    (<span class="name">multiple-value-bind</span> (<span class="name">right-bytes</span> right-root-bytes)</span><br><span class="line">        (<span class="name">write-bst-bytes</span> (<span class="name">node-right</span> bst) stream (<span class="name">+</span> offset left-bytes))</span><br><span class="line"></span><br><span class="line">      (<span class="name">write-fixnum/32</span> (<span class="name">node-data</span> bst) stream)</span><br><span class="line">      (<span class="name">if</span> (<span class="name">zerop</span> left-bytes)</span><br><span class="line">          (<span class="name">write-fixnum/32</span> <span class="number">0</span> stream)</span><br><span class="line">          (<span class="name">write-fixnum/32</span> (<span class="name">-</span> (<span class="name">+</span> offset left-bytes) left-root-bytes) stream))</span><br><span class="line">      (<span class="name">if</span> (<span class="name">zerop</span> right-bytes)</span><br><span class="line">          (<span class="name">write-fixnum/32</span> <span class="number">0</span> stream)</span><br><span class="line">          (<span class="name">write-fixnum/32</span> (<span class="name">-</span> (<span class="name">+</span> offset left-bytes right-bytes) right-root-bytes) stream))</span><br><span class="line">      <span class="comment">;; 之所以要加上12个字节，是因为在写完了左右子树之后，就紧邻着写根节点了。因此，根节点就是在从right-node-offset的位置，接着写完右子树的根节点后的位置，而右子树的根节点占12个字节</span></span><br><span class="line">      (<span class="name">let</span> ((<span class="name">root-bytes</span> (<span class="name">*</span> <span class="number">3</span> <span class="number">4</span>)))</span><br><span class="line">        (<span class="name">values</span> (<span class="name">+</span> left-bytes right-bytes root-bytes)</span><br><span class="line">                root-bytes)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> write-bst-to-file (<span class="name">bst</span> filespec)</span><br><span class="line">  <span class="string">"将二叉树BST序列化为字节流并写入到文件中"</span></span><br><span class="line">  (<span class="name">check-type</span> bst &lt;bst&gt;)</span><br><span class="line">  (<span class="name">with-open-file</span> (<span class="name">stream</span> filespec</span><br><span class="line">                          <span class="symbol">:direction</span> <span class="symbol">:output</span></span><br><span class="line">                          <span class="symbol">:element-type</span> '(unsigned-byte <span class="number">8</span>)</span><br><span class="line">                          <span class="symbol">:if-exists</span> <span class="symbol">:supersede</span>)</span><br><span class="line">    (<span class="name">write-fixnum/32</span> (<span class="name">char-code</span> #\m) stream)</span><br><span class="line">    (<span class="name">write-fixnum/32</span> (<span class="name">char-code</span> #\y) stream)</span><br><span class="line">    (<span class="name">write-fixnum/32</span> (<span class="name">char-code</span> #\b) stream)</span><br><span class="line">    (<span class="name">write-fixnum/32</span> (<span class="name">char-code</span> #\s) stream)</span><br><span class="line">    (<span class="name">write-fixnum/32</span> (<span class="name">char-code</span> #\<span class="literal">t</span>) stream)</span><br><span class="line">    (<span class="name">write-bst-bytes</span> bst stream (<span class="name">*</span> <span class="number">5</span> <span class="number">4</span>))))</span><br></pre></td></tr></table></figure><p>现在可以将<code>*bst*</code>写入文件了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">write-bst-to-file</span> *bst* <span class="string">"/tmp/bst.dat"</span>)</span><br></pre></td></tr></table></figure><p>使用<code>hexdump</code>验证写入的效果</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84.png" alt=""></p><p>文件最开始的五个字节依次存储着字符串<code>&quot;mybst&quot;</code>的ASCII码，为的就是让最早被写入文件中的根节点——也就是二叉树最左下角的节点——的偏移不为0，以免在后续反序列化的时候，从该节点的父节点中读到左子树的偏移为0——这样会被误认为是一棵空树的。</p><p>有哪里写得不好的还请各位读者不吝赐教。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
      <category term="binarysearchtree" scheme="https://liutos.github.io/tags/binarysearchtree/"/>
    
      <category term="binarytree" scheme="https://liutos.github.io/tags/binarytree/"/>
    
      <category term="二叉搜索树" scheme="https://liutos.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://liutos.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="序列化" scheme="https://liutos.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在Emacs中搭建笔记查阅系统的尝试</title>
    <link href="https://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <id>https://liutos.github.io/2019/10/20/在Emacs中搭建笔记查阅系统的尝试/</id>
    <published>2019-10-20T06:42:33.000Z</published>
    <updated>2019-10-20T06:48:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>给Emacs写插件有种痛并快乐着的感觉。虽然这个发挥创意的过程很有趣，但是Elisp写起来总有种别扭的感觉。一方面，我把它当成是Common Lisp，写的时候没有觉得“这个用法可能会有问题”；另一方面，它又不是普通的写lisp代码，还要一边写一边摸索Emacs中的一些概念。不过总体而言，还是挺好玩的，除了没有一个像模像样的REPL之外。</p><h2 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h2><p>我用Emacs记录了不少的“笔记”。虽说我自己将其称为笔记，但是它们更像是我把遇到的一些问题和解决方法给记录下来，而没有太多自己的感悟。它们的外观倒是高度的一致，见下图</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E7%94%A8org-mode%E8%AE%B0%E7%9A%84%E7%AC%94%E8%AE%B0.png" alt=""></p><p>（第一次尝试给自己的图片打水印，有点好玩）每一个一级条目都是一个问题，并且这个文件中只有一级条目。而条目下的内容则是对标题的问题的回答。其中还有代码块——也就是写着BEGIN_SRC和END_SRC的那部分。用org-mode来记录笔记有几个好处，其中一个便是可以在笔记中插入任何Emacs支持的编程语言代码片段并具备语法高亮。当然了，还有一个巨大的优势，便是org-mode尽管看似花里胡哨，骨子里却是正统的纯文本文件，它可以很方便地在其它工具中处理。</p><p>而我用来处理的其中一个工具便是ElasticSearch。比如说，上图的第一条笔记，在ElasticSearch中存成了下面这样的结构</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E6%9F%A5%E7%9C%8BElasticSearch%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0.png" alt=""></p><p>本来我是写了一个Alfred的Workflow来查询ElasticSearch的，但是奈何Workflow那种一行行的方式展示org-mode格式的笔记不太友好，因此便打算直接在Emacs中查询并查看笔记内容。</p><h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>为了可以在Emacs中查看笔记内容，我打算借助于Helm的力量。<a href="https://emacs-helm.github.io/helm/" target="_blank" rel="noopener">Helm</a>是Emacs的一个补全的框架，可以用来呈现一系列的候选项，然后选中后触发一些什么动作。我期望的形式，是在Emacs中按下某种快捷键或者输入某个命令行，可以在minibuffer中输入自己要查询的内容，然后Emacs查询ElasticSearch并最终通过Helm来呈现这些查询内容匹配的笔记条目。目前的成果是下面这样子的</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/lt-ask%E7%9A%84%E5%80%99%E9%80%89%E5%88%97%E8%A1%A8.png" alt=""></p><p>具体的做法其实也很简单。首先，要知道Helm是如何被使用的。通过这篇<a href="https://wikemacs.org/wiki/How_to_write_helm_extensions" target="_blank" rel="noopener">文档</a>，初步了解到只需要定一个变量，并通过<code>:sources</code>关键字参数传递给<code>helm</code>这个函数即可。我所定义的传递给<code>helm</code>函数的“source”如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> faq-helm-sources</span><br><span class="line">      `((name . <span class="string">"FAQ at Emacs"</span>)</span><br><span class="line">        (candidates . faq-candidates)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    (let ((url (format <span class="string">"http://localhost:9200/faq/_doc/%s"</span> candidate)))</span><br><span class="line">                      (browse-url url))))))</span><br></pre></td></tr></table></figure><p>其中<code>faq-candidates</code>的作用便是根据minibuffer中的关键字查询ElasticSearch并组织好一个结构返回给<code>helm</code>。需要注意的是，<code>faq-candidates</code>必须是一个无参的函数才行，但输入的数据又偏偏需要从minibuffer中获取。因此，我的做法是约定一个变量<code>faq-query</code>，在调用<code>helm</code>之前首先调用<code>read-from-minibuffer</code>函数读取输入，然后将输入的字符串赋值给<code>faq-query</code>，之后当<code>helm</code>开始使用这个source的时候，<code>faq-candidates</code>函数便不需要参数，而可以直接从<code>faq-query</code>中拿到自己需要的搜索内容向ElasticSearch请求了。当然了，如果有像Common Lisp动态作用域的话，也就不需要定义这么一个全局变量了，对Emacs全局的侵入会更少一点。</p><p>目前能够做到的也仅仅是查询ElasticSearch，并在选中某个条目并按下回车的时候打开浏览器来查看而已，之后应该会继续完善。目前的完整代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 调用ElasticSearch查询笔记</span></span><br><span class="line">(<span class="name">require</span> 'request)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq (<span class="name">query</span>)</span><br><span class="line">  <span class="string">"向ElasticSearch查询QUERY匹配的笔记"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">response</span>))</span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:9200/faq/_search"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">encode-coding-string</span></span><br><span class="line">            (<span class="name">json-encode</span></span><br><span class="line">             (<span class="name">list</span></span><br><span class="line">              (<span class="name">cons</span> <span class="string">"query"</span> (<span class="name">list</span></span><br><span class="line">                             (<span class="name">cons</span> <span class="string">"multi_match"</span> (<span class="name">list</span></span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"fields"</span> (<span class="name">list</span> <span class="string">"answer"</span> <span class="string">"question"</span>))</span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"query"</span> query)))))))</span><br><span class="line">            'utf-8)</span><br><span class="line">     <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">     <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">setq</span> data (<span class="name">decode-coding-string</span> data 'utf-8))</span><br><span class="line">                 (<span class="name">setq</span> response (<span class="name">json-read-from-string</span> data))))</span><br><span class="line">     <span class="symbol">:sync</span> <span class="literal">t</span>)</span><br><span class="line">    response))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> make-faq-candidates (<span class="name">response</span>)</span><br><span class="line">  <span class="string">"将查询ElasticSearch的结果构造为helm可以识别的candidates格式"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">hits</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits response))))))</span><br><span class="line">    (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">doc</span>)</span><br><span class="line">              (<span class="name">let</span> ((<span class="name">_source</span> (<span class="name">cdr</span> (<span class="name">assoc</span> '_source doc))))</span><br><span class="line">                (<span class="name">cons</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'question _source))</span><br><span class="line">                      (<span class="name">cdr</span> (<span class="name">assoc</span> '_id doc)))))</span><br><span class="line">            hits)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> faq-query <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq-candidates ()</span><br><span class="line">  (<span class="name">make-faq-candidates</span> (<span class="name">faq</span> faq-query)))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> faq-helm-sources</span><br><span class="line">      `((name . <span class="string">"FAQ at Emacs"</span>)</span><br><span class="line">        (candidates . faq-candidates)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    (let ((url (format <span class="string">"http://localhost:9200/faq/_doc/%s"</span> candidate)))</span><br><span class="line">                      (browse-url url))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-ask ()</span><br><span class="line">  <span class="string">"交互式地从minibuffer中读取笔记的关键词并展示选项"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">content</span> (<span class="name">read-from-minibuffer</span> <span class="string">"笔记关键词："</span>)))</span><br><span class="line">    (<span class="name">setq</span> faq-query content)</span><br><span class="line">    (<span class="name">helm</span> <span class="symbol">:sources</span> '(faq-helm-sources))))</span><br></pre></td></tr></table></figure><p>有不少值得吐槽的地方，不过都先按下不表吧，各位读者有兴趣的话可以留言交流一下XD</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="elasticsearch" scheme="https://liutos.github.io/tags/elasticsearch/"/>
    
      <category term="note-taking" scheme="https://liutos.github.io/tags/note-taking/"/>
    
      <category term="笔记" scheme="https://liutos.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何编译defun</title>
    <link href="https://liutos.github.io/2019/10/11/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91defun/"/>
    <id>https://liutos.github.io/2019/10/11/如何编译defun/</id>
    <published>2019-10-11T14:32:54.000Z</published>
    <updated>2019-10-11T14:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解如何编译<code>defun</code>。在Common Lisp中，<code>defun</code>用于定义函数。例如，下列的代码定义了函数<code>foo</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foo (<span class="name">a</span>)</span><br><span class="line">  <span class="string">"一个名为FOO的函数"</span></span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> a))</span><br><span class="line">  (<span class="number">1</span>+ <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>在<code>defun</code>的<a href="http://clhs.lisp.se/Body/m_defun.htm" target="_blank" rel="noopener">语法</a>中，第一行的字符串是这个函数的文档，可以用<code>documentation</code>函数获取；第二行是declaration。（不管是documentation还是declaration，也许要等到自举的那一天才能够支持了）目前只打算支持如下这般朴素的<code>defun</code>用法：</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> a (<span class="name">x</span>)</span><br><span class="line">  (<span class="name">+</span> x <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>可以想象，编译上面这段代码后，首先应当有一个函数名的label，比如就叫做<code>A</code>。紧接着这个label的是函数体的代码，按照我这赶鸭子上架的做法看回来的说法，起码要有参数的处理——比如从寄存器中复制到内存中，还要有callee-saved的寄存器的保护，函数体的处理逻辑代码，以及收拾残局并返回到调用者的代码等等。</p><p>慢着，要将寄存器中的参数值复制到内存中，是需要在栈上开辟空间的。要这么做的话，就得先计算出一共需要多少字节的存储空间，还要计算出每一个参数在栈上的偏移。并且，为了可以在函数体内正确地使用参数的偏移，还需要提供一个环境（类似于编译原理的教程中常常出现的符号表）以便在递归地编译函数体的过程中查询才行——这一系列的东西对<code>jjcc2</code>的改动比较大。</p><p>所以，我用了一个简单但局限性较大的方法：将每一个参数都视为一个同名的全局变量。这样寄存器中的参数值就不需要复制到栈上，而是直接复制到参数名所代表的内存地址中。</p><p>如此，要编译<code>defun</code>就很简单了。拓展后的<code>jjcc2</code>函数的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(get-operand expr <span class="number">0</span>))))</span><br><span class="line">                 globals))</span><br><span class="line">        <span class="comment">;; ((eq (first expr) '_exit)</span></span><br><span class="line">        <span class="comment">;;  ;; 因为知道_exit只需要一个参数，所以将它的第一个操作数塞到EDI寄存器里面就可以了</span></span><br><span class="line">        <span class="comment">;;  ;; <span class="doctag">TODO:</span> 更好的写法，应该是有一个单独的函数来处理这种参数传递的事情（以符合calling convention的方式）</span></span><br><span class="line">        <span class="comment">;;  `((movl ,(get-operand expr 0) %edi)</span></span><br><span class="line">        <span class="comment">;;    (movl #x2000001 %eax)</span></span><br><span class="line">        <span class="comment">;;    (syscall)))</span></span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '&gt;)</span><br><span class="line">         <span class="comment">;; 为了可以把比较之后的结果放入到EAX寄存器中，以我目前不完整的汇编语言知识，可以想到的方法如下</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-greater-than</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           <span class="comment">;; 根据这篇文章（https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions）中的说法，大于号左边的数字应该放在CMP指令的第二个操作数中，右边的放在第一个操作数中</span></span><br><span class="line">           `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">             (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">             (cmpl %ebx %eax)</span><br><span class="line">             (jg ,label-greater-than)</span><br><span class="line">             (movl $<span class="number">0</span> %eax)</span><br><span class="line">             (jmp ,label-end)</span><br><span class="line">             ,label-greater-than</span><br><span class="line">             (movl $<span class="number">1</span> %eax)</span><br><span class="line">             ,label-end)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'if)</span><br><span class="line">         <span class="comment">;; 假定if语句的测试表达式的结果也是放在%eax寄存器中的，所以只需要拿%eax寄存器中的值跟0做比较即可（类似于C语言）</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-else</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">second</span> expr) globals)</span><br><span class="line">                   `((cmpl $<span class="number">0</span> %eax)</span><br><span class="line">                     (je ,label-else))</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                   `((jmp ,label-end)</span><br><span class="line">                     ,label-else)</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">fourth</span> expr) globals)</span><br><span class="line">                   `(,label-end))))</span><br><span class="line">        ((<span class="name">member</span> (<span class="name">first</span> expr) '(_exit exit))</span><br><span class="line">         <span class="comment">;; 暂时以硬编码的方式识别一个函数是否来自于C语言的标准库</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           ;; 据这篇回答（https<span class="symbol">://stackoverflow</span>.com/questions/12678230/how-to-print-argv0-in-nasm）所说，在macOS上调用C语言函数，需要将栈对齐到<span class="number">16</span>位</span><br><span class="line">           ;; 假装要对齐的是栈顶地址。因为栈顶地址是往低地址增长的，所以只需要将地址的低<span class="number">16</span>位抹掉就可以了</span><br><span class="line">           (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">           (call :|_exit|)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'return)</span><br><span class="line">         <span class="comment">;; 由于经过inside-out的处理之后，return的参数就是一个“原子”了，因此不再需要调用jjcc2来处理一遍</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (ret)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'defun)</span><br><span class="line">         <span class="comment">;; defun的编译过程是：</span></span><br><span class="line">         <span class="comment">;; 1. 根据函数参数生成相应的MOV指令</span></span><br><span class="line">         <span class="comment">;; 2. 编译body的部分，生成一系列的汇编代码的S表达式</span></span><br><span class="line">         <span class="comment">;; 3. 以defun的函数名和刚生成的S表达式组成cons</span></span><br><span class="line">         <span class="comment">;; 4. 添加到*udfs*中</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">init-asm</span> '())</span><br><span class="line">               (<span class="name">params</span> (<span class="name">caddr</span> expr))</span><br><span class="line">               (<span class="name">registers</span> '(%rdi %rsi %rdx %rcx %r8 %r9)))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">param</span> params)</span><br><span class="line">             (<span class="name">setf</span> (<span class="name">gethash</span> param globals) <span class="number">0</span>))</span><br><span class="line">           <span class="comment">;; 生成一系列MOV指令，将寄存器中的参数值放入到特定的内存位置中</span></span><br><span class="line">           (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">length</span> params))</span><br><span class="line">             (<span class="name">when</span> (<span class="name">nth</span> i registers)</span><br><span class="line">               (<span class="name">push</span> `(movq ,(nth i registers)</span><br><span class="line">                            ,(format <span class="literal">nil</span> <span class="string">"~A(%RIP)"</span> (nth i params)))</span><br><span class="line">                     init-asm)))</span><br><span class="line"></span><br><span class="line">           (<span class="name">let</span> ((<span class="name">asm</span> (<span class="name">jjcc2</span> (<span class="name">cons</span> 'progn (<span class="name">cdddr</span> expr)) globals)))</span><br><span class="line">             (<span class="name">push</span> (<span class="name">cons</span> (<span class="name">cadr</span> expr)</span><br><span class="line">                         (<span class="name">append</span> init-asm asm '((ret))))</span><br><span class="line">                   *udfs*)</span><br><span class="line">             <span class="literal">nil</span>)))</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         <span class="comment">;; 按照这里（https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html）所给的函数调用约定来传递参数</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">instructions</span> '())</span><br><span class="line">               (<span class="name">registers</span> '(%rdi %rsi %rdx %rcx %r8 %r9)))</span><br><span class="line">           (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">length</span> (<span class="name">rest</span> expr)))</span><br><span class="line">             (<span class="name">if</span> (<span class="name">nth</span> i registers)</span><br><span class="line">                 (<span class="name">push</span> `(movq ,(get-operand expr i) ,(nth i registers)) instructions)</span><br><span class="line">                 (<span class="name">push</span> `(pushq ,(get-operand expr i)) instructions)))</span><br><span class="line">           <span class="comment">;; 经过一番尝试后，我发现必须在完成函数调用后恢复RSP寄存器才不会导致段错误</span></span><br><span class="line">           `(,@(nreverse instructions)</span><br><span class="line">             (pushq %rsp)</span><br><span class="line">             (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">             (call ,(first expr))</span><br><span class="line">             (popq %rsp))))))</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用了一个叫做<code>*udfs*</code>的变量。它在我的<code>.lisp</code>文件中的定义如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defparameter</span> *udfs*</span><br><span class="line">  (<span class="name">list</span> (<span class="name">cons</span> '|lt1|</span><br><span class="line">              '((movl <span class="number">1</span> %eax)</span><br><span class="line">                (ret)))))</span><br></pre></td></tr></table></figure><p>实际上它就是一个很简单的、函数名到函数体代码的alist而已，在生成汇编代码字符串的时候，将其一股脑地写入到流中即可。为此，<code>stringify</code>函数也做了一番修改，拆分为了如下的两个函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> stringify-asm (<span class="name">asm</span>)</span><br><span class="line">  <span class="string">"根据汇编代码ASM生成相应的汇编语言字符串"</span></span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">ins</span> asm)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">keywordp</span> ins)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A:~%"</span> ins))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">3</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A, ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">third</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">2</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">1</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A~%"</span> (<span class="name">first</span> ins))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> stringify (<span class="name">asm</span> globals)</span><br><span class="line">  <span class="string">"根据jjcc2产生的S表达式生成汇编代码字符串"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  <span class="comment">;; 输出globals中的所有变量</span></span><br><span class="line">  <span class="comment">;; <span class="doctag">FIXME:</span> 暂时只支持输出数字</span></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .data~%"</span>)</span><br><span class="line">  (<span class="name">maphash</span> (<span class="name">lambda</span> (<span class="name">k</span> v)</span><br><span class="line">             (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A: .long ~D~%"</span> k v))</span><br><span class="line">           globals)</span><br><span class="line"></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .section __TEXT,__text,regular,pure_instructions~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .globl _main~%"</span>)</span><br><span class="line">  <span class="comment">;; 输出用户自定义的函数</span></span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">e</span> *udfs*)</span><br><span class="line">    (<span class="name">destructuring-bind</span> (<span class="name">label</span> . asm) e</span><br><span class="line">      (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A:~%"</span> label)</span><br><span class="line">      (<span class="name">stringify-asm</span> asm)))</span><br><span class="line"></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"_main:~%"</span>)</span><br><span class="line">  (<span class="name">stringify-asm</span> asm))</span><br></pre></td></tr></table></figure><p>现在，可以继续用以前的<code>fb</code>函数来编译了，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setf</span> *udfs* <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">fb</span> '(progn (defun a (x) (+ x <span class="number">1</span>)) (_exit (a <span class="number">2</span>))))</span><br></pre></td></tr></table></figure><p>生成的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">X: .long 0</span><br><span class="line">G606: .long 0</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">A:</span><br><span class="line">        MOVQ %RDI, X(%RIP)</span><br><span class="line">        MOVL X(%RIP), %EAX</span><br><span class="line">        MOVL $1, %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        RET</span><br><span class="line">_main:</span><br><span class="line">        MOVQ $2, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL A</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVL %EAX, G606(%RIP)</span><br><span class="line">        MOVL G606(%RIP), %EDI</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _exit</span><br></pre></td></tr></table></figure><p>编译运行即可得到返回码为3。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解如何编译&lt;code&gt;defun&lt;/code&gt;。在Common Lisp中，&lt;code&gt;defun&lt;/code&gt;用于定义函数。例如，下列的代码定义了函数&lt;code&gt;foo&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;defun&lt;/span&gt; foo (&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;一个名为FOO的函数&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;ignorable&lt;/span&gt; a))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;defun&lt;/code&gt;的&lt;a href=&quot;http://clhs.lisp.se/Body/m_defun.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;语法&lt;/a&gt;中，第一行的字符串是这个函数的文档，可以用&lt;code&gt;documentation&lt;/code&gt;函数获取；第二行是declaration。（不管是documentation还是declaration，也许要等到自举的那一天才能够支持了）目前只打算支持如下这般朴素的&lt;code&gt;defun&lt;/code&gt;用法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
</feed>
