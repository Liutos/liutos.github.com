<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liutos.github.io/"/>
  <updated>2019-05-07T15:08:41.853Z</updated>
  <id>https://liutos.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Boostnote及对记笔记的思考</title>
    <link href="https://liutos.github.io/2019/05/07/Boostnote%E5%8F%8A%E5%AF%B9%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://liutos.github.io/2019/05/07/Boostnote及对记笔记的思考/</id>
    <published>2019-05-07T15:06:43.000Z</published>
    <updated>2019-05-07T15:08:41.853Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章就是在<a href="https://boostnote.io/" target="_blank" rel="noopener">Boostnote</a> 中写成的XD</p><h2 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h2><p>有一阵子，我沉迷于“笔记软件狩猎”中——就是不停寻找各种各样的笔记软件，再一个个试用，企图从中选出一个最强大的。回想起来，我尝试过有道云笔记、印象笔记、Quiver、Boostnote、OneNote、Yu Writer、Leanote（在本地搭建），等等。大部分都是浅尝辄止，例如OneNote，当我发现它不支持代码块语法高亮时，就放弃了它。目前仍然在使用的是Boostnote，并且也是最令我满意的。</p><h2 id="走马观花"><a href="#走马观花" class="headerlink" title="走马观花"></a>走马观花</h2><p>Boostnote自诩为“for developer”的笔记软件，除了书写Markdown以及实时预览之外，还支持绘图（UML、流程图、时序图）、制表，甚至可以添加LaTeX公式。</p><p>GitHub上可以找到官方对Boostnote绘图能力的简单<a href="https://github.com/BoostIO/Boostnote/wiki/Diagram-support" target="_blank" rel="noopener">示例</a>，但我用得极少。不管是画UML、流程图，还是时序图，方法都是“写代码”。画UML用的是PlantUML的语法（你甚至可以在首选项中找到PlantUML服务器的地址），画流程图用的是<a href="http://flowchart.js.org/" target="_blank" rel="noopener">flowchart.js</a>的语法。我自己很喜欢这类语绘的方式，只需要熟悉一下语法，画起来图来比鼠标拖拖拉拉不知道要高到哪里去了。说到时序图，我更喜欢用<a href="http://sdedit.sourceforge.net/example/index.html" target="_blank" rel="noopener">sdedit</a>。</p><p>制表只需要敲入竖线和横线即可。例如，下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|这|是|一|</span><br><span class="line">|-|-|-|</span><br><span class="line">|个|表|格|</span><br></pre></td></tr></table></figure><p>在Boostnote中预览时的效果是如下这样的</p><table><thead><tr><th>这</th><th>是</th><th>一</th></tr></thead><tbody><tr><td>个</td><td>表</td><td>格</td></tr></tbody></table><p>制表在Emacs的<a href="https://orgmode.org/manual/Built_002din-table-editor.html#Built_002din-table-editor" target="_blank" rel="noopener">org-mode</a>中有更风骚的表现。比如，按下tab键可以让光标跳至下一个单元格，同时会自动调整每一列的宽度；甚至，还可以在单元格中使用公式。</p><p>既然可以嵌入LaTeX，那么下列的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ \LaTeX $$</span><br></pre></td></tr></table></figure><p>就能够用来绘制酷炫版的LaTeX logo了，如下所示</p><p>$$ \LaTeX $$</p><p>只可惜这玩意儿不是inline的。</p><p>Markdown这门标记语言原本也支持代码块，但稍微现代的编辑器都应当至少支持语法高亮才行。在Boostnote中即便不进行预览，代码块中的代码也是彩色的。</p><p>Boostnote自动保存笔记内容，这点上每个人的口味可能还是不太一样的。</p><h2 id="槽点"><a href="#槽点" class="headerlink" title="槽点"></a>槽点</h2><p>尽管可以将剪贴板中的图片粘贴到Boostnote的笔记中，却不能将图片复制到剪贴板中。唯一的办法，就是在粘贴了图片后，按照笔记中的文件路径，在Finder中找到这个文件，然后再复制。</p><p>不像Yu Writer和Typora，Boostnote既不支持目录也不支持大纲模式。如果用来写篇幅很长的文章，并且需要频繁在相距比较远的章节之间切换的话，会写得比较辛苦。但也可以认为，Markdown，或者说Boostnote这样的笔记软件，本来也不适合写作大型文档。遇到这种事情，还是应当出动字处理软件（比如Word）或者TeX。</p><p>Boostnote没有将笔记的内容以朴素的Markdown形式保存为一个.md文件，而是存储成后缀名为.cson的文件格式。这意味着，即便哪一天有一款完美的Markdown编辑器出现了，也无法在其中查看和编辑这些Boostnote生成的文档。</p><h2 id="一些胡言乱语"><a href="#一些胡言乱语" class="headerlink" title="一些胡言乱语"></a>一些胡言乱语</h2><ul><li>记笔记的目的是什么？</li><li>我对笔记软件的要求是什么？</li><li>Boostnote是最合适的吗？它又适合做什么呢？</li></ul><p>我不是从入手了Mac之后才开始记笔记的，在此之前，我用Emacs的org-mode来记笔记，但也许称其为FAQ更恰当。使用org-mode，写作方式、浏览方式，以及载体都是一致的——用org-mode的语法来写作，同时写下的也就是所看到的（org-mode没有预览一说），最后，存储的也是纯粹的、敲入的文本。但用org-mode来记笔记也有自己的缺陷：</p><ul><li>在Emacs中浏览的体验不是非常好</li><li>不方便使用行内的代码块</li><li>其它编辑器对.org格式的支持不好</li><li>不方便粘贴图片</li></ul><p>因此，才打算构筑新的笔记系统。但新的笔记系统应当不仅仅可以解决org-mode遇到的问题，而是应该贴合我的核心需求才行。我自己曾经总结过，笔记软件应该满足如下的要求：</p><ul><li>支持Markdown，它是一门我所熟悉的、轻量级的标记语言，也被众多的软件支持</li><li>支持编程语言的语法高亮，毕竟是软件开发方面的笔记，总会涉及到代码的</li><li>以.md文件的形式存储。这个一会儿再聊聊</li><li>支持树形的文件层级结构，因为我可能会给笔记划分比较多的层级，但这个也值得一会儿聊聊</li><li>支持Emacs的keymap，这是我所熟悉的操作方式，减少手离开键盘的次数</li></ul><p>看下来更像是在物色一款好用的Markdown文件编辑器。但一款优秀的Markdown文件编辑器就会是一款优秀的笔记软件吗？我看未必。</p><p>实际上，对代码的语法高亮的要求，暴露了一个关键因素，就是：即便我写入的是Markdown代码，也希望能够以渲染后的效果展示出来。所以，为什么不直接使用富文本来书写笔记内容。如果是富文本的编辑器，那么一般便不会是以朴素的.md文件的格式来存储的了，但这并没有什么太值得在意的，毕竟谁也不会闲着没事就将笔记内容在各个软件间迁移着玩。</p><p>如果是一些可以公开的笔记，那么直接记录到博客中也不失为一个好办法——博客可以被搜索引擎索引，之后如果想要查找记录过的内容的话，也可以借助于搜索引擎强大的搜索能力来实现。不过，现阶段，我更喜欢这些笔记是私密的。</p><p>我的笔记也几乎不会与他人分享，因此不管是书写格式还是存储格式，都只需要我自己用着开心就足够了。大多数情况下，笔记的用途其实是代码片段，在需要的时候能够复制出来略作修改，用到其它地方——例如粘贴到shell中运行，解决一些临时的问题。如果不是因为我喜欢记下最终结果的来龙去脉的话，Boostnote的代码片段功能也许才是最适合我的选择。另外，由于大部分的代码都非常地短，即便没有语法高亮浏览器来也不是大问题，所以语法高亮的需要也就不那么迫切了。</p><p>现在看来，Boostnote并不是最合适的（打脸了）。Evernote和Leanote是我用过的笔记软件中比较强有力的两个竞争者。由于Leanote比Evernote支持更多的目录层级，并且还可以选择创建Markdown笔记（而不仅仅是富文本笔记），所以我大概会选择用Leanote来作为接下来的笔记软件的主力吧。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>用Typora来写，用ElasticSearch来索引笔记，好像也不错？！</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="boostnote" scheme="https://liutos.github.io/tags/boostnote/"/>
    
      <category term="editor" scheme="https://liutos.github.io/tags/editor/"/>
    
      <category term="markdown" scheme="https://liutos.github.io/tags/markdown/"/>
    
      <category term="note taking" scheme="https://liutos.github.io/tags/note-taking/"/>
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="sequence diagram" scheme="https://liutos.github.io/tags/sequence-diagram/"/>
    
      <category term="typora" scheme="https://liutos.github.io/tags/typora/"/>
    
      <category term="yu writer" scheme="https://liutos.github.io/tags/yu-writer/"/>
    
      <category term="笔记类软件" scheme="https://liutos.github.io/tags/%E7%AC%94%E8%AE%B0%E7%B1%BB%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="编辑器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>更过程式的let——vertical-let</title>
    <link href="https://liutos.github.io/2019/03/13/%E6%9B%B4%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%9A%84let%E2%80%94%E2%80%94vertical-let/"/>
    <id>https://liutos.github.io/2019/03/13/更过程式的let——vertical-let/</id>
    <published>2019-03-13T15:02:59.000Z</published>
    <updated>2019-03-13T15:04:17.548Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名自诩的non-trivial的Common Lisp程序员，在编码的时候经常会遇到令人不愉快的地方，其中一个便是<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm#let" target="_blank" rel="noopener">LET</a>。</p><p>一段典型的<code>LET</code>的示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> <span class="number">1</span>))</span><br><span class="line">   a)</span><br></pre></td></tr></table></figure><p>大多数时候，<code>LET</code>不会只有一个绑定。并且，也不会只是绑定一个常量这么简单，而应当是下面这样的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> (<span class="name">foo</span> x y))</span><br><span class="line">      (<span class="name">b</span> (<span class="name">bar</span> z)))</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>有时候我会想看看某一个绑定的值——最好是在它计算完毕后立即查看。如果要查看<code>foo</code>函数的返回值，可以这样写</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> (<span class="name">foo</span> x y))</span><br><span class="line">      (<span class="name">b</span> (<span class="name">bar</span> z)))</span><br><span class="line">  (<span class="name">print</span> a)</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>如果调用<code>foo</code>和<code>bar</code>都顺利的话上面的代码也就够了。比较棘手的情况是，如果<code>a</code>的值不符合预期，会导致<code>b</code>的计算过程出状况（尽管在上面的代码中看似不会）。这种情况多出现在<code>LET*</code>的使用中，如下面所示</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">a</span> (<span class="name">foo</span> x y))</span><br><span class="line">       (<span class="name">b</span> (<span class="name">bar</span> a)))</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>如果错误的<code>a</code>会导致<code>bar</code>的调用出错，那么在调用<code>function1</code>之前才调用<code>print</code>打印<code>a</code>已经为时过晚了——毕竟调用<code>bar</code>的时候就抛出<code>condition</code>往调用链的上游走了。一种方法是写成下面这样子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">a</span> (<span class="name">let</span> ((<span class="name">tmp</span> (<span class="name">foo</span> x y)))</span><br><span class="line">            (<span class="name">print</span> tmp)</span><br><span class="line">            tmp))</span><br><span class="line">       (<span class="name">b</span> (<span class="name">bar</span> a)))</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>这也太丑了！要不然写成下面这样子？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> (<span class="name">foo</span> x y)))</span><br><span class="line">  (<span class="name">print</span> a)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">b</span> (<span class="name">bar</span> a)))</span><br><span class="line">    (<span class="name">function1</span> a b)</span><br><span class="line">    (<span class="name">function2</span> a b)))</span><br></pre></td></tr></table></figure><p>本来一个<code>LET</code>就可以做到的事情，这下子用了两个，还导致缩进更深了一级。如果有十个变量需要打印，就会增加十个<code>LET</code>和十层缩进。如果心血来潮想查看一个变量的值，还要大幅调整代码。</p><p>问题大概就出在<code>LET</code>和<code>LET*</code>的语法上。以<code>LET</code>为例，它由截然分开的<code>bindings</code>和<code>forms</code>组成，两者不能互相穿插。因此，如果想在<code>bindings</code>中求值一段表达式，只能将<code>bindings</code>切开，写成两个<code>LET</code>的形式。好像写一个新的宏可以解决这个问题？是的，<code>vertical-let</code>就是。</p><p><code>vertical-let</code>是一个我自己写的宏，源代码<a href="https://github.com/Liutos/clitool/blob/master/cl/sak.lisp#L9" target="_blank" rel="noopener">在此</a>。其用法如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line">  <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line">  a)</span><br></pre></td></tr></table></figure><p>它借鉴了<code>LOOP</code>中绑定变量的方式（即<code>:with</code>和<code>=</code>），绑定变量和用于求值的代码还可以交织在一起，如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line">  <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line">  (<span class="name">print</span> a)</span><br><span class="line">  <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line">  (<span class="name">+</span> a b))</span><br></pre></td></tr></table></figure><p><code>vertical-let</code>最终会展开为<code>LET</code>，比如上面的代码，会展开为如下的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">LET</span> ((<span class="name">A</span> <span class="number">1</span>))</span><br><span class="line">  (<span class="name">PRINT</span> A)</span><br><span class="line">  (<span class="name">LET</span> ((<span class="name">B</span> <span class="number">2</span>))</span><br><span class="line">    (<span class="name">+</span> A B)))</span><br></pre></td></tr></table></figure><p><code>vertical-let</code>的算法很简单。它遍历表达式列表，当遇到<code>:with</code>时就把接下来的三个元素分别视为变量名、等号，以及待求值的表达式，将三者打包进一个列表中，再压栈；当遇到其它值时，就视为待求值的表达式（将会组成<code>LET</code>的<code>forms</code>部分），也放进列表中再压栈（具体方法参见源代码）。</p><p>将所有值都遍历并压栈后，接下来要遍历这个栈中的元素。先准备两个空的栈——一个存放<code>bindings</code>，一个存放<code>forms</code>。接着，对于每一个从栈中弹出的元素，分为如下两种情况：</p><ol><li>如果表示<code>binding</code>，则直接压入存放<code>bindings</code>的栈，否则；</li><li>如果是待求值的表达式，并且上一个出栈的元素是<code>binding</code>，则说明已经有一段完整的<code>LET</code>的内容被集齐。因此，将目前在两个栈中的内容全部弹出，组合为一个<code>LET</code>表达式再压入存放<code>forms</code>的栈中。然后将方才弹出的表达式也压入<code>forms</code>。重复上述过程直至所有元素都被处理，最后将还在两个栈中的内容也组合为一个<code>LET</code>表达式便结束了。</li></ol><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="macro" scheme="https://liutos.github.io/tags/macro/"/>
    
      <category term="宏" scheme="https://liutos.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>不同工具查看代码分支diff的差异</title>
    <link href="https://liutos.github.io/2019/02/28/%E4%B8%8D%E5%90%8C%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AFdiff%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <id>https://liutos.github.io/2019/02/28/不同工具查看代码分支diff的差异/</id>
    <published>2019-02-28T14:53:46.000Z</published>
    <updated>2019-02-28T14:55:46.131Z</updated>
    
    <content type="html"><![CDATA[<p>本文只是简单地讲述我自己在使用<a href="https://www.gnu.org/software/emacs/index.html" target="_blank" rel="noopener">GNU Emacs</a>、<a href="https://git-fork.com/" target="_blank" rel="noopener">Fork</a>，以及<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>查看Git仓库的不同分支的diff上的经历。</p><h2 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h2><p>当使用Emacs时，我更喜欢用<code>M-x package-install</code>安装的<a href="https://github.com/magit/magit" target="_blank" rel="noopener"><code>magit</code></a>提供的功能——<code>magit-diff</code>，而不是它自带的<code>vc-dir</code>。按下<code>M-x</code>，输入<code>magit-diff</code>并敲下回车后，Emacs会在minibuffer中等待用户输入要比较的分支。就像在shell中使用<code>git-diff</code>一样，只需要输入两个以<code>..</code>连接的分支名并敲下回车，就可以列出它们间的差异。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E4%BD%BF%E7%94%A8magit-diff%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%AE%E5%BC%82.png" alt=""></p><p>上图是master与re两个分支间的差异。<code>magit-diff</code>会列出两个分支间不一致的文件，与直接使用<code>git-diff</code>命令没有不同。往下滚动跨过文件清单后，还可以查看单个文件的差异。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/magit-diff%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E6%97%B6%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82.png" alt=""></p><h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>第一次知道Fork是在知乎闲逛的时候，好像是在浏览“Mac下有什么值得推荐的软件”这类问题时看到的。某一次，为了能直观地查看两个commit间的差异，便试用了一番，效果确实不错。Fork的界面如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Fork%E7%9A%84%E7%95%8C%E9%9D%A2%E6%A6%82%E8%A7%88.png" alt=""></p><p>还记得，当时为了能够比较两个commit间的差异，我还在Fork的菜单栏中翻了很久——虽然是毫无收获。结果发现，原来只需要选中两个commit就可以了。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Fork%E4%B8%AD%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AAcommit%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82.png" alt=""></p><p>图片两行蓝色的就是我选中的两个commit——先用鼠标点击其一，按住<code>control</code>键后再选中另一个即可。图片下方的部分与<code>magit-diff</code>差不多，应该也算是一目了然了。</p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>原本我觉得Fork已经足够好了，某一天在用VSCode时才忽然发现，在Fork中显示的代码差异，是没有语法高亮的。通常来说，即使没有语法高亮，查看短小的diff也不成问题。但如果差异的内容很多，或是diff位于一个很长的函数内部，这时光靠diff来做代码审查已经不太够了——因为不好确定在这片diff中出现的变量和函数，到底是不是正确地定义了的。</p><p>后来我发现，VSCode自带的“源代码管理”，即便是在查看diff时也是有语法高亮的——不仅有语法高亮，对于Node.js代码而言，还有ESLint的提示和“跳转到定义”的功能，awesome！不愧是全宇宙最好用的编辑器（笑</p><p>为了可以用VSCode来查看两个分支间的差异，放狗搜了一下，找到了神器<a href="https://github.com/eamodio/vscode-gitlens" target="_blank" rel="noopener">GitLens</a>。</p><p>安装GitLens后，VSCode的最左侧会多出一个菜单项，在其中可以方便地选择两个分支来进行比较。首先，找到一个要比较的分支，选择“Select for Compare”。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%9C%A8GitLens%E4%B8%AD%E9%80%89%E4%B8%AD%E8%A6%81%E6%AF%94%E8%BE%83%E7%9A%84%E5%88%86%E6%94%AF.png" alt=""></p><p>再选中另一个要比较的分支，右键单击选择“Compare with Selected”，然后便可以在下方看到VSCode罗列出不一致的文件清单了。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%9C%A8GitLens%E4%B8%AD%E9%80%89%E4%B8%AD%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A6%81%E6%AF%94%E8%BE%83%E7%9A%84%E5%88%86%E6%94%AF.png" alt=""></p><p>VSCode是最吼的！</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="visual studio code" scheme="https://liutos.github.io/tags/visual-studio-code/"/>
    
  </entry>
  
  <entry>
    <title>拿Emacs对接我的cuckoo</title>
    <link href="https://liutos.github.io/2019/02/05/%E6%8B%BFEmacs%E5%AF%B9%E6%8E%A5%E6%88%91%E7%9A%84cuckoo/"/>
    <id>https://liutos.github.io/2019/02/05/拿Emacs对接我的cuckoo/</id>
    <published>2019-02-05T07:17:08.000Z</published>
    <updated>2019-02-05T07:19:57.002Z</updated>
    
    <content type="html"><![CDATA[<p>cuckoo是一个我自己开发的类似待办事项的工具，运行在我本地的电脑上。它有如下两个接口：</p><ol><li>传入一个UNIX Epoch时间戳创建提醒</li><li>传入一个标题以及提醒的ID来创建任务</li></ol><p>这样一来，便能在设定的时刻调用<a href="https://github.com/vjeantet/alerter" target="_blank" rel="noopener"><code>alerter</code></a>在屏幕右上角弹出提醒。</p><p>我喜欢用<a href="https://www.gnu.org/software/emacs/index.html" target="_blank" rel="noopener">Emacs</a>的<a href="https://orgmode.org/" target="_blank" rel="noopener">org-mode</a>来安排任务，但可惜的是，org-mode没有定点提醒的功能（如果有的话希望来个人打我的脸XD）。开发了cuckoo后，忽然灵机一动——何不给Emacs添砖加瓦，让它可以把org-mode中的条目内容（所谓的heading）当做任务丢给cuckoo，以此来实现定点提醒呢。感觉是个好主意，马上着手写这么些Elisp函数。</p><p>PS：读者朋友们就不用执着于我的cuckoo究竟是怎样的接口定义了。</p><p>为了实现所需要的功能，让我从结果反过来推导一番。首先，需要提炼一个TODO条目的标题和时间戳（用来创建提醒获取ID），才能调用cuckoo的接口。标题就是org-mode中一个TODO条目的heading text，在Emacs中用下面的代码获取</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">nth</span> <span class="number">4</span> (<span class="name">org-heading-components</span>))</span><br></pre></td></tr></table></figure><p><code>org-headline-components</code>在光标位于TODO条目上的时候，会返回许多信息（参见下图）</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/org-heading-components%E7%9A%84%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3.png" alt=""></p><p>其中下标为4的component就是我所需要的内容。</p><p>接着便是要获取一个提醒的ID。ID当然是从cuckoo的接口中返回的，这就需要能够解析JSON格式的文本。在Emacs中解析JSON序列化后的文本可以用<a href="https://github.com/ryancrum/json.el" target="_blank" rel="noopener">json</a>这个库，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">s</span> <span class="string">"&#123;\"remind\":&#123;\"create_at\":\"2019-01-11T14:53:59.000Z\",\"duration\":null,\"id\":41,\"restricted_hours\":null,\"timestamp\":1547216100,\"update_at\":\"2019-01-11T14:53:59.000Z\"&#125;&#125;"</span>))</span><br><span class="line">  (<span class="name">cdr</span> (<span class="name">assoc</span> 'id (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">json-read-from-string</span> s))))))</span><br></pre></td></tr></table></figure><p>既然知道如何解析（同时还知道如何提取解析后的内容），那么接下来便是要能够获取上述示例代码中的<code>s</code>。<code>s</code>来自于HTTP响应的body，为了发出HTTP请求，可以用Emacs的<a href="https://github.com/tkf/emacs-request" target="_blank" rel="noopener">request</a>库，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">this-request</span> (<span class="name">request</span></span><br><span class="line">                      <span class="string">"http://localhost:7001/remind"</span></span><br><span class="line">                      <span class="symbol">:data</span> <span class="string">"&#123;\"timestamp\":1547216100&#125;"</span></span><br><span class="line">                      <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">                      <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">                      <span class="symbol">:type</span> <span class="string">"POST"</span></span><br><span class="line">                      <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">                                (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                                  (<span class="name">message</span> <span class="string">"data: %S"</span> data)))</span><br><span class="line">                      <span class="symbol">:sync</span> <span class="literal">t</span>))</span><br><span class="line">       (<span class="name">data</span> (<span class="name">request-response-data</span> this-request)))</span><br><span class="line">  data)</span><br></pre></td></tr></table></figure><p>此处的<code>:sync</code>参数花了我好长的时间才捣鼓出来——看了一下<code>request</code>函数的docstring后才发现，原来需要传递<code>:sync</code>为<code>t</code>才可以让<code>request</code>函数阻塞地调用，否则一调用<code>request</code>就立马返回了<code>nil</code>。</p><p>现在需要的就是构造<code>:data</code>的值了，其中的关键是生成秒级的UNIX Epoch时间戳，这个时间戳可以通过TODO条目的<code>SCHEDULED</code>属性转换而来。比如，一个条目的<code>SCHEDULED</code>属性的值可能是<code>&lt;2019-01-11 Fri 22:15&gt;</code>，将这个字符串传递给<code>date-to-time</code>函数可以解析成代表着秒数的几个数字</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">date-to-time</span> <span class="string">"&lt;2019-01-11 Fri 22:15&gt;"</span>)</span><br></pre></td></tr></table></figure><p>时间戳字符串要怎么拿到？答案是使用org-mode的<code>org-entry-get</code>函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">org-entry-get</span> <span class="literal">nil</span> <span class="string">"SCHEDULED"</span>)</span><br></pre></td></tr></table></figure><p>PS：需要先将光标定位在一个TODO条目上。</p><p>至此，所有的原件都准备齐全了，最终我的Elisp代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> scheduled-to-time (<span class="name">scheduled</span>)</span><br><span class="line">  <span class="string">"将TODO条目的SCHEDULED属性转换为UNIX时间戳"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">lst</span> (<span class="name">date-to-time</span> scheduled)))</span><br><span class="line">    (<span class="name">+</span> (<span class="name">*</span> (<span class="name">car</span> lst) (<span class="name">expt</span> <span class="number">2</span> <span class="number">16</span>))</span><br><span class="line">       (<span class="name">cadr</span> lst))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> create-remind-in-cuckoo (<span class="name">timestamp</span>)</span><br><span class="line">  <span class="string">"往cuckoo中创建一个定时提醒并返回这个刚创建的提醒的ID"</span></span><br><span class="line">  (<span class="name">let</span> (<span class="name">remind-id</span>)</span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:7001/remind"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">json-encode-alist</span></span><br><span class="line">            (<span class="name">list</span> (<span class="name">cons</span> <span class="string">"timestamp"</span> timestamp)))</span><br><span class="line">     <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">     <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">     <span class="symbol">:type</span> <span class="string">"POST"</span></span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">message</span> <span class="string">"返回内容为：%S"</span> data)</span><br><span class="line">                 (<span class="name">let</span> ((<span class="name">remind</span> (<span class="name">json-read-from-string</span> data)))</span><br><span class="line">                   (<span class="name">setq</span> remind-id (<span class="name">cdr</span> (<span class="name">assoc</span> 'id (<span class="name">cdr</span> (<span class="name">car</span> remind))))))))</span><br><span class="line">     <span class="symbol">:sync</span> <span class="literal">t</span>)</span><br><span class="line">    remind-id))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> create-task-in-cuckoo ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">brief</span>)</span><br><span class="line">        (<span class="name">remind-id</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name">setq</span> brief (<span class="name">nth</span> <span class="number">4</span> (<span class="name">org-heading-components</span>)))</span><br><span class="line"></span><br><span class="line">    (<span class="name">let*</span> ((<span class="name">scheduled</span> (<span class="name">org-entry-get</span> <span class="literal">nil</span> <span class="string">"SCHEDULED"</span>))</span><br><span class="line">           (<span class="name">timestamp</span> (<span class="name">scheduled-to-time</span> scheduled)))</span><br><span class="line">      (<span class="name">setq</span> remind-id (<span class="name">create-remind-in-cuckoo</span> timestamp)))</span><br><span class="line">    </span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:7001/task"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">concat</span> <span class="string">"brief="</span> (<span class="name">url-encode-url</span> brief) <span class="string">"&amp;detail=&amp;remind_id="</span> (<span class="name">format</span> <span class="string">"%S"</span> remind-id))</span><br><span class="line">     <span class="symbol">:type</span> <span class="string">"POST"</span></span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">message</span> <span class="string">"任务创建完毕"</span>))))))</span><br></pre></td></tr></table></figure><p>在<code>create-task-in-cuckoo</code>中，之所以没有再传递<code>application/json</code>形式的数据给cuckoo，是因为不管我怎么测试，始终无法避免中文字符在传递到接口的时候变成了<code>\u</code>编码的形式，不得已而为之，只好把中文先做一遍url encoding，然后再通过表单的形式（<code>form/x-www-urlencode</code>）发送给接口了。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>Project-Euler第69题</title>
    <link href="https://liutos.github.io/2019/01/28/Project-Euler%E7%AC%AC69%E9%A2%98/"/>
    <id>https://liutos.github.io/2019/01/28/Project-Euler第69题/</id>
    <published>2019-01-28T15:21:22.000Z</published>
    <updated>2019-01-28T15:26:03.010Z</updated>
    
    <content type="html"><![CDATA[<p>大学的时候挺喜欢解<a href="https://projecteuler.net/" target="_blank" rel="noopener">Project Euler</a>上的题目的，尤其是它不在乎答题者使用哪一门编程语言，甚至还有很多参与者是使用pen&amp;paper来解题的。去年开始重新开始做Project Euler上的题目，而<a href="https://projecteuler.net/problem=69" target="_blank" rel="noopener">第69题</a>则是最近刚刚解决的一题。惭愧的是，因为不晓得欧拉函数的计算公式（甚至都没有想过欧拉函数有没有可以用来计算的公式），所以这一题我是用暴力计算的方法来解决的。尽管花了40分钟左右才找出了问题的答案，但欧拉函数的计算方法本身还是让我觉得挺有意思的，下面我就来讲讲我在计算欧拉函数方面做的一些尝试。</p><p>69题本身很容易读懂，就是要找到一个不大于一百万的正整数<code>n</code>，这个<code>n</code>与以它为参的欧拉函数值的比值能够达到最大。欧拉函数的介绍可以看<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科</a>，简而言之，就是在不大于<code>n</code>的正整数中与<code>n</code>互质的数的个数，具体的例子可以参见69题描述中给出的表格。</p><p>网上可以找到别人的<a href="https://www.jianshu.com/p/d0fad6213433" target="_blank" rel="noopener">解法</a>，基本的思路是：按从小到大的顺序，对于一百万以内的每个素数，都计算出它们的倍数的欧拉函数值的一部分——即对于素数<code>p</code>计算出<code>1-1/p</code>并与这个位置上原来的值相乘。当遍历完一百万以内的所有素数后，也就计算出每一个位置上的欧拉函数值，再遍历一次就可以计算出比值最大的数字了。</p><p>但我今天要讲的是笨方法。</p><p>笨方法的关键就是乖巧地计算出每一个数字的欧拉函数值。而其中最笨的，当属挑出每一个不大于<code>n</code>的因数，计算它们与<code>n</code>的最大公约数，并根据这个最大公约数是否为1，来决定是否给某一个计数器加一。示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> phi (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">count</span> <span class="number">0</span>))</span><br><span class="line">    (<span class="name">dotimes</span> (<span class="name">i</span> n count)</span><br><span class="line">      (<span class="name">when</span> (<span class="name">=</span> (<span class="name">gcd</span> (<span class="number">1</span>+ i) n) <span class="number">1</span>)</span><br><span class="line">        (<span class="name">incf</span> count)))))</span><br></pre></td></tr></table></figure><p>这个<code>phi</code>可以稍微改进一下。例如，如果一个数a与<code>n</code>不是互质的，那么<code>a</code>的倍数（小于<code>n</code>的那一些）也一定不会与<code>n</code>互质。因此，每当遇到这么一个因数<code>a</code>，就知道后续的<code>2a</code>、<code>3a</code>等等，都不再需要计算其与<code>n</code>的最大公约数了。改进后的算法代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> phi (<span class="name">n</span>)</span><br><span class="line">  <span class="string">"通过将不互质的比特设置为1并计算为0的比特的个数来计算phi函数"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">bits</span> (<span class="name">make-array</span> n <span class="symbol">:element-type</span> 'bit <span class="symbol">:initial-element</span> <span class="number">0</span>))</span><br><span class="line">        (<span class="name">count</span> <span class="number">0</span>))</span><br><span class="line">    (<span class="name">dotimes</span> (<span class="name">i</span> n)</span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">=</span> (<span class="name">bit</span> bits i) <span class="number">1</span>)</span><br><span class="line">             <span class="comment">;; 该比特已经为1，说明已经在比它小的倍数被处理时一并被标记了</span></span><br><span class="line">             )</span><br><span class="line">            ((<span class="name">=</span> i (<span class="number">1</span>- n))</span><br><span class="line">             <span class="comment">;; 只处理比上界要小的数字</span></span><br><span class="line">             )</span><br><span class="line">            ((<span class="name">/=</span> (<span class="name">gcd</span> (<span class="number">1</span>+ i) n) <span class="number">1</span>)</span><br><span class="line">             <span class="comment">;; 除了当前这个不互质的数字之外，还需要将这个数字的倍数也一并处理</span></span><br><span class="line">             (<span class="name">dotimes</span> (<span class="name">j</span> (<span class="name">floor</span> n (<span class="number">1</span>+ i)))</span><br><span class="line">               (<span class="name">let*</span> ((<span class="name">j</span> (<span class="number">1</span>+ j))</span><br><span class="line">                      (<span class="name">m</span> (<span class="name">*</span> (<span class="number">1</span>+ i) j)))</span><br><span class="line">                 (<span class="name">setf</span> (<span class="name">bit</span> bits (<span class="number">1</span>- m)) <span class="number">1</span>))))</span><br><span class="line">            (<span class="name">t</span> (<span class="name">incf</span> count))))</span><br><span class="line">    count))</span><br></pre></td></tr></table></figure><p>为了节省内存空间，这里用了一个bitmap来标记小于<code>n</code>的每一个数字是否与<code>n</code>互质——1表示不互质，0表示互质。</p><p>其实并不需要遍历所有比<code>n</code>小的数字，只要遍历所有<code>n</code>的素因子即可。比如，将8分解为素因子，就是3个2，那么对于小于8的所有2的倍数（4和6）都是与8不互质的。基于这个方法，将所有的素因子的倍数所对应的位置为1，再数一下总共有多少个0比特即可。</p><p>对每个<code>n</code>都进行质因数分解效率不高，先生成一个一百万以内的素数表吧</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> primep (<span class="name">n</span>)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">&lt;</span> n <span class="number">2</span>) <span class="literal">nil</span>)</span><br><span class="line">((<span class="name">=</span> <span class="number">2</span> n) <span class="literal">t</span>)</span><br><span class="line">(<span class="name">t</span></span><br><span class="line"> (<span class="name">let</span> ((<span class="name">bnd</span> (<span class="name">truncate</span> (<span class="name">sqrt</span> n))))</span><br><span class="line">   (<span class="name">labels</span> ((<span class="name">rec</span> (<span class="name">test</span>)</span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">&gt;</span> test bnd) <span class="literal">t</span>)</span><br><span class="line">    ((<span class="name">=</span> <span class="number">0</span> (<span class="name">rem</span> n test)) <span class="literal">nil</span>)</span><br><span class="line">    (<span class="name">t</span> (<span class="name">rec</span> (<span class="number">1</span>+ test))))))</span><br><span class="line">     (<span class="name">rec</span> <span class="number">2</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> *primes-in-1000000* <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">defun</span> generate-primes-in-1000000 ()</span><br><span class="line">  (<span class="name">dotimes</span> (<span class="name">i</span> <span class="number">1000000</span>)</span><br><span class="line">    (<span class="name">when</span> (<span class="name">primep</span> (<span class="number">1</span>+ i))</span><br><span class="line">      (<span class="name">push</span> (<span class="number">1</span>+ i) *primes-in-1000000*)))</span><br><span class="line">  (<span class="name">setf</span> *primes-in-1000000* (<span class="name">nreverse</span> *primes-in-1000000*)))</span><br></pre></td></tr></table></figure><p>然后对于一个给定的<code>n</code>，遍历所有小于它的素数并对相应的倍数所在的比特置一就可以了，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> phi3 (<span class="name">n</span>)</span><br><span class="line">  <span class="string">"直接用素数表来做筛法"</span></span><br><span class="line">  (<span class="name">prog</span></span><br><span class="line">      ((<span class="name">bits</span> (<span class="name">make-array</span> n <span class="symbol">:element-type</span> 'bit <span class="symbol">:initial-element</span> <span class="number">0</span>)))</span><br><span class="line">     (<span class="name">dolist</span> (<span class="name">num</span> *primes-in-1000000*)</span><br><span class="line">       (<span class="name">cond</span> ((<span class="name">&gt;</span> num n)</span><br><span class="line">              (<span class="name">go</span> <span class="symbol">:return</span>))</span><br><span class="line">             ((<span class="name">zerop</span> (<span class="name">mod</span> n num))</span><br><span class="line">              (<span class="name">labels</span> ((<span class="name">aux</span> (<span class="name">i</span>)</span><br><span class="line">                         (<span class="name">when</span> (<span class="name">&lt;</span> i n)</span><br><span class="line">                           (<span class="name">setf</span> (<span class="name">bit</span> bits i) <span class="number">1</span>)</span><br><span class="line">                           (<span class="name">aux</span> (<span class="name">+</span> i num)))))</span><br><span class="line">                (<span class="name">aux</span> (<span class="number">1</span>- num))))))</span><br><span class="line">     <span class="symbol">:return</span></span><br><span class="line">     (<span class="name">return-from</span> phi3</span><br><span class="line">       (<span class="name">count-if</span> (<span class="name">lambda</span> (<span class="name">bit</span>) (<span class="name">zerop</span> bit)) bits))))</span><br></pre></td></tr></table></figure><p>PS：写这个<code>phi3</code>的时候发现Common Lisp提供了一个<a href="http://clhs.lisp.se/Body/m_prog_.htm" target="_blank" rel="noopener"><code>prog</code></a>宏，这个宏倒是真的挺好用。</p><p>改进了两轮，其实这仍然是笨方法。即便是用<code>phi3</code>，用来计算题目的答案也花了40多分钟。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="project euler" scheme="https://liutos.github.io/tags/project-euler/"/>
    
      <category term="algorithm" scheme="https://liutos.github.io/tags/algorithm/"/>
    
      <category term="算法" scheme="https://liutos.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://liutos.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>一些在Emacs中搜索文本的方法</title>
    <link href="https://liutos.github.io/2019/01/11/%E4%B8%80%E4%BA%9B%E5%9C%A8Emacs%E4%B8%AD%E6%90%9C%E7%B4%A2%E6%96%87%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://liutos.github.io/2019/01/11/一些在Emacs中搜索文本的方法/</id>
    <published>2019-01-11T13:37:18.000Z</published>
    <updated>2019-01-11T13:38:07.942Z</updated>
    
    <content type="html"><![CDATA[<p>在Emacs中写代码的时候，常常需要查找一个函数、方法，或者变量的定义。如果是正在写Common Lisp，那么<a href="https://common-lisp.net/project/slime/" target="_blank" rel="noopener">SLIME</a>已经配置好了相应的快捷键<code>M-.</code>，只需要将光标移动到要查看的函数、方法，或者变量的名字上，按下<code>M-.</code>便可以跳转过去——再按一下<code>M-,</code>还能回到原来的位置。</p><p>如果是写其它语言的代码，很多时候都没办法方便地跳转过去，这时候就需要依赖于文本搜索了，这也是本篇所要讲述的主题。</p><p>通常情况下，用<code>C-s</code>和<code>C-r</code>就足够了——一个负责“往下”搜索一个负责“往上”搜索。尤其在安装了Emacs的插件<a href="https://github.com/abo-abo/swiper" target="_blank" rel="noopener">swiper</a>之后，只需使用<code>C-s</code>便可以同时查看到上下两个方向的匹配文本。</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/swiper%E6%97%B6%E7%9A%84minibuffer.png" alt=""></p><p>但<code>C-s</code>也有其局限性。例如，它不能跨文件搜索，如果要查看的函数、方法，或者变量的定义不在当前buffer中，就不得不手动在多个buffer间切换并频繁按下<code>C-s</code>了。</p><p>有多种办法可以解决上面这种问题。例如，可以用Emacs的<code>projectile-ag</code>。通常，如果代码散布在多个源文件中，那么它们多半是放在一个项目中——比如一个Git仓库。打开位于项目中的文件时，Emacs的<code>projectile-mode</code>就会启动。此时，按下<code>C-c C-p s s</code>这套组合键，会调用<code>projectile-ag</code>函数。<code>projectile-ag</code>会在minibuffer中等候输入要搜索的内容，按下回车后，Emacs会调用命令行工具<a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="noopener">ag</a>来搜索这个项目下的所有文件，找出匹配关键字的行并显示。</p><p><code>projectile-ag</code>函数会打开另一个buffer来展示搜索结果，一个示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ag --literal --group --line-number --column --color --color-match 30\;43 --color-path 1\;32 --smart-case --stats -- emacs .</span><br><span class="line">0 matches</span><br><span class="line">0 files contained matches</span><br><span class="line">36 files searched</span><br><span class="line">111365 bytes searched</span><br><span class="line">0.007795 seconds</span><br></pre></td></tr></table></figure><p>使用<code>projectile-ag</code>的前提是要搜索的文件都在同一个一个项目中，但并非所有时候都满足这个要求。这时，可以用Emacs的<code>find-grep</code>函数。</p><p><code>find-grep</code>函数调起后同样要求使用者在minibuffer输入内容，但它更原始一点</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/find-grep%E7%9A%84%E7%AD%89%E5%80%99.png" alt=""></p><p>光标会定位在<code>-e</code>选项之后，需要填补交给<code>grep</code>的正则表达式。由于minibuffer中给出的是完整的、将会被运行的命令，因此可以也给<code>find</code>命令添加一些选项和参数，来改变搜索行为。</p><p>如果是在一个Node.js项目中搜索，一般还要让<code>find</code>忽略一些文件，如node_modules目录下的大量依赖，或者构建产生出来的.css和.js文件。这些文件中的行不仅很可能会命中输入的正则表达式，还极可能成片地出现，占据搜索结果中的半壁江山。</p><p>除了<code>grep</code>之外，还有许多命令行的文本搜索工具，例如<a href="https://github.com/samaaron/ack" target="_blank" rel="noopener"><code>ack</code></a>和<a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener"><code>rg</code></a>，并且它们都称自己更快。要在Emacs中使用它们也很简单，尤其是后者还有相应的插件<a href="https://github.com/dajva/rg.el" target="_blank" rel="noopener"><code>rg.el</code></a>可以方便调起。</p><p>如果经常要控制<code>find</code>来忽略node_modules，可以考虑用<code>git-grep</code>。<code>man git-grep</code>中说到，它只会搜索tracked的文件</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/git-grep%E7%9A%84man%E6%96%87%E6%A1%A3.png" alt="git-grep的man文档"></p><p>node_modules一般都不会被git跟踪，自然也就不会被搜索。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="search" scheme="https://liutos.github.io/tags/search/"/>
    
      <category term="tool" scheme="https://liutos.github.io/tags/tool/"/>
    
      <category term="搜索" scheme="https://liutos.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="工具" scheme="https://liutos.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Emacs的org-mode实现自动的internal archive</title>
    <link href="https://liutos.github.io/2019/01/07/Emacs%E7%9A%84org-mode%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%9A%84internal-archive/"/>
    <id>https://liutos.github.io/2019/01/07/Emacs的org-mode实现自动的internal-archive/</id>
    <published>2019-01-07T05:50:53.000Z</published>
    <updated>2019-01-07T06:18:51.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p><a href="https://orgmode.org/" target="_blank" rel="noopener">org-mode</a>是一个<a href="https://www.gnu.org/software/emacs/index.html" target="_blank" rel="noopener">Emacs</a>内置的major mode，当打开一个后缀为<code>.org</code>的文件时就会被启用。在官网的介绍中提到，它可以用于管理待办事项，而这也正是我目前使用org-mode最多的场合。比如，我用它来记录漫画的阅读进度，每一话或每一章就是一个标记了TODO关键字的条目，读完那一话或那一章后就会将对应的条目标记为DONE。一般我会一周一次地归档自己标记为DONE的条目，但由于一次要处理的条目可能很多，逐一将它们归档比较繁琐，因此，便打算二次开发实现一个自动归档的功能。</p><p>需要事先声明的是，本文不是org-mode的入门教程，也不会讲解如何配置org-mode。对这方面有兴趣的读者，可以自己搜索一番，资料还是相当丰富的。</p><h2 id="菜谱"><a href="#菜谱" class="headerlink" title="菜谱"></a>菜谱</h2><p>对于每一个被完成的单独的阅读任务，我的做法是将其<a href="https://orgmode.org/manual/Internal-archiving.html" target="_blank" rel="noopener">internal archive</a>。等到一整本漫画都读完之后，再将整个以漫画名命名的条目归档到别的文件中去。要实现自动的internal archive，最简单直接的办法是借助于org-mode提供的各种hook。</p><p>org-mode提供了许多的hook，在官方的<a href="https://orgmode.org/worg/doc.html#org-after-demote-entry-hook" target="_blank" rel="noopener">文档</a>中有一一列举 。其中，名为<code>org-after-todo-state-change-hook</code>的便是我所需要的钩子。只需往这个变量所绑定的列表中添加一个函数，那么这个函数便会在条目切换状态时（比如从TODO切换到DONE）被org-mode调用。</p><p>最终的ELisp代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt-archive-if-manga ()</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">state</span> org-state))</span><br><span class="line">    (<span class="name">when</span> (<span class="name">string=</span> state <span class="string">"DONE"</span>)</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">tags</span> (<span class="name">org-get-tags-at</span>)))</span><br><span class="line">        (<span class="name">when</span> (<span class="name">member</span> <span class="string">"漫画"</span> tags)</span><br><span class="line">          (<span class="name">org-toggle-archive-tag</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-to-list</span> 'org-after-todo-state-change-hook 'lt-archive-if-manga <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><p>稍微解释一下。从<code>C-h v org-after-todo-state-change-hook RET</code>的文档可以得知，条目的新状态可以通过变量<code>org-state</code>获取。取得新状态（是个字符串）后，首先检查其是否为<code>&quot;DONE&quot;</code>。如果是，再检查这个条目是否为一个阅读漫画的任务。</p><p>在我的用法中，凡是漫画条目，都打上了名为<code>&quot;漫画&quot;</code>的标签。因此，使用函数<code>org-get-tags-at</code>取得一个条目的所有标签（包括从父级条目继承下来的），再用<code>member</code>函数判断这些标签中是否包含字符串<code>&quot;漫画&quot;</code>。如果有，就调用<code>org-toggle-archive-tag</code>将该条目internal archive。</p><p>传给函数<code>add-to-list</code>的第三个参数<code>t</code>的作用，是让这个新加入钩子的函数最后被调用。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
  </entry>
  
  <entry>
    <title>2018年度技术总结</title>
    <link href="https://liutos.github.io/2018/12/29/2018%E5%B9%B4%E5%BA%A6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://liutos.github.io/2018/12/29/2018年度技术总结/</id>
    <published>2018-12-29T05:44:31.000Z</published>
    <updated>2018-12-29T05:45:22.525Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间2018年只剩下最后的几天了，赶紧趁热写篇年度总结，毕竟据说元旦会变冷。</p><h2 id="入手Mac"><a href="#入手Mac" class="headerlink" title="入手Mac"></a>入手Mac</h2><p>参加工作的第五个年头，终于买了一台自己的MacBook Pro。其实我从高中时起，就对Mac有一种憧憬。那时候每到周末，就常常往苹果的实体店跑，就为了去看看那些精致的笔记本，试着在触控板上滑动一下手指，点开几个自己只在苹果官网上看过icon的陌生应用。</p><p>依稀记得下决心买这台电脑的那天晚上，回到家掏出之前的联○笔记本，发现转动显示屏盖子的地方坏掉了，导致笔记本的盖子翻不起来。在家里要接一个外置的显示器来用实在是太麻烦了，立即就萌生了买一台新的来应急的想法。再三思索后，决定尝试一下Mac，便立即在官网下单了。令人哭笑不得的是，明明是要应急用的，结果还是过了三天才到手。庆幸的是，在公司是用外置显示器来办公的。</p><p>用上Mac之后有挺多的感触，有兴趣的读者可以移步<a href="http://liutos.github.io/2018/08/02/MacBook-Pro%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/">这里</a>阅读，这里就不再赘述了。令我自己也感到惊讶的，是我在用了Mac之后还购买了几款软件——我并不是一个很舍得花钱买软件的人，多数情况下，都是用一些免费的开源软件的。在Mac上买的这几款软件，大概是因为它们真的挺好用吧。最早入手的是<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>，买了它的Powerpack。后来买了<a href="https://folivora.ai/" target="_blank" rel="noopener">BetterTouchTool</a>，自定义了很多touchbar上的按钮，用得挺欢的</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/BetterTouchTools%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%B0%E7%8A%B6.png" alt="BetterTouchTool的使用现状"></p><p>再后来，遇到了堪称神器的<a href="https://contexts.co/" target="_blank" rel="noopener">Contexts</a>，现在在macOS中切换窗口就像是牛奶巧克力那般的丝滑。最近买的，则是<a href="https://www.macbartender.com/" target="_blank" rel="noopener">Bartender</a>，是在淘宝上的<a href="https://www.lizhi.io/" target="_blank" rel="noopener">数码荔枝</a>那里买的，趁着双十一的时候有折扣赶紧入了手。它们都很实用，使用频率也非常地高。当然了，像<a href="">Default Folder X</a>虽然也非常好用，但因为它可以无限期地免费使用（只是会偶尔弹个窗提醒购买），所以我就没有急着花钱了。一些比较有意思的应用，比如<a href="https://www.obdev.at/products/littlesnitch/index.html" target="_blank" rel="noopener">Little Snitch</a>，虽然很酷炫（看着世界地图上的各种连线），但对我而言用处不大，最后也就卸载了。</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>越是写博客就越发现，<del>博客的力量是有限的，除非超越博客。我不做程序员啦JOJO</del>比起写给自己查阅的笔记，写公开发表的文章是大不同的。笔记可以写得像铜墙铁壁那么规整，可以一层一层地嵌进去。但是发表在博客上的文章就像代码，是写给自己之外的人看的，要讲究阅读体验。偶尔要用段子活跃一下气氛给读者提提神，字里行间也要注意正确地使用行话。尤其是写一些教程一般的文章时，要循序渐进地讲述自己的操作过程，还要战战兢兢地担心别人无法复现自己的结果（人类的本质是复读机）。</p><p>重新开始写作后才发现，简书上的最后文章已经是2017年七月份的了。重开的博客，打算继续发表在GitHub Pages上。本来GitHub Pages上的博客的页面，是我用自己写的一个<a href="https://github.com/Liutos/cl-github-page" target="_blank" rel="noopener">工具</a>来生成的。结果这个半成品在Mac上因为cl-mysql安装失败跑不起来，我也一时不想折腾，于是决定换个成熟的工具来用。目前用的是<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>。一个惊喜是，Hexo默认支持Google Analytics——尽管并没有多少人会去看我的博客。</p><p>除了GitHub Pages之外，我也把文章发表到了SegmentFault的专栏上。感谢SegmentFault极其不友好的插入图片的方式，迫使我写了一个Alfred的Workflow，用来快速地把截图的图片上传到GitHub的一个仓库里（拿GitHub的仓库当图床）。现在的写作流程，是在电脑上用<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>先写好，然后<code>hexo new</code>一下生成源文件，把写好的内容粘贴进去，再发布，最后把文章内容再到SegmentFault上创建篇新文章再贴一次，发表出去。</p><h2 id="布谷，布谷"><a href="#布谷，布谷" class="headerlink" title="布谷，布谷"></a>布谷，布谷</h2><p>以前用（坏掉现在又修好了的）联○笔记本的时候，我用Windows 10自带的Alarm设置了很多提醒——叫外卖的、喝水的，以及起来走走的（久坐是不好的哟），大量的定时提醒让我有一种生活井井有条的感觉——写作感觉读作错觉。Mac在这方面可以做得更好，因为它自带crontab。于是我便用crontab和<a href="https://github.com/vjeantet/alerter" target="_blank" rel="noopener">alerter</a>（刚开始的时候用的是<a href="https://github.com/julienXX/terminal-notifier" target="_blank" rel="noopener">terminal-notifier</a>）给自己设定了不少定时提醒。等到<code>crontab -l</code>的输出开始泛滥后，便萌生了自己写一个管理工具的想法。</p><p>一开始还在<a href="https://boostnote.io/" target="_blank" rel="noopener">Boostnote</a>上煞有介事地写了一篇需求文档和设计文档（已经都是废稿了），想着用Common Lisp来开发。但同样因为cl-mysql安装不成功，我又不希望把时间都花在了折腾环境上，便改用了Node.js来编写这个管理工具。框架选择了<a href="https://eggjs.org/" target="_blank" rel="noopener">egg-js</a>，在操作MySQL和Redis方面都有相应的插件，此外还内置支持定时任务，上手很方便——真要是用Common Lisp的话，也许还在纠结某个功能是用某个半残的第三方库还是自己费劲从零写起。</p><p>用Redis的ZADD、ZRANGEBYSCORE、ZREM，以及ZSCORE指令做了一个简陋但够用的消息队列——用Z*系列的指令是为了可以模拟出延时消息的效果（<a href="https://beanstalkd.github.io/" target="_blank" rel="noopener">beanstalkd</a>和<a href="https://cn.aliyun.com/product/mns" target="_blank" rel="noopener">阿里云MNS</a>都支持这种特性）。配合egg-js的定时任务功能，就可以实现定时提醒了——弹出提醒仍然是用alerter。目前这套系统运作得还不错，大部分原本录入在crontab中的定时提醒已经交由它来处理了。尽管还有不少的小问题，不过相信都是可以解决的。</p><p>对了，这玩意儿的名字叫做cuckoo，即布谷鸟。</p><h2 id="GTD"><a href="#GTD" class="headerlink" title="GTD?"></a>GTD?</h2><p>Mac跟“效率”这个词似乎特别有缘，常常被人换做生产力工具，仿佛一拿起Mac，便自动屏蔽了外界的干扰。开始用Mac的几天后，我便开始把玩macOS上各款大名鼎鼎的TODO list应用了。关于这个话题之前也写了一篇吐槽文，有兴趣的可以移步<a href="https://segmentfault.com/a/1190000016955687" target="_blank" rel="noopener">这里</a>阅读。世间的TODO list应用是真的多，不过可能是我的口味实在是太刁钻了，我竟然没有一款是特别满意的。在把玩的期间最让我产生好感的，要属<a href="https://www.mylifeorganized.net/" target="_blank" rel="noopener">My Life Organized</a>，然而这货没有Mac版，不然我真的很可能会喜加一。</p><p>每过一段时间，我就会想要把自己对TODO list类应用的一些想法付诸实践，自己动手开发一个给自己用。不过到目前为止，这些想法仍然处于被封存的状态，被遗忘在了磁盘上哪个角落里的文件中。目前Emacs的<a href="https://orgmode.org/" target="_blank" rel="noopener">org-mode</a>还算够用，它兼顾了我使用上的凌乱与规整，尤其是当我需要在某个任务下写一些包含代码的笔记或者想法的时候，org-mode几乎就是所有TODO list类应用中的唯一选择了。但工具只是用来管理任务，当夜深人静坐下来，想要自己第二天给安排得明明白白的时候，就会发现，即便有最好的工具（我并不是说org-mode），也仍然需要方法论来指导这个安排的过程。尤其是，这个过程应当是“object-oriented”的——不是面向对象，而是“目标导向”。如果不事先制定一些目标——不管是像人生规划这般空泛的目标，还是像租一辆共享汽车开车上路这样具体的短期目标，如果缺乏目标，那么很快就会陷入了“随便找一些任务来填充第二天的空闲时间”这样的状态，久而久之GTD也就实践不起来了。</p><p>规划不等于目标。</p><h2 id="Note-taking"><a href="#Note-taking" class="headerlink" title="Note-taking"></a>Note-taking</h2><p>无法高亮编程语言代码的Evernote、OneNote，使用不通用的存储格式的Boostnote、Quiver，还有收费的为知笔记，都没能够取代Emacs的org-mode成为我做笔记的工具。org-mode最弱的地方，就在于使用起来不够随意，不像其它的几款笔记软件那样，截图之后的图片没有办法一键粘贴到.org文件中去。但恰恰我个人不太喜欢截个图配一段话的笔记形态，所以这个缺点可以视若无睹。我现在的笔记都是QA形式，一个一级headline就是一个问题，headline下的文本就是答案，而org-mode又支持嵌入代码（虽说Markdown也支持），很适合我的习惯</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E7%94%A8org-mode%E5%81%9A%E7%AC%94%E8%AE%B0.png" alt="Emacs中的笔记示例"></p><p>最近我觉得，与记笔记同样重要的，是能够方便并且准确地查找自己的笔记。笔记如果只是记而没有翻阅出来利用，那还不如每次都打开搜索引擎当场查找算了。我打算把笔记的导入到ElasticSearch中去，然后依托它的全文搜索功能来查找。感谢org-mode，是纯文本的存储格式。要写一个工具，把.org文件中的每个问题和对应的答案组装成一个JSON喂给ElasticSearch真是太简单了。现在缺的是一个方便的入口，以及一个美观大方的结果显示方式。</p><p>不过这个新想法的项目名还没想好</p><h2 id="Web后端的固有结界"><a href="#Web后端的固有结界" class="headerlink" title="Web后端的固有结界"></a>Web后端的固有结界</h2><p>年初开始渐渐负责起了面试的工作。为了可以比较系统地面试，便整理了一份Web后端工程师需要掌握的知识的清单。目前这份清单还在绝赞完善中——想必这个完善的过程是不会停止下来的，而且目前积累的面试题也不足。</p><p>原本还有另一份清单，是自我提升用的指引。但渐渐地我发现要求面试者所具备的知识，和充电用的技能树指引，其实是应当合二为一的，于是乎便诞生了一个叫做charging的项目。在其中的一个叫做knowledge.org的文件中（又是org-mode），我以自己的理解自上而下地给Web后端的软件工程师所需要的知识做了一下划分，并逐级细分，到了合适的粒度的headline，便添加这个分类下的相关面试题。除了在这些叶子节点上挂上面试题之外，我还依照这些合适粒度的headline给自己安排学习的内容，一般是相关主题的电子书或者PDF。经过最近一次的梳理后，接下来可能会学习一下Erlang（都不记得是第几次了），读一下《重构》，以及《Redis实战》。当然了，这些只是最近一次整理增加的内容，仅仅是完整学习内容的冰山一角XD</p><p>我本来不喜欢听网课的，认为视频和语音方式的教学，接收信息的效率比用眼看的方式要来得低效，毕竟不管是视频还是音频，总是要收完前一段内容才能继续收下一段内容（真香警告）。大约在两周前，买了极○时间的专栏《MySQL实战45讲》，听下来发觉其实还挺有意思，尤其适合在通勤和夜晚慢跑时听，算是2018年新增的一种学习方式吧。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>尽管有年月日的划分，但日子毕竟是连在一起过的，所以今年未完成的学习安排并不会在2019年到来的那一刻戛然而止。Org Agenda中还有很多标记为TODO的条目，Pocket中还有很多未读的文章，还有很多没看完的PDF，LeetCode和Project Euler上也还有很多的题目没做。2019年，想必会是忙碌的一年。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="2018" scheme="https://liutos.github.io/tags/2018/"/>
    
      <category term="总结" scheme="https://liutos.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何随机挑选要做的任务</title>
    <link href="https://liutos.github.io/2018/12/15/%E5%A6%82%E4%BD%95%E9%9A%8F%E6%9C%BA%E6%8C%91%E9%80%89%E8%A6%81%E5%81%9A%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
    <id>https://liutos.github.io/2018/12/15/如何随机挑选要做的任务/</id>
    <published>2018-12-15T14:50:39.000Z</published>
    <updated>2019-01-09T15:20:35.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于个人喜好的因素，选择了用Emacs的org-mode来实践GTD，管理自己的任务和安排日程。但也因为个人喜好的因素，导致在安排第二天的计划，从积累的TODO列表中挑选要做的事情时，总会下意识地跳过一些一看就很麻烦的任务。久而久之，在列表的顶部，便堆积着一些好久前就创建的TODO。而因为总是从上往下挑选任务，列表的底部则是堆积着好久没有露脸的TODO。有不见者，三十六年。</p><p>迫切需要一个办法来解决这个难题，但若真的一丝不苟地从上往下处理每一条TODO又觉得没意思，该怎么办？不如从中随机地挑选TODO来安排到第二天的日程中？Sounds good。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>一开始，我是打算找找现成的类似功能的，不过放狗搜了一番后并没有什么收获。之后的某天我忽然意识到，.org文件不过就是普通的文本文件而已，直接用命令行工具处理就好了呀。摸索一番之后才知道并不难，成果就是下面这段简单的shell命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name '*.org' ! -name 'trash.org' ! -name 'work.org' -exec grep -Hn '\*\* TODO' &#123;&#125; \; | sort -R | head -3</span><br></pre></td></tr></table></figure><p>稍微解释一下。首先登场的是<code>find</code>，它用来遍历目录下的所有.org文件——因为我把TODO按照不同的领域放到了不同的.org文件下。传递给<code>find</code>的参数的意思，是“匹配所有文件名以.org结尾、但既不叫trash.org、也不叫work.org的文件”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-name '*.org' ! -name 'trash.org' ! -name 'work.org'</span><br></pre></td></tr></table></figure><p>trash.org是垃圾箱，work.org存放的是工作相关的任务——我可不喜欢把工作安排到自己的闲暇时光里。</p><p>通过<code>-exec</code>让<code>find</code>调用<code>grep</code>从.org文件中过滤出符合条件的带有TODO关键字的行——在我的.org文件中，有很多行是没有TODO关键字的非任务型的内容，它们可能是一个目标、一个分类，甚至可以是某个TODO条目下的“笔记”。用下面的正则即可筛选出想要的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">'\*\* TODO'</span><br></pre></td></tr></table></figure><p>总和运用<code>find</code>和<code>grep</code>后，便到了从中挑选的环节了。虽然开始的时候提到的是“随机地挑选”，但可以参考音乐播放器的“随机播放”功能的做法，即先将所有的TODO条目随机排序，然后从头开始按顺序取出前几个。<code>sort</code>命令的<code>-R</code>选项已经实现了随机排序，再用<code>head</code>选取前3个即可。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="find" scheme="https://liutos.github.io/tags/find/"/>
    
      <category term="grep" scheme="https://liutos.github.io/tags/grep/"/>
    
      <category term="sort" scheme="https://liutos.github.io/tags/sort/"/>
    
      <category term="head" scheme="https://liutos.github.io/tags/head/"/>
    
      <category term="gtd" scheme="https://liutos.github.io/tags/gtd/"/>
    
  </entry>
  
  <entry>
    <title>用过的一些Markdown编辑器</title>
    <link href="https://liutos.github.io/2018/12/14/%E7%94%A8%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9BMarkdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://liutos.github.io/2018/12/14/用过的一些Markdown编辑器/</id>
    <published>2018-12-14T15:43:50.000Z</published>
    <updated>2019-01-09T15:20:58.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>买了MacBook Pro之后的一段时间里，为了打造适合自己的知识管理体系，折腾起了笔记类软件（题外话，我还挺喜欢尝试新软件的，尤其在接触macOS后发现许多软件都长得很漂亮）。其实在入手Mac之前，我已经试用过不少笔记类软件和服务了，包括Evernote（还有印象笔记）、有道云笔记、为知笔记，等等。再后来，改用Emacs的<a href="https://orgmode.org/" target="_blank" rel="noopener">org-mode</a>来写笔记——主要是将一些常常搜索的内容或经验记录在了多个.org文件中，算是一份自己的FAQ。后来想看看在macOS的世界中有没有更好的工具，同时渐渐觉得Markdown是一个更好的笔记内容载体，便尝试了一些知名的笔记类软件暨Markdown编辑器。</p><p>大致上尝试了下列这些：</p><ul><li>Emacs</li><li>Boostnote</li><li>Quiver</li><li>Typora</li><li>Visual Studio Code</li><li>Yu Writer</li></ul><p>本文并不是一篇完整的、专业的软件评测报告，只是我兴趣使然的对各个软件的吐槽和赞美，各位权当打发时间吧。下面我按顺序说一下上面提及的各款软件。</p><h2 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h2><p><a href="https://www.gnu.org/software/emacs/index.html" target="_blank" rel="noopener">Emacs</a>并不仅仅是一款Markdown编辑器，我用得最多的是用它来做计划（之前还用来写Node.js代码，不过现在交给VSCode了）。用Emacs来写Markdown，坏处是没有live preview的功能。在Emacs中打开了一个.md文件，只会原原本本地显示着井号、星号，三个反引号等Markdown语法的关键字——并且还是白底黑字的模样，而不带有丝毫不同的样式。为了让它们好看点，你还需要安装一个叫做<code>markdown-mode</code>的Emacs扩展。但几遍安装了<code>markdown-mode</code>，也无法实时预览。<code>markdown-mode</code>的菜单栏中有一个叫做“Preview”的功能，它依赖一个名为<code>markdown</code>的命令行工具（用<code>brew install markdown</code>可以安装）。当一切安装完毕点击“Preview”菜单项时，才发现是在网页浏览器中查看的方式——虽然有preview了，但并不live。</p><p>Emacs在写Markdown方面也并非一无是处。对程序员而言，在一篇Markdown写就的文章中插入代码是再正常不过的事情了。在Emacs中将光标定位到Markdown语法的代码块内，按下<code>control</code>和<code>c</code>的组合键，再敲一下单引号键，Emacs便会另起一个相应模式的buffer，并将代码块中的内容复制到新buffer中供继续编辑。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Emacs_%E7%BC%96%E8%BE%91Markdown%E4%BB%A3%E7%A0%81%E5%9D%97.gif" alt="Emacs_编辑Markdown代码块.gif"></p><p>在上面的GIF中，代码块以GitHub Flavored Markdown的语法在开头的三个反引号后附上了模式的名字，即lisp，Emacs便会打开<code>lisp-mode</code>的buffer。在这个buffer中可以继续使用Emacs的完整功能编辑对代码，包括语法高亮、自动补全，等等——如果启动了<a href="https://common-lisp.net/project/slime/" target="_blank" rel="noopener">SLIME</a>，甚至可以运行里面的Common Lisp代码。</p><p>Emacs和VSCode用于在编写代码的同时写写项目的README.md文件应当是绰绰有余的了。</p><h2 id="Boostnote"><a href="#Boostnote" class="headerlink" title="Boostnote"></a>Boostnote</h2><p><a href="https://boostnote.io/" target="_blank" rel="noopener">Boostnote</a>自诩为“程序员的笔记本”，它并不是我在Emacs之外寻找的第一款笔记软件，在它之前，我还尝试了<a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a>、<a href="http://happenapps.com/" target="_blank" rel="noopener">Quiver</a>来着。上手后发现，Boostnote简直就是Quiver的开源免费版本，相当的喜爱。</p><p>Boostnote当然让我格外喜欢的有几点：首先，Boostnote可以实时预览键入的Markdown源文档。会有一列跟编辑区域差不多宽的区域被用来展示Markdown渲染后的效果。（刚刚发现，原来这个区域的宽度是可以拖动调节的）</p><p>其次，它不仅支持Markdown、带语法高亮的代码块，甚至还支持表格和流程图的绘制！当然我以为，用竖线和连字符绘制表格的功能仅在Emacs的org-mode中存在（孤陋寡闻了汗颜），刚开始用Boostnote制作表格的时候可是相当兴奋。而text-based的绘制流程图的方式也是让我大开眼界（后来才知道原来有<a href="http://flowchart.js.org/" target="_blank" rel="noopener">flowchart.js</a>这样的工具）——尽管后来我渐渐发现，绘制流程图其实挺少用。</p><p>然后Boostnote具备在多份笔记中搜索的功能，这对于一款笔记软件而言倒是真的非常重要，因为有时候只能想到一些只言片语，而并不能确定所要查阅的内容究竟在哪一份笔记中。</p><p>但Boostnote也有一些缺点。首先，Boostnote是用自有的文件格式（而不是纯文本的.md文件）来存储输入的内容的——打开<code>~/Boostnote/notes/</code>可以看到这些后缀为<code>.cson</code>的文件。这样一来，假设我日后发现了一款更优秀的Markdown编辑器，那就不能无痛迁移了，还得先从Boostnote中将这些笔记逐一导出成.md文件才行。</p><p>其次，Boostnote只支持三层的组织结构——最外层是storage，然后是folder，最后就是笔记本身。当初有道云笔记特别让我喜欢的，就是它支持非常多层级的目录结构。尽管目录不是越多越好，但有这种灵活性总是更好的。否则，笔记的使用者就只能在命名和标签上下功夫了</p><p>最后一点，就是Boostnote在我的系统上非常容易崩溃。有时候一翻起盖子，看到的就是Boostnote崩溃的提示。</p><p>不过Boostnote支持往其中粘贴图片，当我需要快速记录一些图文内容时，我还是很喜欢用它的。</p><h2 id="Yu-Writer"><a href="#Yu-Writer" class="headerlink" title="Yu Writer"></a>Yu Writer</h2><p>某一天偶然遇到了<a href="https://ivarptr.github.io/yu-writer.site/" target="_blank" rel="noopener">Yu Writer</a>，它官网上的截图看着很吸引人，于是我便试用了一下。第一印象是，Yu Writer is awesome！首先它很人性化。它的预览区域是一个minimap——就是Sublime Text最右侧的那一列。在做到实时预览的时候，也不会占用太多的横向空间。其次，它支持大纲视图</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Yu%20Writer%E7%9A%84%E5%A4%A7%E7%BA%B2%E8%A7%86%E5%9B%BE.png" alt="Yu Writer的大纲视图"></p><p>即上图左侧的目录。恰逢当时我在用Boostnote写一篇比较长的设计文档，深刻地体验到了一个大纲视图的重要意义——对在长文档内的多个标题间跳转非常有帮助。再次，Yu Writer还准备了工具栏，方便不懂得Markdown语法的用户；支持标签页，便于在多个文档间切换；甚至可以把一个Markdown文档作为幻灯片来播放。</p><p>但Yu Writer也有它自己的劣势。第一，在Yu Writer内，原本在macOS系统中全局可用的Emacs风格快捷键——即<code>control+b</code>往左移动光标、<code>control+f</code>往右移动光标——居然不生效！这些快捷键对我个人还是非常重要的。</p><p>第二，在Yu Writer中，不能直接插入磁盘上的图片文件的绝对地址，既没有在预览区域显示出来，也没有在文档列表显示成功。</p><p>据说Yu Writer的作者的主业是厨师，感觉好强</p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> is best。不同于前面提到的几款Markdown编辑器，Typora是“所见即所得”的编辑器。你敲入两个井号，加一个空格，再敲入你的标题内容，最后回车，那么标题内容就会被渲染为二级标题的形式，如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Typora_%E8%BE%93%E5%85%A5%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98.gif" alt="Typora_输入二级标题"></p><p>这么一来，屏幕上的空间基本都可以被用来写作，不需要担心被预览用的列给占据了。</p><p>然后，Typora没有自定义它的存储结构，它直接打开磁盘上的.md文件进行编辑，这些Markdown源文件可以随心所欲地放在任何喜欢的目录下，只要能打开就行。再加上它文件树视图，就实现了不受限制的笔记组织方式了，如下图</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Typora_%E6%96%87%E4%BB%B6%E6%A0%91%E8%A7%86%E5%9B%BE.png" alt="Typora_文件树视图"></p><p>不过一个可以想到的缺点，就是Typora不支持在所有的Markdown文件上搜索关键字——毕竟它也不知道要去哪个目录下寻找这些待搜索的源文件。</p><p>尽管Typora外观很简洁，但Boostnote有的功能它一个也没有落下，就像它的官网所说的那样</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Typora%E7%9A%84%E5%AE%98%E7%BD%91%E5%AE%A3%E4%BC%A0.png" alt="Typora的官网宣传"></p><p>现在我的博客的文章基本都是用Typora来写的，冥冥中感受到了一股乐趣。但Typora毕竟没有搜索功能，所以我又开始摸索额外的搜索笔记的方式了（比如把记录在.org文件中的FAQ导入到ElasticSearch中再借助全文搜索的力量来找到自己要的内容）。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>没有最好的，只有最适合的，祝各位都能找到最适合自己的Markdown编辑器。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="boostnote" scheme="https://liutos.github.io/tags/boostnote/"/>
    
      <category term="editor" scheme="https://liutos.github.io/tags/editor/"/>
    
      <category term="markdown" scheme="https://liutos.github.io/tags/markdown/"/>
    
      <category term="note taking" scheme="https://liutos.github.io/tags/note-taking/"/>
    
      <category term="typora" scheme="https://liutos.github.io/tags/typora/"/>
    
      <category term="yu writer" scheme="https://liutos.github.io/tags/yu-writer/"/>
    
      <category term="笔记类软件" scheme="https://liutos.github.io/tags/%E7%AC%94%E8%AE%B0%E7%B1%BB%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="编辑器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
  </entry>
  
  <entry>
    <title>把GitHub作为图床</title>
    <link href="https://liutos.github.io/2018/12/07/%E6%8A%8AGitHub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/"/>
    <id>https://liutos.github.io/2018/12/07/把GitHub作为图床/</id>
    <published>2018-12-07T05:31:59.000Z</published>
    <updated>2019-01-09T15:20:35.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近又迷恋上了写博客，尤其是前一段时间很想要写点东西分享一些软件的使用感想。但当写完文章想要发表时就会碰到一个问题：由于我是现在本机的编辑器中用Markdown写好了全文的内容，再发表到各个平台（曾经是GitHub Pages搭建的博客，后来又多了简书，现在再加上SegmentFault）上的，因此文章里的图片都是引用在本地磁盘上的文件路径的。这么一来，如果直接将文章源码粘贴到博客平台上——比如粘贴到SegmentFault中，那么这些本地的图片链接就无法在发布后的文章中正常显示了。</p><p>如果一开始就在SegmentFault中写作也会遇到问题。SegmentFault上的文章插入图片后，并不是像普通的Markdown源码那般插入一条<code>![]()</code>形式的标记的，而是像下图这样</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%9C%A8SegmentFault%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="在SegmentFault中插入图片后的效果"></p><p>显然，这样的文章源码复制到其它平台（GitHub Pages、简书）去发布的话，必然是需要针对其中的图片标记修改一番的——比刚开始的方法或许要更麻烦。</p><p>看来要解决这个图片链接在不同平台间共用的问题，必须有一处纯粹的用于存放图片文件的地方——也就是大家常说的图床了。刚开始我也放狗搜了一下，看看别人的推荐，印象中得到的答复不外乎是又○云、七○云、新○微博，以及<a href="https://sm.ms/" target="_blank" rel="noopener">sm.ms</a>等。但它们要么需要注册并且实名认证，要么不纯粹，要么让人觉得随时会丢失。</p><p>某个晚上忽然想到，GitHub不就是一个很好的图床么？！在GitHub上建一个仓库专门存放博客中的图片，不仅免费、完全受自己管理，而且自带CDN加速，并且我的读者群（如果真的有这么一个群体的话）也应当可以畅通地访问GitHub。</p><p>放图片的仓库虽然有了，但用起来还不是很便利——因为作为写作素材的图片在我的电脑上是存放在一个单独的、非GitHub仓库的目录下的，所以如果要丢到图床上，就需要先将文件复制过去，然后执行git的add、commit、push三部曲，最后还要到GitHub上复制这张新图片的“raw”地址。</p><p>这个过程很机械化，完全可以用一个<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>的<a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">Workflow</a>来代劳。</p><h2 id="编写Workflow"><a href="#编写Workflow" class="headerlink" title="编写Workflow"></a>编写Workflow</h2><p>编写Workflow就像编写Common Lisp中的宏一样，总是从它们的用法入手的。在我的设想中，这个Workflow的使用方式应当是：</p><ol><li>首先，按下快捷键调出Alfred的输入框，输入关键字（在我这里就叫做upload）来唤起这个Workflow；</li><li>然后，输入要上传的图片文件的绝对路径并按下回车，开始在后台处理</li><li>最后，上传完毕后，弹出通知来告诉我</li></ol><p>整个Workflow的概貌其实很简单</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Alfred%E4%B8%AD%E7%9A%84upload%E7%9A%84%E9%B8%9F%E7%9E%B0%E5%9B%BE.png" alt="upload Workflow的全貌"></p><p>第二个节点所调用的External Script是长这样子的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将磁盘文件上传到GitHub</span></span><br><span class="line"></span><br><span class="line">path=$&#123;1&#125;</span><br><span class="line"></span><br><span class="line">pictures_dir="$&#123;HOME&#125;/Documents/Projects/riverbed/pictures"</span><br><span class="line">cp "$&#123;path&#125;" "$&#123;pictures_dir&#125;"</span><br><span class="line">echo '文件复制完毕'</span><br><span class="line"></span><br><span class="line">file=$(basename "$&#123;path&#125;")</span><br><span class="line">cd "$&#123;pictures_dir&#125;"</span><br><span class="line">git add "$&#123;file&#125;"</span><br><span class="line">git commit -m '上传一张图片'</span><br><span class="line">git push -u origin master</span><br><span class="line">echo '文件已提交到GitHub'</span><br><span class="line"></span><br><span class="line">/usr/local/bin/node -e "console.log(encodeURI('https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/$&#123;file&#125;'));" | tr -d '\n' | pbcopy</span><br></pre></td></tr></table></figure><p>获取文件的绝对路径其实很简单，在Finder中选中文件后，按下Command+Option+C即可</p><p>这里使用<code>basename</code>命令获取文件名。并且，为了避免<code>git</code>打开文本编辑器要求输入commit message，向git-commit命令传递了<code>-m</code>选项。</p><p>因为文件名含有非ASCII的字符（毕竟会有中文），需要做一次URL编码，因此用了<code>node</code>来做转换。在Node.js代码中用<code>console.log</code>输出编码后的图片URL，结尾会有一个换行符，所以用<code>tr</code>将其去掉。最后，输出的内容重定向给<code>pbcopy</code>，就将上传后的图片URL复制到剪贴板中了。如果此时正在编辑文章，便可以粘贴这个图片的链接到源码中。</p><p>Alfred也提供<code>Copy to Clipboard</code>，用于将Workflow中上一个节点的输出复制到剪贴板中。之所以不使用，其实是因为刚开始的时候就是用的Alfred的<code>Copy to Clipboard</code>，结果发现<code>git</code>运行过程中的输出也被Alfred接收了，跟图片URL一起混进了剪贴板中。所以最后改为直接调用<code>pbcopy</code>。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="alfred" scheme="https://liutos.github.io/tags/alfred/"/>
    
      <category term="github" scheme="https://liutos.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>编写嵌套反引号的宏</title>
    <link href="https://liutos.github.io/2018/11/27/%E7%BC%96%E5%86%99%E5%B5%8C%E5%A5%97%E5%8F%8D%E5%BC%95%E5%8F%B7%E7%9A%84%E5%AE%8F/"/>
    <id>https://liutos.github.io/2018/11/27/编写嵌套反引号的宏/</id>
    <published>2018-11-27T15:11:42.000Z</published>
    <updated>2019-01-09T15:20:35.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个没事找事的例子"><a href="#一个没事找事的例子" class="headerlink" title="一个没事找事的例子"></a>一个没事找事的例子</h2><p>当在Common Lisp中定义宏的时候，常常会使用到反引号（`）。比方说，我有这么一个函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobar ()</span><br><span class="line">  (<span class="name">+</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">  (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">  (<span class="name">+</span> <span class="number">5</span> <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p><p>它被调用后会返回最后一个表达式的结果——13。如果我希望在第二个表达式计算后就把结果返回给外部的调用者的话，可以用<code>return-from</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobar ()</span><br><span class="line">  (<span class="name">+</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">  (<span class="name">return-from</span> foobar (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">  (<span class="name">+</span> <span class="number">5</span> <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p><p>当然了，这属于没事找事，因为完全可以把最后两个表达式放到一个<code>prog1</code>（这也是没事找事），或者直接点，把最后一个表达式删掉来做到同样的效果——但如果是这样的话这篇东西就写不下去了，所以我偏要用<code>return-from</code>。</p><p>还有一个更加没事找事的办法，就是用<code>macrolet</code>定义一个局部的宏来代替<code>return-from</code>——我很想把这个新的宏叫做<code>return</code>，但这样<a href="http://www.sbcl.org/" target="_blank" rel="noopener">SBCL</a>会揍我一顿，所以我只好把这个宏叫做<code>bye</code>（叫做<code>exit</code>也会被揍）<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobar ()</span><br><span class="line">  (<span class="name">macrolet</span> ((<span class="name">bye</span> (<span class="name">&amp;optional</span> value)</span><br><span class="line">               `(return-from foobar ,value)))</span><br><span class="line">    (<span class="name">+</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">    (<span class="name">bye</span> (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">    (<span class="name">+</span> <span class="number">5</span> <span class="number">8</span>)))</span><br></pre></td></tr></table></figure></p><p>如果我有另一个叫做<code>foobaz</code>的函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobaz ()</span><br><span class="line">  (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">  (<span class="name">+</span> <span class="number">3</span> <span class="number">4</span>)</span><br><span class="line">  (<span class="name">+</span> <span class="number">5</span> <span class="number">6</span>))</span><br></pre></td></tr></table></figure></p><p>也想要拥有<code>bye</code>这种想来就来想走就走的能力的话，可以依葫芦画瓢地包含一个<code>macrolet</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foobaz ()</span><br><span class="line">  (<span class="name">macrolet</span> ((<span class="name">bye</span> (<span class="name">&amp;optional</span> value)</span><br><span class="line">               `(return-from foobaz ,value)))</span><br><span class="line">    (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>)</span><br><span class="line">    (<span class="name">bye</span> (<span class="name">+</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">    (<span class="name">+</span> <span class="number">5</span> <span class="number">6</span>)))</span><br></pre></td></tr></table></figure></p><p>好了，现在我觉得每次都需要在函数体内粘贴一份<code>bye</code>的实现代码太麻烦了，想要减少这种重复劳作。于是乎，我打算写一个宏来帮我复制粘贴代码。既然要定义宏，那么首先应当定义这个宏的名字以及用法，姑且是这么用的吧<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">with-bye</span> foobar</span><br><span class="line">  (<span class="name">+</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">  (<span class="name">bye</span> (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">  (<span class="name">+</span> <span class="number">5</span> <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p><p><code>with-bye</code>这个宏需要能够展开成上面的手动编写的<code>foobar</code>中的函数体的代码形式，那么<code>with-bye</code>的定义中，就一定会含有<code>macrolet</code>的代码，同时也就含有了反引号——好了，现在要来处理嵌套的反引号了。</p><p><a href="https://blog.csdn.net/xiaojianpitt/article/details/7747230" target="_blank" rel="noopener">这篇文章</a>有个不错的讲解，各位不妨先看看。现在，让我来机械化地操作一遍，给出<code>with-bye</code>的定义。首先，要确定生成的目标代码中，那一些部分是可变的。对于<code>with-bye</code>而言，<code>return-from</code>的第一个参数已经<code>macrolet</code>的函数体是可变的，那么不妨把这两部分先抽象为参数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">name</span> 'foobar)</span><br><span class="line">      (<span class="name">body</span> '((+ <span class="number">1</span> <span class="number">1</span>) (bye (+ <span class="number">2</span> <span class="number">3</span>)) (+ <span class="number">5</span> <span class="number">8</span>))))</span><br><span class="line">  `(macrolet ((bye (&amp;optional value)</span><br><span class="line">                `(return-from ,name ,value)))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure></p><p>但这样是不够的，因为<code>name</code>是一个在最外层绑定的，但它被放在了两层的反引号当中，如果它只有一个前缀的逗号，那么它就无法在外层的反引号求值的时候被替换为目标的<code>FOOBAR</code>符号。因此，需要在<code>,name</code>之前再添加一个反引号<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">name</span> 'foobar)</span><br><span class="line">      (<span class="name">body</span> '((+ <span class="number">1</span> <span class="number">1</span>) (bye (+ <span class="number">2</span> <span class="number">3</span>)) (+ <span class="number">5</span> <span class="number">8</span>))))</span><br><span class="line">  `(macrolet ((bye (&amp;optional value)</span><br><span class="line">                `(return-from ,,name ,value)))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure></p><p>如果你在Emacs中对上述的表达式进行求值，那么它吐出来的结果实际上是<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">MACROLET</span> ((<span class="name">BYE</span> (<span class="name">&amp;OPTIONAL</span> VALUE)</span><br><span class="line">             `(RETURN-FROM ,FOOBAR ,VALUE)))</span><br><span class="line">  (<span class="name">+</span> <span class="number">1</span> <span class="number">1</span>)</span><br><span class="line">  (<span class="name">BYE</span> (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">  (<span class="name">+</span> <span class="number">5</span> <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p><p>显然，这还是不对。如果生成了上面这样的代码，那么对于<code>bye</code>而言<code>FOOBAR</code>就是一个未绑定的符号了。之所以会这样，是因为</p><ol><li><code>name</code>在绑定的时候输入的是一个符号，并且</li><li><code>name</code>被用在了嵌套的反引号内，它会被求值两次——第一次求值得到符号<code>foobar</code>，第二次则是<code>foobar</code>会被求值</li></ol><p>因此，为了对抗第二次的求值，需要给<code>,name</code>加上一个前缀的引号（‘），最终效果如下<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">name</span> 'foobar)</span><br><span class="line">      (<span class="name">body</span> '((+ <span class="number">1</span> <span class="number">1</span>) (bye (+ <span class="number">2</span> <span class="number">3</span>)) (+ <span class="number">5</span> <span class="number">8</span>))))</span><br><span class="line">  `(macrolet ((bye (&amp;optional value)</span><br><span class="line">                `(return-from ,',name ,value)))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure></p><p>所以<code>with-bye</code>的定义是这样的<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> with-bye (<span class="name">name</span> <span class="symbol">&amp;body</span> body)</span><br><span class="line">  `(macrolet ((bye (&amp;optional value)</span><br><span class="line">                `(return-from ,',name ,value)))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure></p><h2 id="机械化的操作方法"><a href="#机械化的操作方法" class="headerlink" title="机械化的操作方法"></a>机械化的操作方法</h2><p>我大言不惭地总结一下，刚才的操作步骤是这样的。首先，找出一段有规律的、需要被用宏来实现的目标代码；然后，识别其中的可变的代码，给这些可变的代码的位置起一个名字（例如上文中的<code>name</code>和<code>body</code>），将它们作为<code>let</code>表达式的绑定，把目标代码装进同一个<code>let</code>表达式中。此时，目标代码被加上了一层反引号，而根据每个名字出现的位置的不同，为它们适当地补充一个前缀的逗号；最后，如果在嵌套的反引号中出现的名字无法被求值多次——比如符号或者列表，那么还需要给它们在第一个逗号后面插入一个引号，避免被求值两次招致未绑定的错误。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>就用上面所引用的文章里的例子好了。有一天我觉得Common Lisp中一些常用的宏的名字实在是太长了想要精简一下——毕竟敲键盘也是会累的——假装没有自动补全的功能。我可能会定义下面这两个宏<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> d-bind (<span class="name">&amp;body</span> body)</span><br><span class="line">  `(destructuring-bind ,@body))</span><br><span class="line">(<span class="name">defmacro</span> mv-bind (<span class="name">&amp;body</span> body)</span><br><span class="line">  `(multiple-value-bind ,@body))</span><br></pre></td></tr></table></figure></p><p>显然，这里的代码的写法出现了重复模式，不妨试用按照机械化的操作手法来提炼出一个宏。第一步，先识别出其中可变的内容。对于上面这个例子而言，变化的地方其实只有两个名字——新宏的名字（<code>d-bind</code>和<code>mv-bind</code>），以及旧宏的名字（<code>destructuring-bind</code>和<code>multiple-value-bind</code>）。第二步，给它们命名并剥离成<code>let</code>表达式的绑定，得到如下的代码<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">new-name</span> 'd-bind)</span><br><span class="line">      (<span class="name">old-name</span> 'destructuring-bind))</span><br><span class="line">  `(defmacro ,new-name (&amp;body body)</span><br><span class="line">     `(,old-name ,@body)))</span><br></pre></td></tr></table></figure></p><p>因为<code>old-name</code>处于嵌套的反引号中，但是它是由最外层的<code>let</code>定义的，所以应当添上一个前缀的逗号，得到<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">new-name</span> 'd-bind)</span><br><span class="line">      (<span class="name">old-name</span> 'destructuring-bind))</span><br><span class="line">  `(defmacro ,new-name (&amp;body body)</span><br><span class="line">     `(,,old-name ,@body)))</span><br></pre></td></tr></table></figure></p><p>最后，因为<code>old-name</code>绑定的是一个符号，不能被两次求值（第二次是在<code>defmacro</code>定义的新宏中展开，此时<code>old-name</code>已经被替换为了<code>destructuring-bind</code>，而它对于新宏而言是一个自由变量，并没有被绑定），所以需要有一个单引号来阻止第二次的求值——因为需要的就是符号<code>destructuring-bind</code>本身。所以，最终的代码为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defmacro</span> define-abbreviation (<span class="name">new-name</span> old-name)</span><br><span class="line">  `(defmacro ,new-name (&amp;body body)</span><br><span class="line">     `(,',old-name ,@body)))</span><br></pre></td></tr></table></figure></p><p>试一下就可以确认这个<code>define-abbreviation</code>是能用的（笑</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>能够指导编写宏的、万能的、机械化的操作方法，我想应该是不存在的</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="macro" scheme="https://liutos.github.io/tags/macro/"/>
    
      <category term="宏" scheme="https://liutos.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>重复输入相似的命令的几种方法</title>
    <link href="https://liutos.github.io/2018/11/25/%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5%E7%9B%B8%E4%BC%BC%E7%9A%84%E5%91%BD%E4%BB%A4%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://liutos.github.io/2018/11/25/重复输入相似的命令的几种方法/</id>
    <published>2018-11-25T14:40:51.000Z</published>
    <updated>2019-01-09T15:20:35.088Z</updated>
    
    <content type="html"><![CDATA[<p>在命令行经常需要重复输入一些shell代码，例如用cd切换到某个目录、运行npm run local，或者git commit等。每次都完整地一个个字符地敲入这些命令还是很麻烦的，这种时候就要寻找可以解决重复输入，提高效率的办法了。</p><p>最原始的，当然是找一个文本文件，把平时经常敲入的命令存放在其中，每当需要运行这些命令的时候就打开文件选中内容复制一下，再到终端粘贴并运行，但这未免过于原始了。</p><h2 id="使用ctrl-r翻出历史命令"><a href="#使用ctrl-r翻出历史命令" class="headerlink" title="使用ctrl-r翻出历史命令"></a>使用ctrl-r翻出历史命令</h2><p>使用ctrl-r是一种不那么原始的方法。在终端中按下ctrl-r后，shell会等待进一步地输入，并根据输入从以前输入过的命令中找出匹配的一条。找到了自己所需要的命令行，直接敲击回车即可，效果如下<br><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/ctrl_r%E7%9A%84%E6%95%88%E6%9E%9C.gif" alt="ctrl-r的效果"><br>PS：上面是使用了<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">fzf</a>之后的效果，所以在敲入回车后并不会立即执行所选中的命令。原生的ctrl-r命令不支持在不同的位置上匹配输入字符，所以还是推荐一试fzf的。</p><h2 id="使用alias"><a href="#使用alias" class="headerlink" title="使用alias"></a>使用alias</h2><p>alias相比于ctrl-r而言进化了一点，因为它毕竟不再需要往命令行中塞入那么多字符了——它让终端用户可以用较短的内容来代替较长的内容。例如，我就给登录我本地的MySQL的命令写了一个alias<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> myroot=<span class="string">'mysql -u root -p*******'</span></span><br></pre></td></tr></table></figure></p><p>而且alias更像是宏展开，所以可以在后面添加其它内容，如下图<br><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/alias%E7%9A%84%E6%95%88%E6%9E%9C.gif" alt="alias的效果"><br>在myroot之后输入的test和user_info都跟着myroot展开后的结果一起喂给了shell去执行。使用alias之后，每次只需要输入较短的myroot即可。</p><h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>如果说alias是C语言里面的宏的话，那么shell所支持的函数就是C语言里面的函数了（这不是废话么）。alias始终不太适合所要输入的内容比较多的场景——定义也特别难写，并且alias没有输入参数可言，也不适合处理需要有为妙差异的重复内容的情况。shell函数很适合这种情况，例如，我在本地编辑完一个.sd文件后需要用<a href="http://sdedit.sourceforge.net/index.html" target="_blank" rel="noopener">sdedit</a>将其转换为.png文件，方能上传到Confluence上贴到设计文档里，我希望.png文件跟.sd文件有相同的basename，那么用下面这个shell函数可以减轻一些重复输入的劳动力<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据.sd文件生成同名的.png文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sdpng</span></span>() &#123;</span><br><span class="line">    basename=<span class="variable">$&#123;1&#125;</span></span><br><span class="line">    /usr/<span class="built_in">local</span>/bin/sdedit -t png -o <span class="variable">$&#123;basename&#125;</span>.png <span class="variable">$&#123;basename&#125;</span>.sd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要我输入一次文件名即可，效果如下<br><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/shell%E5%87%BD%E6%95%B0%E7%9A%84%E6%95%88%E6%9E%9C.gif" alt="shell函数的效果"></p><h2 id="使用Alfred的Snippets功能"><a href="#使用Alfred的Snippets功能" class="headerlink" title="使用Alfred的Snippets功能"></a>使用Alfred的Snippets功能</h2><p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>带有一个叫做Snippets的特性<br><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Alfred%E7%9A%84Snippets%E7%89%B9%E6%80%A7.png" alt="Alfred的Snippets特性"><br>它跟上面所说的alias很相似，但它不是由shell自己处理悄悄展开的，它是显式地输入一长串的字符。比如说我定义了三个短语：gpd、gct，以及gpt，它们分别会展开为<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin develop</span><br><span class="line">git checkout <span class="built_in">test</span></span><br><span class="line">git push -u origin <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p><p>效果如下<br><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Alfred%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%E7%9A%84%E6%95%88%E6%9E%9C.gif" alt="Alfred的Snippets自动展开的效果"><br>Alfred的Snippets也跟alias一样是不能接受参数的，不过支持一些占位符，可以展开为一些特定模式的动态内容。一个比较有用的是{cursor}这个占位符，可以让光标定位至此。例如我可以定义这样的一串展开结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `user_info` WHERE `userId` = &#123;cursor&#125;\G</span><br></pre></td></tr></table></figure></p><p>这样我敲入对应的短语后就可以正确定位到WHERE语句，然后直接输入要查询的参数即可，效果如下<br><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/cursor%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E6%95%88%E6%9E%9C.gif" alt="cursor占位符的效果"></p><p>除了Alfred之外，还有其它的通过snippet提高输入效率的软件，比如<a href="http://www.trankynam.com/atext/" target="_blank" rel="noopener">aText</a>，<a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a>，不过我没有实际地用过，就不多说了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>没有代码才是最快地输入代码的方式</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="alfred" scheme="https://liutos.github.io/tags/alfred/"/>
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>值得使用的软件之Alfred</title>
    <link href="https://liutos.github.io/2018/11/16/%E5%80%BC%E5%BE%97%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B9%8BAlfred/"/>
    <id>https://liutos.github.io/2018/11/16/值得使用的软件之Alfred/</id>
    <published>2018-11-16T15:05:00.000Z</published>
    <updated>2018-12-02T13:30:21.596Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>是一款所谓的“生产力工具”，可以理解为就是帮助Mac用户提高日常事务的处理效率的工具，在我还没有入手MBP的时候就已经（在知乎上）听闻了这款软件的大名了。实际使用了之后发现确实可以提升一些事情的处理效率，是一款值得身为程序员的读者朋友使用的应用。接下来我会举一些例子来说明一下，希望可以传达到我的感受。献上我的Alfred使用统计<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx5nx11uumj21kw115n9m.jpg" alt="Alfred的使用统计"></p><h2 id="Alfred的Clipboard"><a href="#Alfred的Clipboard" class="headerlink" title="Alfred的Clipboard"></a>Alfred的Clipboard</h2><p>剪贴板真是一个再常用不过的功能了，我想所有的读者朋友应该都使用过复制&amp;粘贴的功能——不管是在Windows上面的Ctrl-c Ctrl-v也好，还是在Mac上面的Command-c Command-v也罢。Alfred的Clipboard功能可以认为是一个强化版的剪贴板，它可以通过快捷键（在我的系统上设置为了Command-p）快速唤出<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx5o8vf7g9j20vs0ngh1e.jpg" alt="Alfred唤出Clipboard"></p><p>并且支持搜索（虽然很遗憾图片没办法搜索）<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx5oh8pgiyj20vs0ngnh2.jpg" alt="在Clipboard中搜索"></p><p>当需要在两个应用间复制粘贴多段内容的时候，Clipboard就派上用场了。只需要先把需要的每一段内容在一个应用中分别复制一次，打开另一个应用后唤出Clipboard，便可以把刚才复制的内容逐个粘贴进来。每当我在一些地方看到有趣的图片想要分享给微信或者QQ的朋友时，也是打开微信或者QQ后进入Alfred的Clipboard浏览——打开Clipboard后，敲入“Image”，便可以只查看记录在剪贴板中的图片了，并且还可以在发送前预览<br><img src="http://wx4.sinaimg.cn/large/791cf7abgy1fx6clzi5sej20vq0ngqnt.jpg" alt="在Clipboard中搜索图片"></p><h2 id="Alfred的Snippets"><a href="#Alfred的Snippets" class="headerlink" title="Alfred的Snippets"></a>Alfred的Snippets</h2><p>Snippets算是我近期才挖掘到并开始重度使用的功能，用一句话概括，就是“长话短说”。在Snippets中可以新建一个较短的关键字来代替一串较长的输入，例如我就分别用了gcd、gct，以及gmd来代替切换到develop分支、切换到test分支，以及合并develop分支这三条常用的Git操作命令<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx7i4n82ouj21kw1144kh.jpg" alt="在Snippets中定义短语"></p><p>之后既可以通过快捷键唤出Snippets面板的方式来输入短语，也可以直接在短语定义时勾选【Auto expandsion allowed】来做到输入短语后自动展开为完整的内容。下图演示的是输入gcd后自动展开为完整的命令<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx95zf440lg20dc06n42u.gif" alt="自动展开Snippets中的短语"></p><p>我现在已经积累了很多的短语了，不仅提高了输入的速度，也降低了重复输入这些内容的出错率，实在是居家旅行coding必备。</p><h2 id="Alfred的Workflow"><a href="#Alfred的Workflow" class="headerlink" title="Alfred的Workflow"></a>Alfred的Workflow</h2><p>购买Alfred的Powerpack后就可以开启<a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">Workflow</a>的功能了，实际上，在我真正开始用Alfred之前（还在用着Windows的时候），对Alfred的了解基本上局限于“它拥有一个很强大的叫做Workflow的功能”这样，可以说，让Alfred如此闻名遐迩的就是它的Workflow特性吧——不过后来我才知道原来Mac自带一个叫做Automator的类似的功能。</p><p>刚开始接触Workflow的时候，我也沉迷于在网上搜罗别人写好的来用，慢慢地才发现这些其他人经常（在知乎的答案里）列举到的Workflow，其实并不适合我。有一两个觉得眼前一亮的，在使用了一两次之后也就不怎么用了。现在，我自己写了一些Workflow，倒是显著地提升了我的开发过程。</p><p>比较合适作为例子的是我写的三个用于处理时间的Workflow。一个是用于将日期时间字符串转换为UNIX时间戳（毫秒单位）的Workflow，名为gt——取的是get time之意。使用起来的效果大致如下<br><img src="http://wx1.sinaimg.cn/large/791cf7abgy1fx95y9x87ng20dc0c81en.gif" alt="gt的使用效果"></p><p>这个Workflow最终会把结果复制到剪贴板中，便于在其它应用中使用。由于工作内容的缘故，我常常会需要获取某一个时候的UNIX时间戳（毫秒单位）。在有这个Workflow之前，我都是打开iTerm运行node，然后敲入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2018-11-15 00:00:00'</span>).getTime();</span><br></pre></td></tr></table></figure></p><p>这般的代码来得到结果的，不仅要在不同的应用间切换来切换去的，而且还需要重复地敲入new、Date，以及getTime等字眼，实在是一件很低效的事情。使用了gt之后，感觉幸福感也提高了很多。</p><p>另一个Workflow名为wt——取的是what time之意，它的作用跟gt相反，是将毫秒数转换为可读的日期时间字符串，效果如下<br><img src="http://wx2.sinaimg.cn/large/791cf7abgy1fx960hx1heg20dc0c849f.gif" alt="wt的使用效果"></p><p>最后一个Workflow名为int——即I need time，它可以提供特定的一些时刻的时间戳，例如【今天零点】这样的特定的时刻。这三个Workflow的入口节点都是一个<a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/" target="_blank" rel="noopener">Script Filter</a>，int的使用效果如下<br><img src="http://wx3.sinaimg.cn/large/791cf7abgy1fx9um0vongg20dc0c8k95.gif" alt="int的使用效果"></p><p>Alfred的Workflow还可以做很多的事情。它是一个入口，很适合用于不需要肉眼查看含有大段文字的结果的交互场景，例如对字符串做编码转换、计算字符串的摘要、通过AppleScript调起微信联系人，以及控制音量等等，只要好好利用，就可以提升平时的使用效率。程序员朋友们，不妨一起来发挥自己的创造力吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="alfred" scheme="https://liutos.github.io/tags/alfred/"/>
    
  </entry>
  
  <entry>
    <title>flexi-streams用法简介</title>
    <link href="https://liutos.github.io/2018/09/18/flexi-streams%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>https://liutos.github.io/2018/09/18/flexi-streams用法简介/</id>
    <published>2018-09-18T15:14:50.000Z</published>
    <updated>2018-12-02T13:29:44.528Z</updated>
    
    <content type="html"><![CDATA[<p>每过一段时间总会燃起一种用Common Lisp（下文简称CL）来写Web应用的冲动，继而就会开始感慨在CL的生态圈中居然没有一款好用的Web框架。尽管放狗搜索“common lisp web framework”可以找到一些——例如Caveman2，以及在Cliki中记录的一些其它框架。然后使用过其中一部分的人就会知道，大部分用起来的体验都不咋地。</p><p>在业界摸爬打滚了一小段时光（从业几年姑且可以这么说吧）后，感觉制作一款专门用于编写JSON-in-JSON-out的Web应用的Web框架应该是一个不错的点子——反正大家都是发出application/json的请求期望application/json的响应，于是乎就撸起袖子自己干了。不过完全从零开始编写起是不现实的，于是乎选择了一个“平台”来作为基础。这个平台就是<a href="https://github.com/fukamachi/clack" target="_blank" rel="noopener">Clack</a>啦</p><p>Clack会负责屏蔽下层的Web Server的差异，它只需要我提供一个函数给它作为来访的HTTP请求的“handler”即可，然后在这个handler中我就可以为所欲为啦。Clack在收到HTTP请求后，会把HTTP请求中的一些信息组织为一个列表类型的值传递给这个handler。在这个handler中，我只需要综合运用CAR、CDR之类的奇怪名字的函数就可以拿到自己需要的东西了——当然了，鉴于这个列表是个plist，用CL提供的DESTRUCTURING-BIND就可以很方便地提取啦。</p><p>在这个plist中，就有一个叫做:RAW-BODY的p，它的值是一个“流”——是的，就是那种文件流的流！但它又不是一个路边随处可见的妖艳贱货的流，而是一个来自FLEXI-STREAMS这个包（指CL中的package）的流。<a href="https://edicl.github.io/flexi-streams/" target="_blank" rel="noopener">FLEXI-STREAMS</a>是一个提供流操作的库，鉴于我没有看过<a href="http://www.nhplace.com/kent/CL/Issues/stream-definition-by-user.html" target="_blank" rel="noopener">Gray streams</a>相关的内容，就不在这里瞎逼逼误导读者了。总而言之，我必须找到一个办法可以从一个FLEXI-STREAMS提供的输入流类型的值中读出一些东西来。</p><p>其实这个办法很简单，就是用CL原生提供的读取流的函数即可——比如READ-SEQUENCE这样的函数。不过我得验证一下不是，为此，我需要有办法可以构造出一个FLEXI-STREAMS流类型的值出来。FLEXI-STREAMS提供了一个叫做MAKE-FLEXI-STREAM的函数，显然这个就是我所需要调用的最后一个函数了。从它的描述来看，它需要一个CL中的原生流来作为第一个参数才行。为此，我试了一下下面的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">text</span> <span class="string">"Hello, world!"</span>))</span><br><span class="line">  (<span class="name">with-input-from-string</span> (<span class="name">s</span> text)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">buffer</span> (<span class="name">make-array</span> (<span class="name">length</span> text)))</span><br><span class="line">          (<span class="name">fs</span> (<span class="name">flexi-streams</span><span class="symbol">:make-flexi-stream</span> s)))</span><br><span class="line">      (<span class="name">read-sequence</span> buffer fs))))</span><br></pre></td></tr></table></figure><p>遗憾的是，运行上面的代码会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">The value</span><br><span class="line">  #\H</span><br><span class="line">is not of type</span><br><span class="line">  (UNSIGNED-BYTE 8)</span><br><span class="line">when setting an element of (ARRAY (UNSIGNED-BYTE 8))</span><br><span class="line">   [Condition of type TYPE-ERROR]</span><br><span class="line"></span><br><span class="line">Restarts:</span><br><span class="line"> 0: [RETRY] Retry SLIME interactive evaluation request.</span><br><span class="line"> 1: [*ABORT] Return to SLIME&apos;s top level.</span><br><span class="line"> 2: [ABORT] abort thread (#&lt;THREAD &quot;worker&quot; RUNNING &#123;1007766D53&#125;&gt;)</span><br><span class="line"></span><br><span class="line">Backtrace:</span><br><span class="line">  0: ((SB-VM::OPTIMIZED-DATA-VECTOR-SET (UNSIGNED-BYTE 8)) #&lt;unavailable argument&gt; #&lt;unavailable argument&gt; #&lt;unavailable argument&gt;)</span><br><span class="line">  1: (SB-IMPL:ANSI-STREAM-READ-SEQUENCE #(0 0 0 0 0 0 ...) #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;1007975973&#125;&gt; 0 13)</span><br><span class="line">  2: (READ-SEQUENCE #(0 0 0 0 0 0 ...) #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;1007975973&#125;&gt; :START 0 :END 13)</span><br><span class="line">  3: ((FLET FLEXI-STREAMS::FILL-BUFFER :IN FLEXI-STREAMS::READ-SEQUENCE*) 13)</span><br><span class="line">  4: ((:METHOD FLEXI-STREAMS::READ-SEQUENCE* (FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT T T T T)) #&lt;FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT (:ISO-8859-1 :EOL-STYLE :LF) &#123;1007975B43&#125;&gt; #&lt;FLEXI-STREAMS:FLEXI-INPUT-STRE..</span><br><span class="line">  5: ((:METHOD STREAM-READ-SEQUENCE (TRIVIAL-GRAY-STREAMS:FUNDAMENTAL-INPUT-STREAM T)) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;1007975C73&#125;&gt; #(0 0 0 0 0 0 ...) 0 NIL) [fast-method]</span><br><span class="line">  6: (READ-SEQUENCE #(0 0 0 0 0 0 ...) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;1007975C73&#125;&gt; :START 0 :END NIL)</span><br><span class="line">  7: ((LAMBDA ()))</span><br><span class="line">  8: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))) #&lt;NULL-LEXENV&gt;)</span><br><span class="line">  9: (EVAL (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))))</span><br><span class="line"> 10: ((LAMBDA NIL :IN SWANK:INTERACTIVE-EVAL))</span><br><span class="line"> --more--</span><br></pre></td></tr></table></figure><p>既然在调用READ-SEQUENCE的时候出状况了，不妨试试下面的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">text</span> <span class="string">"Hello, world!"</span>))</span><br><span class="line">  (<span class="name">with-input-from-string</span> (<span class="name">s</span> text)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">fs</span> (<span class="name">flexi-streams</span><span class="symbol">:make-flexi-stream</span> s)))</span><br><span class="line">      (<span class="name">read-char</span> fs))))</span><br></pre></td></tr></table></figure><p>再次令人遗憾的，它会抛出另一个状况（CL中的condition啦）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#&lt;SB-IMPL::STRING-INPUT-STREAM &#123;10020A7243&#125;&gt; is not a binary input stream.</span><br><span class="line">   [Condition of type SIMPLE-TYPE-ERROR]</span><br><span class="line"></span><br><span class="line">Restarts:</span><br><span class="line"> 0: [RETRY] Retry SLIME interactive evaluation request.</span><br><span class="line"> 1: [*ABORT] Return to SLIME&apos;s top level.</span><br><span class="line"> 2: [ABORT] abort thread (#&lt;THREAD &quot;worker&quot; RUNNING &#123;1001F6E813&#125;&gt;)</span><br><span class="line"></span><br><span class="line">Backtrace:</span><br><span class="line">  0: (SB-KERNEL:ILL-BIN #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;10020A7243&#125;&gt;)</span><br><span class="line">  1: (READ-BYTE #&lt;SB-IMPL::STRING-INPUT-STREAM &#123;10020A7243&#125;&gt; NIL NIL)</span><br><span class="line">  2: ((:METHOD FLEXI-STREAMS::READ-BYTE* (FLEXI-STREAMS:FLEXI-INPUT-STREAM)) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;10020A74C3&#125;&gt;) [fast-method]</span><br><span class="line">  3: ((:METHOD FLEXI-STREAMS::OCTETS-TO-CHAR-CODE (FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT T)) #&lt;FLEXI-STREAMS::FLEXI-LATIN-1-FORMAT (:ISO-8859-1 :EOL-STYLE :LF) &#123;10020A7393&#125;&gt; #&lt;unavailable argument&gt;) [fast-me..</span><br><span class="line">  4: ((:METHOD STREAM-READ-CHAR (FLEXI-STREAMS:FLEXI-INPUT-STREAM)) #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;10020A74C3&#125;&gt;) [fast-method]</span><br><span class="line">  5: (READ-CHAR #&lt;FLEXI-STREAMS:FLEXI-INPUT-STREAM &#123;10020A74C3&#125;&gt; T NIL #&lt;unused argument&gt;)</span><br><span class="line">  6: ((LAMBDA ()))</span><br><span class="line">  7: (SB-INT:SIMPLE-EVAL-IN-LEXENV (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))) #&lt;NULL-LEXENV&gt;)</span><br><span class="line">  8: (EVAL (LET ((TEXT &quot;Hello, world!&quot;)) (WITH-INPUT-FROM-STRING (S TEXT) (LET # #))))</span><br><span class="line">  9: ((LAMBDA NIL :IN SWANK:INTERACTIVE-EVAL))</span><br><span class="line"> --more--</span><br></pre></td></tr></table></figure><p>看来从一开始提供给MAKE-FLEXI-STREAM函数的参数就应当是一个“二进制”的流才对。为此，我需要借助FLEXI-STREAMS自身的力量——调用它的STRING-TO-OCTETS函数。使用这个函数，可以将一个字符串转换为某种编码下的字节数组，例如下面的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">flexi-streams</span><span class="symbol">:string-to-octets</span> <span class="string">"Hello"</span>) <span class="comment">;#(72 101 108 108 111)</span></span><br></pre></td></tr></table></figure><p>得到一串“octet”后，还需要将其转换为“流”才行。再次借助FLEXI-STREAMS的力量，调用它的MAKE-IN-MEMORY-INPUT-STREAM函数，然后将这个函数调用的返回值作为MAKE-FLEXI-STREAM的第一个参数即可，最终的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">text</span> <span class="string">"Hello, world!"</span>)           <span class="comment">; 原始文本</span></span><br><span class="line">       (<span class="name">octets</span> (<span class="name">flexi-streams</span><span class="symbol">:string-to-octets</span> text)) <span class="comment">; 使用flexi-streams转换为字节数组，因为下一个函数只接受这种类型的参数</span></span><br><span class="line">       (<span class="name">memory-input</span> (<span class="name">flexi-streams</span><span class="symbol">:make-in-memory-input-stream</span> octets)) <span class="comment">; 同样先转换为内存中的流，因为下一个函数只接受这种类型的参数</span></span><br><span class="line">       (<span class="name">flexi-stream</span> (<span class="name">flexi-streams</span><span class="symbol">:make-flexi-stream</span> memory-input)) <span class="comment">; 终于可以得到一个真正的flexi-stream了</span></span><br><span class="line">       (<span class="name">buffer</span> (<span class="name">make-array</span> (<span class="name">flexi-streams</span><span class="symbol">:octet-length</span> text)))) <span class="comment">; 这里其实用字节的长度还是用字符的长度（flexi-streams:char-length）都没差</span></span><br><span class="line">  (<span class="name">read-sequence</span> buffer flexi-stream)   <span class="comment">; 可以像处理CL中的流那样处理flexi-stream</span></span><br><span class="line">  (<span class="name">print</span> (<span class="name">coerce</span> buffer 'string)))      <span class="comment">; 把字节数组拼成字符串再输出比较好看</span></span><br></pre></td></tr></table></figure><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
  </entry>
  
  <entry>
    <title>sdedit使用方法介绍（混沌向）</title>
    <link href="https://liutos.github.io/2018/08/12/sdedit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%EF%BC%88%E6%B7%B7%E6%B2%8C%E5%90%91%EF%BC%89/"/>
    <id>https://liutos.github.io/2018/08/12/sdedit使用方法介绍（混沌向）/</id>
    <published>2018-08-12T00:52:54.000Z</published>
    <updated>2018-12-02T13:30:00.790Z</updated>
    
    <content type="html"><![CDATA[<p>最近在寻找绘制时序图的过程中遇到了sdedit，感觉非常适合自己使用，故写这么篇文章向自己也向有同样需求的其它开发人员介绍一些这款软件</p><p>sdedit在macOS上安装还是非常容易的，只需要使用homebrew就可以轻松安装，命令如下</p><pre><code>brew install sdedit</code></pre><p>之后sdedit就会被安装到/usr/local/bin 这个目录下，在命令中输入sdedit就可以启动了。</p><p>输入sdedit后会启动一个Java Swing写的GUI程序，具体的外观和布局就不介绍了，这里主要讲解一下sdedit所支持的语法</p><h1 id="sdedit中绘图的常用语法"><a href="#sdedit中绘图的常用语法" class="headerlink" title="sdedit中绘图的常用语法"></a>sdedit中绘图的常用语法</h1><p>PS：我对UML中的一些术语并不了解，下面的介绍是可能有错误的，具体请以sdedit的官方文档（<a href="http://sdedit.sourceforge.net/enter_text/" target="_blank" rel="noopener">http://sdedit.sourceforge.net/enter_text/</a>）为准。同时，既然有官方文档了，我就不在此翻译一遍了，只记录一些常用的用法</p><p>如果需要输入整个时序图的标题（姑且叫做标题），那么可以使用下面的语法</p><pre><code>#![一键获取手机号并登录的交互流程]</code></pre><p>即以UNIX中的shebang开头，后面通过一对方括号包住标题内容即可</p><p>如果需要绘制一个参与时序图的节点，那么使用下面的语法（摘抄自官方文档）</p><pre><code>&lt;name&gt;:&lt;Type&gt;[&lt;flags&gt;] &quot;&lt;label&gt;&quot;</code></pre><p>其中，<name>就是节点的唯一名字，之后当描述节点间的交互时需要这个字段，请给每一个节点都取一个独一无二的名字（就像取变量名那样）；<type>部分顾名思义就是类型，虽然我在使用的时候这个字段的值也是随心所欲地写的，但这个字段对sdedit而言似乎有特殊含义——例如，如果这个字段填入的是Actor，那么绘制出来的就会是一个人形的节点，在用来表示用户的时候特别有用；（flags我还没有用过就不介绍了）；label可以理解为节点的文案，如果不填<label>，那么节点在最终绘制的图中展示的时候用的就是<name>作为名字</name></label></type></name></p><p>定义好节点之后，就需要把各个节点在不同的时间用不同的消息联系起来了。描述节点间联系用的语法是（摘自官网）</p><pre><code>&lt;caller&gt;[&lt;s&gt;]:&lt;answer&gt;=&lt;callee&gt;[m].&lt;message&gt;</code></pre><p>其中的caller和callee都是写的节点的<name>（所以name需要时独一无二的），这样就会绘制出两条线——一条实线从caller指向callee，以及一条虚线从callee指向caller，以及在callee的生命周期下绘制出一个纵向的矩形，表示callee的处理过程；<message>是从caller发往callee的消息，例如参数的描述；如果需要同时描述从callee返回的结果，那么就需要填写在上述语法的的<answer>的位置——个人觉得这个语法是有点奇怪的</answer></message></name></p><h2 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h2><p>上面的这些文本描述都需要输入到sdedit的文本框中（唯一UI上的右下角），之后点击保存就可以得到一个XXX.sdx的文件了。由于在我的电脑上，sdedit的GUI上的导出功能用起来非常有问题，所以我摸索出来的是在命令行导出图片文件的做法（并且可以导出的格式似乎更丰富）。总体的用法是</p><pre><code>sdedit -t &lt;类型&gt; -o &lt;输出文件名&gt; &lt;原始的.sdx文件&gt;</code></pre><p>输出文件名随性地取即可，其中类型对常用的都有支持（svg、png、jpg，和bmp），我一般常用的是png，然后就可以得到一张PNG图片了（便可以美美地用到设计文档里了）</p><p>配图什么的等我哪天特别闲了再补充上来吧</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="sequence diagram" scheme="https://liutos.github.io/tags/sequence-diagram/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro使用体验</title>
    <link href="https://liutos.github.io/2018/08/02/MacBook-Pro%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>https://liutos.github.io/2018/08/02/MacBook-Pro使用体验/</id>
    <published>2018-08-02T15:33:58.000Z</published>
    <updated>2018-12-02T13:29:15.019Z</updated>
    
    <content type="html"><![CDATA[<p>生平第一次有一台自己的MacBook，使用了一段时间之后也有了自己的一番感想，特此写下来留个纪念。感想主要分为硬件以及软件两个方面，本文不会有太多的条理性</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>上周四晚上第一次从收件的超市老板手里接过MacBook Pro的时候，第一感觉是意想不到的沉重。回到家拆开包装，拿起机体和电源适配器的时候，也是觉得非常的重。虽然经过几天的使用后发现并没有当初那般沉重的感觉了，但总体还是超过了我的预期。</p><p>接着是发现这台电脑居然没有开机键。老实说，其实这个是我在昨天才意识到的；同时，这台电脑只有四个Type-C的接口，不得不下单买了个外接的适配器。</p><p>触控板的面积很大，但正如传闻中所说的，触控板非常地好用，不像我之前用的电脑触控板是塑料材质的，当手出汗的时候非常地难用。</p><p>比较可惜的是，control键只在键盘的左侧有，对于使用Emacs来编码的人（指我自己）来说，是比较不方便的。虽然现在已经分别将左右的option设置成了（Windows上的）control，以及将command设置成了（Windows上的）Alt，但无名指在按键的时候还是难免误触。同时，没有独立的home/end/up/down，刚开始还真有点不习惯</p><p>touchbar毕竟是一块没有力反馈的触摸屏，所以每当需要按ESC的时候都忍不住要肉眼确认一下或者按两下。但用touchbar来控制音量则非常方便</p><p>散热有点糟糕。第一天晚上折腾的时候，安装完Visual Studio Code然后VSC自己卡死了，随后机器开始发热，尤其是touchbar上方靠近屏幕铰链的位置很烫——可千万不要轻易烧坏了呀</p><p>电池很给力，不需要每天下班都带着重重的电源适配器回家</p><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>开机后的第一感觉就是界面新颖，虽然并不是第一次亲眼看见macOS了，但作为自己的机器来使用，认真一看确实觉得比Windows要美观，比起之前在虚拟机中使用的Mint也要更优雅统一。触控板非常地好用，尤其是三指上划用于在窗口间切换的功能非常地棒，两指点击表示右键单击的效果也非常地好，既轻盈又方便。字体很好看，就连在Emacs中展示的中文也变得可爱起来</p><p>摆脱了虚拟机，也就不用再把内存用在一起重复的功能上了（比如把内存分给虚拟机的操作系统），搭配上SSD现在开启软件都非常地快。不过大概是因为虚拟机用惯了，有时候总忍不住切换到调度中心，然后找一个看起来比较像虚拟机的应用来点一下，2333</p><p>以前在Mint里面用的搜狗输入法总觉得有什么欠缺，现在可以用上全功能的版本了感觉很爽快，连在Emacs中输入中文也变得畅快起来。更令人惊喜的是，不知道如何折腾，现在我居然可以在多个软件里用上Emacs的键绑定了，目前发现的包括但不限于Firefox的输入框、微信、QQ，以及有道云笔记。</p><p>Mac上的一些软件很有趣，比如Alfred、Timing等等，同时也是我第一次使用zsh+oh-my-zsh，的确是很强大的工具。这两天我也开始编写自己的Workflow了，打算接着学习一下Apple Script更好地帮助自己使用这个系统。</p><p>好了，就酱</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="macbook" scheme="https://liutos.github.io/tags/macbook/"/>
    
  </entry>
  
  <entry>
    <title>cl-mongo用法入门</title>
    <link href="https://liutos.github.io/2017/06/04/cl-mongo%E7%94%A8%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>https://liutos.github.io/2017/06/04/cl-mongo用法入门/</id>
    <published>2017-06-04T13:21:20.000Z</published>
    <updated>2018-12-02T13:29:37.905Z</updated>
    
    <content type="html"><![CDATA[<p>最近用Common Lisp开发一个个人项目，需要记录发出的HTTP请求的参数，包括了目标地址、HTTP body，以及HTTP头部等多种信息。为了可以结构化地存储这些数据（比如HTTP头部是由多个键值对组成的），我选择将它们保存到MongoDB中。Google一番后，我找到了<a href="https://github.com/fons/cl-mongo" target="_blank" rel="noopener">cl-mongo</a>这个库，可以在Common Lisp中读写MongoDB，尝试了一下也确实可以满足自己的需求。为了方便自己查阅，也为了方便有相同需求的人了解如何使用cl-mongo，于是写了这篇文章。</p><p>首先使用<code>CL-MONGO:MONGO</code>函数连接MongoDB的服务器程序（mongod）。因为在我的系统上mongod进程监听的是27017这个端口，并且我希望使用的数据库名为test，因此键入如下代码来连接数据库</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:mongo</span> <span class="symbol">:db</span> <span class="string">"test"</span></span><br><span class="line">                <span class="symbol">:host</span> <span class="string">"127.0.0.1"</span></span><br><span class="line">                <span class="symbol">:port</span> <span class="number">27017</span>)</span><br></pre></td></tr></table></figure><p>连接上了数据库后，首先尝试往其中写入一个文档。假设现在要记录的是发出的HTTP请求的信息，那么一个可以写入的基本信息就是请求的目标地址。假设在命令行的mongo shell中输入的内容如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.http_request.insert(&#123;<span class="attr">uri</span>: <span class="string">'http://example.com'</span>&#125;);</span><br></pre></td></tr></table></figure><p>那么使用cl-mongo提供的<code>DB.INSERT</code>函数达到上述效果的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.insert <span class="string">"http_request"</span></span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"uri"</span> <span class="string">"http://example.com"</span>))</span><br></pre></td></tr></table></figure><p>求值上述代码后返回值为NIL。为了将上述写入的文档重新查询出来，需要使用cl-mongo提供的<code>DB.FIND</code>函数。因为只有一个文档，所以直接查询就可以查看到结果了。在mongo shell中我们可以使用如下代码查询</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.http_request.find();</span><br></pre></td></tr></table></figure><p>使用<code>DB.FIND</code>函数的话编写的代码可能会长得像下面这样</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.find <span class="string">"http_request"</span> <span class="symbol">:all</span>)</span><br></pre></td></tr></table></figure><p>在我的系统上求值了上述代码后在REPL中输出的内容如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">86</span> <span class="number">449</span> <span class="number">0</span> <span class="number">1</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="string">"http_request"</span>)</span><br><span class="line"> (<span class="name">&lt;CL-MONGO</span><span class="symbol">:DOCUMENT&gt;</span> : &#123; </span><br><span class="line">   _id : CL-MONGO:<span class="symbol">:BSON-OID</span> [#(<span class="number">89</span> <span class="number">52</span> <span class="number">26</span> <span class="number">160</span> <span class="number">109</span> <span class="number">156</span> <span class="number">254</span> <span class="number">71</span> <span class="number">184</span> <span class="number">115</span> <span class="number">102</span> <span class="number">30</span>)]</span><br><span class="line">   elements : <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>DB.FIND</code>的返回值不完全是文档组成的数组，而是在这个结果集的数组之外又多了一层列表，并且列表的第一个元素还是一个一看之下不知其所以然的子列表。由于cl-mongo的GitHub上没有提及这个玩意儿的来历，我也没有深入去了解<code>DB.FIND</code>函数的实现代码，因此这个元素就先忽略它吧。如果需要使用<code>DB.FIND</code>查询到的结果，那么开发者需要对<code>DB.FIND</code>的返回值应用一下函数<code>SECOND</code>才行，如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">second</span> (<span class="name">cl-mongo</span><span class="symbol">:db</span>.find <span class="string">"http_request"</span> <span class="symbol">:all</span>))</span><br></pre></td></tr></table></figure><p>返回值的列表中的每一个元素都是<code>CL-MONGO:DOCUMENT</code>这个类的实例对象，如果要直接使用还是稍微有点不方便的，因此我写了一个函数用来将<code>DB.FIND</code>函数查询到的<code>CL-MONGO:DOCUMENT</code>的实例对象都转换为较为熟悉，容易操作的数据类型——association list，函数的定义如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> document-to-alist (<span class="name">doc</span>)</span><br><span class="line">  <span class="string">"Convert a DOC of type CL-MONGO:DOCUMENT to a equivalent, serializable alist."</span></span><br><span class="line">  (<span class="name">check-type</span> doc cl-mongo<span class="symbol">:document</span>)</span><br><span class="line">  (<span class="name">labels</span> ((<span class="name">aux</span> (<span class="name">doc</span>)</span><br><span class="line">             (<span class="name">cond</span> ((<span class="name">typep</span> doc 'cl-mongo<span class="symbol">:document</span>)</span><br><span class="line">                    (<span class="name">let</span> ((<span class="name">keys</span> (<span class="name">cl-mongo</span><span class="symbol">:get-keys</span> doc)))</span><br><span class="line">                      (<span class="name">mapcar</span> #'(lambda (key)</span><br><span class="line">                                  (cons key</span><br><span class="line">                                        (aux (cl-mongo:get-element key doc))))</span><br><span class="line">                              keys)))</span><br><span class="line">                   (<span class="name">t</span> doc))))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">id</span> (<span class="name">cl-mongo</span><span class="symbol">:doc-id</span> doc)))</span><br><span class="line">      (<span class="name">append</span> (<span class="name">aux</span> doc) (<span class="name">list</span> (<span class="name">cons</span> <span class="string">"_id"</span> id))))))</span><br></pre></td></tr></table></figure><p>使用如下代码即可查看方才所写入的文档究竟长什么样子了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">document-to-alist</span> (<span class="name">first</span> (<span class="name">second</span> (<span class="name">cl-mongo</span><span class="symbol">:db</span>.find <span class="string">"http_request"</span> <span class="symbol">:all</span>))))</span><br></pre></td></tr></table></figure><p>如果想要修改数据库中的文档，例如增加一个字段，那么可以使用cl-mongo提供的<code>DB.UPDATE</code>函数，用法如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.update <span class="string">"http_request"</span></span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"uri"</span> <span class="string">"http://example.com"</span>)</span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"$set"</span></span><br><span class="line">                                 (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"method"</span> <span class="string">"GET"</span>)))</span><br></pre></td></tr></table></figure><p>最后如果要删除刚才所写入的这个文档，可以使用cl-mongo的<code>DB.DELETE</code>函数（我很好奇这个函数居然不是叫做DB.REMOVE），用法如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cl-mongo</span><span class="symbol">:db</span>.delete <span class="string">"http_request"</span></span><br><span class="line">                    (<span class="name">cl-mongo</span><span class="symbol">:kv</span> <span class="string">"uri"</span> <span class="string">"http://example.com"</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="mongo" scheme="https://liutos.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>远程请求Squid</title>
    <link href="https://liutos.github.io/2017/05/18/%E8%BF%9C%E7%A8%8B%E8%AF%B7%E6%B1%82Squid/"/>
    <id>https://liutos.github.io/2017/05/18/远程请求Squid/</id>
    <published>2017-05-18T13:18:42.000Z</published>
    <updated>2019-01-09T15:20:35.215Z</updated>
    
    <content type="html"><![CDATA[<p>不久前在办公室抓取某网站S被对方发现，导致对方自动屏蔽了来自办公室网络的所有HTTP请求，连正儿八经地用浏览器打开也不行。为了可以摸索出“改头换面”（改HTTP头部）访问的方法，必须先成功访问至少一次，看看发出的HTTP头部是怎样的才行。恰好想起自己有一台腾讯云服务器，登上去用<code>curl</code>访问网站S，发现是成功的（也就是尚未被屏蔽）。既然如此，干脆在服务器上部署一套Squid作为正向代理，帮助办公网络的请求成功抵达网站S并拿到响应页面。</p><p>用<code>apt-get</code>安装了<code>squid</code>软件包后启动并监听端口8321，在办公网络下将公网地址和8321端口作为代理配置传递给<code>curl</code>的<code>-x</code>选项，访问网站S。不料Squid拒绝了我的请求，返回了如下内容（节选自<code>curl -v</code>命令的输出）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt; HTTP/1.1 403 Forbidden</span><br><span class="line">&lt; Server: squid/3.5.12</span><br><span class="line">&lt; Mime-Version: 1.0</span><br><span class="line">&lt; Date: Wed, 17 May 2017 15:18:08 GMT</span><br><span class="line">&lt; Content-Type: text/html;charset=utf-8</span><br><span class="line">&lt; Content-Length: 3531</span><br><span class="line">&lt; X-Squid-Error: ERR_ACCESS_DENIED 0</span><br><span class="line">&lt; Vary: Accept-Language</span><br><span class="line">&lt; Content-Language: en</span><br><span class="line">&lt; X-Cache: MISS from VM-44-136-ubuntu</span><br><span class="line">&lt; X-Cache-Lookup: NONE from VM-44-136-ubuntu:8321</span><br><span class="line">&lt; Via: 1.1 VM-44-136-ubuntu (squid/3.5.12)</span><br><span class="line">&lt; Connection: keep-alive</span><br></pre></td></tr></table></figure><p>经过一番Google，才知道原来是Squid的配置导致的。在Squid配置文件（/etc/squid/squid.conf）中，默认的acl和http_access指令的设置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">acl SSL_ports port 443</span><br><span class="line">acl Safe_ports port 80          # http</span><br><span class="line">acl Safe_ports port 21          # ftp</span><br><span class="line">acl Safe_ports port 443         # https</span><br><span class="line">acl Safe_ports port 70          # gopher</span><br><span class="line">acl Safe_ports port 210         # wais</span><br><span class="line">acl Safe_ports port 1025-65535  # unregistered ports</span><br><span class="line">acl Safe_ports port 280         # http-mgmt</span><br><span class="line">acl Safe_ports port 488         # gss-http</span><br><span class="line">acl Safe_ports port 591         # filemaker</span><br><span class="line">acl Safe_ports port 777         # multiling http</span><br><span class="line">acl CONNECT method CONNECT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http_access deny !Safe_ports</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line">http_access allow localhost manager</span><br><span class="line">http_access deny manager</span><br><span class="line">http_access allow localhost</span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure><p>由于Squid是按照第一条匹配的http_access指令来决定允许还是拒绝的，因为来自我办公网络的请求实际上命中的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_access deny all</span><br></pre></td></tr></table></figure><p>因此被拒绝是必然的。为了可以接受来自办公网络发起的请求，首先需要新增一行acl指令。通过Squid的日志（/var/log/squid/access.log）可以查看到被拒绝的请求的IP地址是多少，此处假设IP地址为8.7.198.45，那么相应的acl指令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl myclients src 8.7.198.45</span><br></pre></td></tr></table></figure><p>此处的myclients为自定义的名称，顾名思义，它表示“我的客户端”；src是一种acl类型，表示客户端的IP地址；8.7.198.45是src类型下的参数，也就是我所使用的客户端发出的请求的来源IP地址。配置了acl后，还需要配置http_access指令。这个就简单多了，只要允许上面创建的这个acl的访问即可，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_access allow myclients</span><br></pre></td></tr></table></figure><p>之后再重启Squid服务即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service squid restart</span><br></pre></td></tr></table></figure><p>这时候再从办公网络中以腾讯云服务器上的Squid为正向代理发出请求，就不会再被Squid拒绝了。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="教程" scheme="https://liutos.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="tutorial" scheme="https://liutos.github.io/tags/tutorial/"/>
    
      <category term="squid" scheme="https://liutos.github.io/tags/squid/"/>
    
  </entry>
  
  <entry>
    <title>如何使用CL实现snowflake</title>
    <link href="https://liutos.github.io/2017/04/30/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CL%E5%AE%9E%E7%8E%B0snowflake/"/>
    <id>https://liutos.github.io/2017/04/30/如何使用CL实现snowflake/</id>
    <published>2017-04-30T14:59:30.000Z</published>
    <updated>2018-12-02T13:30:33.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR;"></a>TL;DR;</h2><p>这是一篇为了完成写作KPI而写的博客，总结起来就是提供了一种用Common Lisp实现来自于Twitter的雪花算法的实现方案。成品在<a href="https://github.com/Liutos/clitool/blob/master/cl/misc/snowflake.lisp" target="_blank" rel="noopener">这里</a>，本文只是简单地描述一下生成雪花ID的大致思路，详细内容请各位移步代码仓库查看。</p><p>上述代码仓库中的snowflake算法——如果我的实现确实可以称作snowflake算法的话——的思路来自于下列两个地方：</p><ol><li><a href="http://www.lanindex.com/twitter-snowflake，64位自增id算法详解/" target="_blank" rel="noopener">http://www.lanindex.com/twitter-snowflake，64位自增id算法详解/</a></li><li><a href="https://github.com/sony/sonyflake" target="_blank" rel="noopener">https://github.com/sony/sonyflake</a></li></ol><h2 id="如何获取时间戳"><a href="#如何获取时间戳" class="headerlink" title="如何获取时间戳"></a>如何获取时间戳</h2><p>Common Lisp本身提供了一个获取时间戳的函数，也就是<code>get-universal-time</code>，可惜的是，这个函数所返回的并不是通常意义上的<a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Epoch时间戳</a>，而是自己的一套计算时间的方式中的表示时间的整数。为了获得UNIX时间戳，需要借助于第三方库<a href="https://common-lisp.net/project/local-time/manual.html" target="_blank" rel="noopener"><code>local-time</code></a>。为了可以获取到毫秒精度的时间戳，一个可运行的函数如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> now ()</span><br><span class="line">  <span class="string">"Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."</span></span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">now</span> (<span class="name">local-time</span><span class="symbol">:now</span>))</span><br><span class="line">         (<span class="name">seconds</span> (<span class="name">local-time</span><span class="symbol">:timestamp-to-unix</span> now))</span><br><span class="line">         (<span class="name">milliseconds</span> (<span class="name">local-time</span><span class="symbol">:timestamp-millisecond</span> now)))</span><br><span class="line">    (<span class="name">+</span> (<span class="name">*</span> <span class="number">1000</span> seconds) milliseconds)))</span><br></pre></td></tr></table></figure><h2 id="如何获取机器ID"><a href="#如何获取机器ID" class="headerlink" title="如何获取机器ID"></a>如何获取机器ID</h2><p>这里参考了Sony的雪花ID算法中的思路，基于机器的内网IP地址来生成机器ID。当然了，Common Lisp标准中是没有提供获取机器的内网IP地址的方法的，这一点也可以借助于第三方库实现，选用的是<a href="https://common-lisp.net/project/ip-interfaces/" target="_blank" rel="noopener"><code>ip-interfaces</code></a>。通过这个库提供的<code>get-ip-interfaces</code>函数可以获取到机器的所有“接口”，遍历这个接口的列表后即可找出其中的内网IP。一台机器可能会有多个内网IP，我的方法是选用了第一个找到的内网IP地址。当然了，还需要一个将向量转化为数值的函数，并取出转化为数值后的IP地址的低10位，作为机器ID。</p><h2 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h2><p>如果希望生成的ID是保持递增的，那么就需要维护一个可以原子递增的数值计数器。在真实的使用中可以通过Redis的INCR指令来生成这一个ID，但是因为这里的雪花ID算法是作为一个独立的库实现的，不需要依赖于数据库等外部组建，因此这里就直接使用了Common Lisp自带的<code>random</code>函数来生成这个序号了。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
  </entry>
  
</feed>
