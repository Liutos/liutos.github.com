<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liutos.github.io/"/>
  <updated>2019-10-20T06:48:42.127Z</updated>
  <id>https://liutos.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Emacs中搭建笔记查阅系统的尝试</title>
    <link href="https://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
    <id>https://liutos.github.io/2019/10/20/在Emacs中搭建笔记查阅系统的尝试/</id>
    <published>2019-10-20T06:42:33.000Z</published>
    <updated>2019-10-20T06:48:42.127Z</updated>
    
    <content type="html"><![CDATA[<p>给Emacs写插件有种痛并快乐着的感觉。虽然这个发挥创意的过程很有趣，但是Elisp写起来总有种别扭的感觉。一方面，我把它当成是Common Lisp，写的时候没有觉得“这个用法可能会有问题”；另一方面，它又不是普通的写lisp代码，还要一边写一边摸索Emacs中的一些概念。不过总体而言，还是挺好玩的，除了没有一个像模像样的REPL之外。</p><h2 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h2><p>我用Emacs记录了不少的“笔记”。虽说我自己将其称为笔记，但是它们更像是我把遇到的一些问题和解决方法给记录下来，而没有太多自己的感悟。它们的外观倒是高度的一致，见下图</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E7%94%A8org-mode%E8%AE%B0%E7%9A%84%E7%AC%94%E8%AE%B0.png" alt=""></p><p>（第一次尝试给自己的图片打水印，有点好玩）每一个一级条目都是一个问题，并且这个文件中只有一级条目。而条目下的内容则是对标题的问题的回答。其中还有代码块——也就是写着BEGIN_SRC和END_SRC的那部分。用org-mode来记录笔记有几个好处，其中一个便是可以在笔记中插入任何Emacs支持的编程语言代码片段并具备语法高亮。当然了，还有一个巨大的优势，便是org-mode尽管看似花里胡哨，骨子里却是正统的纯文本文件，它可以很方便地在其它工具中处理。</p><p>而我用来处理的其中一个工具便是ElasticSearch。比如说，上图的第一条笔记，在ElasticSearch中存成了下面这样的结构</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E6%9F%A5%E7%9C%8BElasticSearch%E4%B8%AD%E7%9A%84%E7%AC%94%E8%AE%B0.png" alt=""></p><p>本来我是写了一个Alfred的Workflow来查询ElasticSearch的，但是奈何Workflow那种一行行的方式展示org-mode格式的笔记不太友好，因此便打算直接在Emacs中查询并查看笔记内容。</p><h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>为了可以在Emacs中查看笔记内容，我打算借助于Helm的力量。<a href="https://emacs-helm.github.io/helm/" target="_blank" rel="noopener">Helm</a>是Emacs的一个补全的框架，可以用来呈现一系列的候选项，然后选中后触发一些什么动作。我期望的形式，是在Emacs中按下某种快捷键或者输入某个命令行，可以在minibuffer中输入自己要查询的内容，然后Emacs查询ElasticSearch并最终通过Helm来呈现这些查询内容匹配的笔记条目。目前的成果是下面这样子的</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/lt-ask%E7%9A%84%E5%80%99%E9%80%89%E5%88%97%E8%A1%A8.png" alt=""></p><p>具体的做法其实也很简单。首先，要知道Helm是如何被使用的。通过这篇<a href="https://wikemacs.org/wiki/How_to_write_helm_extensions" target="_blank" rel="noopener">文档</a>，初步了解到只需要定一个变量，并通过<code>:sources</code>关键字参数传递给<code>helm</code>这个函数即可。我所定义的传递给<code>helm</code>函数的“source”如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> faq-helm-sources</span><br><span class="line">      `((name . <span class="string">"FAQ at Emacs"</span>)</span><br><span class="line">        (candidates . faq-candidates)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    (let ((url (format <span class="string">"http://localhost:9200/faq/_doc/%s"</span> candidate)))</span><br><span class="line">                      (browse-url url))))))</span><br></pre></td></tr></table></figure><p>其中<code>faq-candidates</code>的作用便是根据minibuffer中的关键字查询ElasticSearch并组织好一个结构返回给<code>helm</code>。需要注意的是，<code>faq-candidates</code>必须是一个无参的函数才行，但输入的数据又偏偏需要从minibuffer中获取。因此，我的做法是约定一个变量<code>faq-query</code>，在调用<code>helm</code>之前首先调用<code>read-from-minibuffer</code>函数读取输入，然后将输入的字符串赋值给<code>faq-query</code>，之后当<code>helm</code>开始使用这个source的时候，<code>faq-candidates</code>函数便不需要参数，而可以直接从<code>faq-query</code>中拿到自己需要的搜索内容向ElasticSearch请求了。当然了，如果有像Common Lisp动态作用域的话，也就不需要定义这么一个全局变量了，对Emacs全局的侵入会更少一点。</p><p>目前能够做到的也仅仅是查询ElasticSearch，并在选中某个条目并按下回车的时候打开浏览器来查看而已，之后应该会继续完善。目前的完整代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 调用ElasticSearch查询笔记</span></span><br><span class="line">(<span class="name">require</span> 'request)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq (<span class="name">query</span>)</span><br><span class="line">  <span class="string">"向ElasticSearch查询QUERY匹配的笔记"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">response</span>))</span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:9200/faq/_search"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">encode-coding-string</span></span><br><span class="line">            (<span class="name">json-encode</span></span><br><span class="line">             (<span class="name">list</span></span><br><span class="line">              (<span class="name">cons</span> <span class="string">"query"</span> (<span class="name">list</span></span><br><span class="line">                             (<span class="name">cons</span> <span class="string">"multi_match"</span> (<span class="name">list</span></span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"fields"</span> (<span class="name">list</span> <span class="string">"answer"</span> <span class="string">"question"</span>))</span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"query"</span> query)))))))</span><br><span class="line">            'utf-8)</span><br><span class="line">     <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">     <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">setq</span> data (<span class="name">decode-coding-string</span> data 'utf-8))</span><br><span class="line">                 (<span class="name">setq</span> response (<span class="name">json-read-from-string</span> data))))</span><br><span class="line">     <span class="symbol">:sync</span> <span class="literal">t</span>)</span><br><span class="line">    response))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> make-faq-candidates (<span class="name">response</span>)</span><br><span class="line">  <span class="string">"将查询ElasticSearch的结果构造为helm可以识别的candidates格式"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">hits</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits response))))))</span><br><span class="line">    (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">doc</span>)</span><br><span class="line">              (<span class="name">let</span> ((<span class="name">_source</span> (<span class="name">cdr</span> (<span class="name">assoc</span> '_source doc))))</span><br><span class="line">                (<span class="name">cons</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'question _source))</span><br><span class="line">                      (<span class="name">cdr</span> (<span class="name">assoc</span> '_id doc)))))</span><br><span class="line">            hits)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> faq-query <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq-candidates ()</span><br><span class="line">  (<span class="name">make-faq-candidates</span> (<span class="name">faq</span> faq-query)))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> faq-helm-sources</span><br><span class="line">      `((name . <span class="string">"FAQ at Emacs"</span>)</span><br><span class="line">        (candidates . faq-candidates)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    (let ((url (format <span class="string">"http://localhost:9200/faq/_doc/%s"</span> candidate)))</span><br><span class="line">                      (browse-url url))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-ask ()</span><br><span class="line">  <span class="string">"交互式地从minibuffer中读取笔记的关键词并展示选项"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">content</span> (<span class="name">read-from-minibuffer</span> <span class="string">"笔记关键词："</span>)))</span><br><span class="line">    (<span class="name">setq</span> faq-query content)</span><br><span class="line">    (<span class="name">helm</span> <span class="symbol">:sources</span> '(faq-helm-sources))))</span><br></pre></td></tr></table></figure><p>有不少值得吐槽的地方，不过都先按下不表吧，各位读者有兴趣的话可以留言交流一下XD</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="elasticsearch" scheme="https://liutos.github.io/tags/elasticsearch/"/>
    
      <category term="note-taking" scheme="https://liutos.github.io/tags/note-taking/"/>
    
      <category term="笔记" scheme="https://liutos.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何编译defun</title>
    <link href="https://liutos.github.io/2019/10/11/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91defun/"/>
    <id>https://liutos.github.io/2019/10/11/如何编译defun/</id>
    <published>2019-10-11T14:32:54.000Z</published>
    <updated>2019-10-11T14:34:47.098Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解如何编译<code>defun</code>。在Common Lisp中，<code>defun</code>用于定义函数。例如，下列的代码定义了函数<code>foo</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foo (<span class="name">a</span>)</span><br><span class="line">  <span class="string">"一个名为FOO的函数"</span></span><br><span class="line">  (<span class="name">declare</span> (<span class="name">ignorable</span> a))</span><br><span class="line">  (<span class="number">1</span>+ <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>在<code>defun</code>的<a href="http://clhs.lisp.se/Body/m_defun.htm" target="_blank" rel="noopener">语法</a>中，第一行的字符串是这个函数的文档，可以用<code>documentation</code>函数获取；第二行是declaration。（不管是documentation还是declaration，也许要等到自举的那一天才能够支持了）目前只打算支持如下这般朴素的<code>defun</code>用法：</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> a (<span class="name">x</span>)</span><br><span class="line">  (<span class="name">+</span> x <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>可以想象，编译上面这段代码后，首先应当有一个函数名的label，比如就叫做<code>A</code>。紧接着这个label的是函数体的代码，按照我这赶鸭子上架的做法看回来的说法，起码要有参数的处理——比如从寄存器中复制到内存中，还要有callee-saved的寄存器的保护，函数体的处理逻辑代码，以及收拾残局并返回到调用者的代码等等。</p><p>慢着，要将寄存器中的参数值复制到内存中，是需要在栈上开辟空间的。要这么做的话，就得先计算出一共需要多少字节的存储空间，还要计算出每一个参数在栈上的偏移。并且，为了可以在函数体内正确地使用参数的偏移，还需要提供一个环境（类似于编译原理的教程中常常出现的符号表）以便在递归地编译函数体的过程中查询才行——这一系列的东西对<code>jjcc2</code>的改动比较大。</p><p>所以，我用了一个简单但局限性较大的方法：将每一个参数都视为一个同名的全局变量。这样寄存器中的参数值就不需要复制到栈上，而是直接复制到参数名所代表的内存地址中。</p><p>如此，要编译<code>defun</code>就很简单了。拓展后的<code>jjcc2</code>函数的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(get-operand expr <span class="number">0</span>))))</span><br><span class="line">                 globals))</span><br><span class="line">        <span class="comment">;; ((eq (first expr) '_exit)</span></span><br><span class="line">        <span class="comment">;;  ;; 因为知道_exit只需要一个参数，所以将它的第一个操作数塞到EDI寄存器里面就可以了</span></span><br><span class="line">        <span class="comment">;;  ;; <span class="doctag">TODO:</span> 更好的写法，应该是有一个单独的函数来处理这种参数传递的事情（以符合calling convention的方式）</span></span><br><span class="line">        <span class="comment">;;  `((movl ,(get-operand expr 0) %edi)</span></span><br><span class="line">        <span class="comment">;;    (movl #x2000001 %eax)</span></span><br><span class="line">        <span class="comment">;;    (syscall)))</span></span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '&gt;)</span><br><span class="line">         <span class="comment">;; 为了可以把比较之后的结果放入到EAX寄存器中，以我目前不完整的汇编语言知识，可以想到的方法如下</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-greater-than</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           <span class="comment">;; 根据这篇文章（https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions）中的说法，大于号左边的数字应该放在CMP指令的第二个操作数中，右边的放在第一个操作数中</span></span><br><span class="line">           `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">             (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">             (cmpl %ebx %eax)</span><br><span class="line">             (jg ,label-greater-than)</span><br><span class="line">             (movl $<span class="number">0</span> %eax)</span><br><span class="line">             (jmp ,label-end)</span><br><span class="line">             ,label-greater-than</span><br><span class="line">             (movl $<span class="number">1</span> %eax)</span><br><span class="line">             ,label-end)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'if)</span><br><span class="line">         <span class="comment">;; 假定if语句的测试表达式的结果也是放在%eax寄存器中的，所以只需要拿%eax寄存器中的值跟0做比较即可（类似于C语言）</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-else</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">second</span> expr) globals)</span><br><span class="line">                   `((cmpl $<span class="number">0</span> %eax)</span><br><span class="line">                     (je ,label-else))</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                   `((jmp ,label-end)</span><br><span class="line">                     ,label-else)</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">fourth</span> expr) globals)</span><br><span class="line">                   `(,label-end))))</span><br><span class="line">        ((<span class="name">member</span> (<span class="name">first</span> expr) '(_exit exit))</span><br><span class="line">         <span class="comment">;; 暂时以硬编码的方式识别一个函数是否来自于C语言的标准库</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           ;; 据这篇回答（https<span class="symbol">://stackoverflow</span>.com/questions/12678230/how-to-print-argv0-in-nasm）所说，在macOS上调用C语言函数，需要将栈对齐到<span class="number">16</span>位</span><br><span class="line">           ;; 假装要对齐的是栈顶地址。因为栈顶地址是往低地址增长的，所以只需要将地址的低<span class="number">16</span>位抹掉就可以了</span><br><span class="line">           (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">           (call :|_exit|)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'return)</span><br><span class="line">         <span class="comment">;; 由于经过inside-out的处理之后，return的参数就是一个“原子”了，因此不再需要调用jjcc2来处理一遍</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (ret)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'defun)</span><br><span class="line">         <span class="comment">;; defun的编译过程是：</span></span><br><span class="line">         <span class="comment">;; 1. 根据函数参数生成相应的MOV指令</span></span><br><span class="line">         <span class="comment">;; 2. 编译body的部分，生成一系列的汇编代码的S表达式</span></span><br><span class="line">         <span class="comment">;; 3. 以defun的函数名和刚生成的S表达式组成cons</span></span><br><span class="line">         <span class="comment">;; 4. 添加到*udfs*中</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">init-asm</span> '())</span><br><span class="line">               (<span class="name">params</span> (<span class="name">caddr</span> expr))</span><br><span class="line">               (<span class="name">registers</span> '(%rdi %rsi %rdx %rcx %r8 %r9)))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">param</span> params)</span><br><span class="line">             (<span class="name">setf</span> (<span class="name">gethash</span> param globals) <span class="number">0</span>))</span><br><span class="line">           <span class="comment">;; 生成一系列MOV指令，将寄存器中的参数值放入到特定的内存位置中</span></span><br><span class="line">           (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">length</span> params))</span><br><span class="line">             (<span class="name">when</span> (<span class="name">nth</span> i registers)</span><br><span class="line">               (<span class="name">push</span> `(movq ,(nth i registers)</span><br><span class="line">                            ,(format <span class="literal">nil</span> <span class="string">"~A(%RIP)"</span> (nth i params)))</span><br><span class="line">                     init-asm)))</span><br><span class="line"></span><br><span class="line">           (<span class="name">let</span> ((<span class="name">asm</span> (<span class="name">jjcc2</span> (<span class="name">cons</span> 'progn (<span class="name">cdddr</span> expr)) globals)))</span><br><span class="line">             (<span class="name">push</span> (<span class="name">cons</span> (<span class="name">cadr</span> expr)</span><br><span class="line">                         (<span class="name">append</span> init-asm asm '((ret))))</span><br><span class="line">                   *udfs*)</span><br><span class="line">             <span class="literal">nil</span>)))</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         <span class="comment">;; 按照这里（https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html）所给的函数调用约定来传递参数</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">instructions</span> '())</span><br><span class="line">               (<span class="name">registers</span> '(%rdi %rsi %rdx %rcx %r8 %r9)))</span><br><span class="line">           (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">length</span> (<span class="name">rest</span> expr)))</span><br><span class="line">             (<span class="name">if</span> (<span class="name">nth</span> i registers)</span><br><span class="line">                 (<span class="name">push</span> `(movq ,(get-operand expr i) ,(nth i registers)) instructions)</span><br><span class="line">                 (<span class="name">push</span> `(pushq ,(get-operand expr i)) instructions)))</span><br><span class="line">           <span class="comment">;; 经过一番尝试后，我发现必须在完成函数调用后恢复RSP寄存器才不会导致段错误</span></span><br><span class="line">           `(,@(nreverse instructions)</span><br><span class="line">             (pushq %rsp)</span><br><span class="line">             (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">             (call ,(first expr))</span><br><span class="line">             (popq %rsp))))))</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用了一个叫做<code>*udfs*</code>的变量。它在我的<code>.lisp</code>文件中的定义如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defparameter</span> *udfs*</span><br><span class="line">  (<span class="name">list</span> (<span class="name">cons</span> '|lt1|</span><br><span class="line">              '((movl <span class="number">1</span> %eax)</span><br><span class="line">                (ret)))))</span><br></pre></td></tr></table></figure><p>实际上它就是一个很简单的、函数名到函数体代码的alist而已，在生成汇编代码字符串的时候，将其一股脑地写入到流中即可。为此，<code>stringify</code>函数也做了一番修改，拆分为了如下的两个函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> stringify-asm (<span class="name">asm</span>)</span><br><span class="line">  <span class="string">"根据汇编代码ASM生成相应的汇编语言字符串"</span></span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">ins</span> asm)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">keywordp</span> ins)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A:~%"</span> ins))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">3</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A, ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">third</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">2</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">1</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A~%"</span> (<span class="name">first</span> ins))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> stringify (<span class="name">asm</span> globals)</span><br><span class="line">  <span class="string">"根据jjcc2产生的S表达式生成汇编代码字符串"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  <span class="comment">;; 输出globals中的所有变量</span></span><br><span class="line">  <span class="comment">;; <span class="doctag">FIXME:</span> 暂时只支持输出数字</span></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .data~%"</span>)</span><br><span class="line">  (<span class="name">maphash</span> (<span class="name">lambda</span> (<span class="name">k</span> v)</span><br><span class="line">             (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A: .long ~D~%"</span> k v))</span><br><span class="line">           globals)</span><br><span class="line"></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .section __TEXT,__text,regular,pure_instructions~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .globl _main~%"</span>)</span><br><span class="line">  <span class="comment">;; 输出用户自定义的函数</span></span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">e</span> *udfs*)</span><br><span class="line">    (<span class="name">destructuring-bind</span> (<span class="name">label</span> . asm) e</span><br><span class="line">      (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A:~%"</span> label)</span><br><span class="line">      (<span class="name">stringify-asm</span> asm)))</span><br><span class="line"></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"_main:~%"</span>)</span><br><span class="line">  (<span class="name">stringify-asm</span> asm))</span><br></pre></td></tr></table></figure><p>现在，可以继续用以前的<code>fb</code>函数来编译了，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setf</span> *udfs* <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">fb</span> '(progn (defun a (x) (+ x <span class="number">1</span>)) (_exit (a <span class="number">2</span>))))</span><br></pre></td></tr></table></figure><p>生成的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">X: .long 0</span><br><span class="line">G606: .long 0</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">A:</span><br><span class="line">        MOVQ %RDI, X(%RIP)</span><br><span class="line">        MOVL X(%RIP), %EAX</span><br><span class="line">        MOVL $1, %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        RET</span><br><span class="line">_main:</span><br><span class="line">        MOVQ $2, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL A</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVL %EAX, G606(%RIP)</span><br><span class="line">        MOVL G606(%RIP), %EDI</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _exit</span><br></pre></td></tr></table></figure><p>编译运行即可得到返回码为3。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解如何编译&lt;code&gt;defun&lt;/code&gt;。在Common Lisp中，&lt;code&gt;defun&lt;/code&gt;用于定义函数。例如，下列的代码定义了函数&lt;code&gt;foo&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;defun&lt;/span&gt; foo (&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;一个名为FOO的函数&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;declare&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;ignorable&lt;/span&gt; a))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;defun&lt;/code&gt;的&lt;a href=&quot;http://clhs.lisp.se/Body/m_defun.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;语法&lt;/a&gt;中，第一行的字符串是这个函数的文档，可以用&lt;code&gt;documentation&lt;/code&gt;函数获取；第二行是declaration。（不管是documentation还是declaration，也许要等到自举的那一天才能够支持了）目前只打算支持如下这般朴素的&lt;code&gt;defun&lt;/code&gt;用法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>编译return语句</title>
    <link href="https://liutos.github.io/2019/09/18/%E7%BC%96%E8%AF%91return%E8%AF%AD%E5%8F%A5/"/>
    <id>https://liutos.github.io/2019/09/18/编译return语句/</id>
    <published>2019-09-18T14:01:33.000Z</published>
    <updated>2019-09-18T14:05:37.137Z</updated>
    
    <content type="html"><![CDATA[<p>Common Lisp中有一个叫做<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_return.htm" target="_blank" rel="noopener"><code>return</code></a>的宏，它的作用和平常在C、Java，或者Node.js里面见到的<code>return</code>关键字完全不一样。Common Lisp中的<code>return</code>用于从一个块（<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_block.htm" target="_blank" rel="noopener"><code>block</code></a>）中返的，而不是从一个函数中返回。用<code>return</code>可以写出下面这样的代码，符号<code>YOU-WILL-NOT-SEE-ME</code>永远不会被打印</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foo ()</span><br><span class="line">  (<span class="name">block</span> <span class="literal">nil</span></span><br><span class="line">    (<span class="name">return</span> <span class="number">123</span>)</span><br><span class="line">    (<span class="name">print</span> 'you-will-not-see-me)))</span><br></pre></td></tr></table></figure><p>求值<code>return</code>，就将123作为<code>block</code>的返回值从中返回了，后面的<code>print</code>并没有机会执行——在SBCL中编译上面这段<code>defun</code>的时候，编译器甚至已经给出了提醒</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/SBCL%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%99%E5%87%BA%E7%9A%84note.png" alt=""></p><p><code>return</code>是一个宏，它可以展开为一个<code>return-from</code>，并带有一个名为<code>NIL</code>的块名。用<code>return-from</code>可以直接从函数<code>foo</code>中返回而不需要多一层<code>block</code>，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> foo2 ()</span><br><span class="line">  (<span class="name">return-from</span> foo2 <span class="number">123</span>)</span><br><span class="line">  (<span class="name">print</span> 'you-will-not-see-me))</span><br></pre></td></tr></table></figure><p>除了要多写一个函数的名称之外，<code>return-from</code>跟C、Java，或者Node.js中的<code>return</code>语句是差不多的——没错，只是差不多而已。实际上，<code>return-from</code>也是从一个<code>block</code>中返回的，上面的代码之所以有效，是因为<code>defun</code>会隐式地定义一个跟函数同名的块。</p><p>这一次要在<code>jjcc2</code>中支持的<code>return</code>，比起Common Lisp，更接近于C语言中的<code>return</code>语句——是用来直接从函数调用中返回的。</p><p>编译<code>return</code>其实很简单。在目前的<code>inside-out</code>中，<code>return</code>会落入到最后的分支，因此它的唯一一个参数会被翻出来先编译，并且其结果是放入到<code>%EAX</code>寄存器中的。所以，编译<code>return</code>只需要生成一道简单的<code>RET</code>指令就足够了。修改后的<code>jjcc2</code>如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(get-operand expr <span class="number">0</span>))))</span><br><span class="line">                 globals))</span><br><span class="line">        <span class="comment">;; ((eq (first expr) '_exit)</span></span><br><span class="line">        <span class="comment">;;  ;; 因为知道_exit只需要一个参数，所以将它的第一个操作数塞到EDI寄存器里面就可以了</span></span><br><span class="line">        <span class="comment">;;  ;; <span class="doctag">TODO:</span> 更好的写法，应该是有一个单独的函数来处理这种参数传递的事情（以符合calling convention的方式）</span></span><br><span class="line">        <span class="comment">;;  `((movl ,(get-operand expr 0) %edi)</span></span><br><span class="line">        <span class="comment">;;    (movl #x2000001 %eax)</span></span><br><span class="line">        <span class="comment">;;    (syscall)))</span></span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '&gt;)</span><br><span class="line">         <span class="comment">;; 为了可以把比较之后的结果放入到EAX寄存器中，以我目前不完整的汇编语言知识，可以想到的方法如下</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-greater-than</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           <span class="comment">;; 根据这篇文章（https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions）中的说法，大于号左边的数字应该放在CMP指令的第二个操作数中，右边的放在第一个操作数中</span></span><br><span class="line">           `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">             (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">             (cmpl %ebx %eax)</span><br><span class="line">             (jg ,label-greater-than)</span><br><span class="line">             (movl $<span class="number">0</span> %eax)</span><br><span class="line">             (jmp ,label-end)</span><br><span class="line">             ,label-greater-than</span><br><span class="line">             (movl $<span class="number">1</span> %eax)</span><br><span class="line">             ,label-end)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'if)</span><br><span class="line">         <span class="comment">;; 假定if语句的测试表达式的结果也是放在%eax寄存器中的，所以只需要拿%eax寄存器中的值跟0做比较即可（类似于C语言）</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-else</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">second</span> expr) globals)</span><br><span class="line">                   `((cmpl $<span class="number">0</span> %eax)</span><br><span class="line">                     (je ,label-else))</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                   `((jmp ,label-end)</span><br><span class="line">                     ,label-else)</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">fourth</span> expr) globals)</span><br><span class="line">                   `(,label-end))))</span><br><span class="line">        ((<span class="name">member</span> (<span class="name">first</span> expr) '(_exit exit))</span><br><span class="line">         <span class="comment">;; 暂时以硬编码的方式识别一个函数是否来自于C语言的标准库</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           ;; 据这篇回答（https<span class="symbol">://stackoverflow</span>.com/questions/12678230/how-to-print-argv0-in-nasm）所说，在macOS上调用C语言函数，需要将栈对齐到<span class="number">16</span>位</span><br><span class="line">           ;; 假装要对齐的是栈顶地址。因为栈顶地址是往低地址增长的，所以只需要将地址的低<span class="number">16</span>位抹掉就可以了</span><br><span class="line">           (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">           (call :|_exit|)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'return)</span><br><span class="line">         <span class="comment">;; 由于经过inside-out的处理之后，return的参数就是一个“原子”了，因此不再需要调用jjcc2来处理一遍</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (ret)))</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         <span class="comment">;; 按照这里（https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html）所给的函数调用约定来传递参数</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">instructions</span> '())</span><br><span class="line">               (<span class="name">registers</span> '(%rdi %rsi %rdx %rcx %r8 %r9)))</span><br><span class="line">           (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">length</span> (<span class="name">rest</span> expr)))</span><br><span class="line">             (<span class="name">if</span> (<span class="name">nth</span> i registers)</span><br><span class="line">                 (<span class="name">push</span> `(movq ,(get-operand expr i) ,(nth i registers)) instructions)</span><br><span class="line">                 (<span class="name">push</span> `(pushq ,(get-operand expr i)) instructions)))</span><br><span class="line">           <span class="comment">;; 经过一番尝试后，我发现必须在完成函数调用后恢复RSP寄存器才不会导致段错误</span></span><br><span class="line">           `(,@(nreverse instructions)</span><br><span class="line">             (pushq %rsp)</span><br><span class="line">             (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">             (call ,(first expr))</span><br><span class="line">             (popq %rsp))))))</span><br></pre></td></tr></table></figure><p>现在，就不需要总是依靠<code>exit</code>函数来退出了。下列的代码可以使用<code>RET</code>指令从<code>_main</code>函数中返回</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fb</span> '(return (+ <span class="number">1</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>生成的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">G565: .long 0</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EAX</span><br><span class="line">        MOVL $2, %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        MOVL %EAX, G565(%RIP)</span><br><span class="line">        MOVL G565(%RIP), %EAX</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Common Lisp中有一个叫做&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/m_return.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt;的宏，它的作用和平常在C、Java，或者Node.js里面见到的&lt;code&gt;return&lt;/code&gt;关键字完全不一样。Common Lisp中的&lt;code&gt;return&lt;/code&gt;用于从一个块（&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/s_block.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt;）中返的，而不是从一个函数中返回。用&lt;code&gt;return&lt;/code&gt;可以写出下面这样的代码，符号&lt;code&gt;YOU-WILL-NOT-SEE-ME&lt;/code&gt;永远不会被打印&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;defun&lt;/span&gt; foo ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;print&lt;/span&gt; &#39;you-will-not-see-me)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;求值&lt;code&gt;return&lt;/code&gt;，就将123作为&lt;code&gt;block&lt;/code&gt;的返回值从中返回了，后面的&lt;code&gt;print&lt;/code&gt;并没有机会执行——在SBCL中编译上面这段&lt;code&gt;defun&lt;/code&gt;的时候，编译器甚至已经给出了提醒&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>输出HELLO WORLD——如何编译通用的函数调用表达式</title>
    <link href="https://liutos.github.io/2019/08/15/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E9%80%9A%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://liutos.github.io/2019/08/15/如何编译通用的函数调用表达式/</id>
    <published>2019-08-15T14:15:57.000Z</published>
    <updated>2019-08-15T14:23:29.883Z</updated>
    
    <content type="html"><![CDATA[<p>这篇的东西比较多。</p><p>首先要处理一下<code>inside-out/aux</code>和<code>inside-out</code>这两个函数。之前的<code>inside-out/aux</code>其实一直不支持对<code>progn</code>的处理，需要先补充；而<code>inside-out</code>则可以优化一下，避免在只有一个表达式的情况下，也用<code>progn</code>将其包裹起来。修改后的<code>inside-out/aux</code>和<code>inside-out</code>分别如下</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> inside-out/aux (<span class="name">expr</span> result)</span><br><span class="line">  <span class="string">"将嵌套的表达式EXPR由内而外地翻出来"</span></span><br><span class="line">  (<span class="name">check-type</span> expr list)</span><br><span class="line">  <span class="comment">;; 出于简单起见，暂时只处理加法运算</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">member</span> (<span class="name">first</span> expr) '(+ - * / _exit &gt; exit))</span><br><span class="line">         (let ((operands '()))</span><br><span class="line">           ;; 对参数列表中的所有表达式都递归地进行【外翻】处理</span><br><span class="line">           (dolist (arg (rest expr))</span><br><span class="line">             (if (listp arg)</span><br><span class="line">                 (let ((var (gensym)))</span><br><span class="line">                   (setf result (inside-out/aux arg result))</span><br><span class="line">                   (let ((val (pop result)))</span><br><span class="line">                     (push `(setq ,var ,val) result)</span><br><span class="line">                     (push var operands)))</span><br><span class="line">                 (push arg operands)))</span><br><span class="line">           (push (cons (first expr) (nreverse operands)) result)</span><br><span class="line">           result))</span><br><span class="line">        ((eq (first expr) 'if)</span><br><span class="line">         (push `(if ,(inside-out (second expr))</span><br><span class="line">                    ,(inside-out (third expr))</span><br><span class="line">                    ,(inside-out (fourth expr)))</span><br><span class="line">               result)</span><br><span class="line">         result)</span><br><span class="line">        ((eq (first expr) 'progn)</span><br><span class="line">         (dolist (e (rest expr))</span><br><span class="line">           (push (inside-out e) result))</span><br><span class="line">         result)</span><br><span class="line">        (t</span><br><span class="line">         (push expr result)</span><br><span class="line">         result)))</span><br><span class="line"></span><br><span class="line">(defun inside-out (expr)</span><br><span class="line">  (let ((forms (nreverse (inside-out/aux expr '()))))</span><br><span class="line">    (if (&gt; (length forms) 1)</span><br><span class="line">        (cons 'progn forms)</span><br><span class="line">        (car forms))))</span><br></pre></td></tr></table></figure><p>实际上可以更进一步：<code>inside-out/aux</code>和<code>inside-out</code>大可以合并到一起，结果如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> inside-out (<span class="name">expr</span>)</span><br><span class="line">  <span class="string">"将嵌套的表达式EXPR由内而外地翻出来"</span></span><br><span class="line">  (<span class="name">check-type</span> expr list)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) 'if)</span><br><span class="line">         `(if ,(inside-out (second expr))</span><br><span class="line">              ,(inside-out (third expr))</span><br><span class="line">              ,(inside-out (fourth expr))))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">cons</span> 'progn</span><br><span class="line">               (<span class="name">mapcar</span> #'inside-out (<span class="name">rest</span> expr))))</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">assignments</span> '())</span><br><span class="line">               (<span class="name">operands</span> '()))</span><br><span class="line">           <span class="comment">;; 对参数列表中的所有表达式都递归地进行【外翻】处理</span></span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">arg</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">if</span> (<span class="name">listp</span> arg)</span><br><span class="line">                 (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">inside-out</span> arg))</span><br><span class="line">                       (<span class="name">var</span> (<span class="name">gensym</span>)))</span><br><span class="line">                   (<span class="name">push</span> `(setq ,var ,val) assignments)</span><br><span class="line">                   (<span class="name">push</span> var operands))</span><br><span class="line">                 (<span class="name">push</span> arg operands)))</span><br><span class="line">           (<span class="name">if</span> (<span class="name">null</span> assignments)</span><br><span class="line">               expr</span><br><span class="line">               `(progn</span><br><span class="line">                  ,@(nreverse assignments)</span><br><span class="line">                  (,(first expr) ,@(nreverse operands))))))))</span><br></pre></td></tr></table></figure><p>好了，接下来才是本文的重点：如何编译所有的函数调用表达式。</p><p>尽管我在上面夸下海口，说要编译“所有”的函数调用表达式，但事实上，现在我还做不到——我只能把所有的函数调用表达式，都映射到对C标准库中的函数的调用。因此，如果想要调用C标准库中的<code>putchar</code>函数，那么必须写下如下的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">|_putchar|</span> #.(<span class="name">char-code</span> #\A))</span><br></pre></td></tr></table></figure><p>这里用了双竖线的语法来确保这个符号的<code>symbol-name</code>是全小写的<code>putchar</code>，开始的下划线是因为在macOS中，调用C函数的时候必须要加上这个前缀的下划线。<code>#.</code>是个Common Lisp中的<code>reader macro</code>，可以让后面的表达式在读取期被求值，这样我就不需要手写字母A的code-point啦——好吧，是在炫技。</p><p>要编译这种函数调用表达式，只需要模仿一下此前对<code>_exit</code>的处理就可以啦。首先，是求值函数调用表达式中的各个参数，然后将它们放入恰当的位置中——有的要放入寄存器中，有的要压栈。作为一个野路子的编译器爱好者，我当然是没有正儿八经地看过牙膏厂或者按摩店出品的ABI手册的，我看的是这一份资料：<a href="https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html" target="_blank" rel="noopener">https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html</a></p><p>所以我了解到的是：</p><ul><li>前六个参数，分别要从左到右地依次放入<code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code>，以及<code>R9</code>这些寄存器中的；</li><li>剩下的参数，通通压栈</li></ul><p>然后由于macOS的任性要求，在调用前还需要将<code>RSP</code>寄存器对齐到16字节的内存地址。我在这里折腾了很久，最后才发现，原来我要在函数调用结束之后，把修改过的<code>RSP</code>寄存器恢复原状才行_(:з」∠)_</p><p>所以，这一部分的代码是这样子的（精简了一下）</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> (<span class="name">t</span> <span class="comment">;; 这里省却了很多其它情况下的代码，欢迎读者自行脑补</span></span><br><span class="line">         <span class="comment">;; 按照这里（https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html）所给的函数调用约定来传递参数</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">instructions</span> '())</span><br><span class="line">               (<span class="name">registers</span> '(%rdi %rsi %rdx %rcx %r8 %r9)))</span><br><span class="line">           (<span class="name">dotimes</span> (<span class="name">i</span> (<span class="name">length</span> (<span class="name">rest</span> expr)))</span><br><span class="line">             (<span class="name">if</span> (<span class="name">nth</span> i registers)</span><br><span class="line">                 (<span class="name">push</span> `(movq ,(get-operand expr i) ,(nth i registers)) instructions)</span><br><span class="line">                 (<span class="name">push</span> `(pushq ,(get-operand expr i)) instructions)))</span><br><span class="line">           <span class="comment">;; 经过一番尝试后，我发现必须在完成函数调用后恢复RSP寄存器才不会导致段错误</span></span><br><span class="line">           `(,@(nreverse instructions)</span><br><span class="line">             (pushq %rsp)</span><br><span class="line">             (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">             (call ,(first expr))</span><br><span class="line">             (popq %rsp))))))</span><br></pre></td></tr></table></figure><p>先用<code>pushq</code>把<code>RSP</code>保存起来，待<code>call</code>指令结束返回之后，再<code>popq</code>出来恢复它XD</p><p>到这里为止，就可以来写经典的Hello World了，代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fb</span> `(progn ,@(mapcar #'(lambda (c) `(|_putchar| ,(char-code c))) (coerce <span class="string">"Hello, world!"</span> 'list)) (_exit <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><p>生成的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVQ $72, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $101, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $108, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $108, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $111, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $44, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $32, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $119, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $111, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $114, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $108, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $100, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVQ $33, %RDI</span><br><span class="line">        PUSHQ %RSP</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _putchar</span><br><span class="line">        POPQ %RSP</span><br><span class="line">        MOVL $0, %EDI</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _exit</span><br></pre></td></tr></table></figure><p>使用GAS编译上述代码，并借助gcc链接后，运行它就可以看到<code>Hello, world!</code>了</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇的东西比较多。&lt;/p&gt;
&lt;p&gt;首先要处理一下&lt;code&gt;inside-out/aux&lt;/code&gt;和&lt;code&gt;inside-out&lt;/code&gt;这两个函数。之前的&lt;code&gt;inside-out/aux&lt;/code&gt;其实一直不支持对&lt;code&gt;progn&lt;/code&gt;的处理，需要先补充；而&lt;code&gt;inside-out&lt;/code&gt;则可以优化一下，避免在只有一个表达式的情况下，也用&lt;code&gt;progn&lt;/code&gt;将其包裹起来。修改后的&lt;code&gt;inside-out/aux&lt;/code&gt;和&lt;code&gt;inside-out&lt;/code&gt;分别如下&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>一个有用的org-agenda-custom-commands的例子</title>
    <link href="https://liutos.github.io/2019/08/11/%E4%B8%80%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84org-agenda-custom-commands%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>https://liutos.github.io/2019/08/11/一个有用的org-agenda-custom-commands的例子/</id>
    <published>2019-08-11T14:37:28.000Z</published>
    <updated>2019-08-11T14:38:59.036Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写了，文章的开头，照例还是要吹吹水的。</p><p>自从更新了基于org-mode的待办事项的管理模式后，感觉整个人都日益神清气爽起来。究其原因，大概是因为现在处理inbox.org和安排第二天的行程的时候，有一个相对可行的操作方法可以参考了，所以每次处理这两件事情的时候，也就没有那么纠结了。同时，还因为采取了一种尽量goal-oriented的TODO管理方法，最大程度上杜绝了一些不必要的TODO被收集起来，从而也减轻了内心的焦虑感。</p><p>言归正传，这篇文章是要讲一个我自定义的org-mode的Agenda视图的command的。这条命令是下面这样子的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> org-agenda-custom-commands</span><br><span class="line">      '((<span class="string">"f"</span> <span class="string">"查看TODO条目（按创建时间排序）"</span> todo <span class="string">"TODO"</span></span><br><span class="line">         ((org-agenda-sorting-strategy '(priority-down time-up))))))</span><br></pre></td></tr></table></figure><p>俗话说的好，要检验自己是不是懂得某个东西，只要看看自己能不能把这个东西给别人讲清楚就可以了。如果讲清楚了，没有哪里需要emmmm的地方，那么就可以认为这个东西基本上自己是真的懂得了。</p><p>那么<code>org-agenda-custom-commands</code>是干嘛用的呢。官方文档的链接在这里：<a href="https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html" target="_blank" rel="noopener">https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html</a> ——哎哟喂，其实如果你们身处在Emacs之中来看这篇文章的话，只要按下<code>C-h v</code>，然后在minibuffer中输入<code>org-agenda-custom-commands</code>的话，也就可以看到关于这个变量的说明了啦。不过上面这个文档的好处是它有附赠一些例子。</p><p>总而言之，<code>org-agenda-custom-commands</code>是一个变量，通过给这个变量赋值，可以在<code>org-mode</code>的Agenda视图中，添加一些自定义的功能及对应的快捷键。例如，如果在Emacs中求值我上面所给的Elisp代码，然后按下<code>C-c a</code>，便会看到类似于下面这样的提示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Emacs%E7%9A%84org-mode%E7%9A%84Agenda%E8%A7%86%E5%9B%BE%E6%8F%90%E9%86%92%E4%BF%A1%E6%81%AF.png" alt=""></p><p>这时候，如果按下<code>f</code>键，Emacs就会按照上面代码中描述的那样找出所有关键字为<code>TODO</code>的条目，然后按照【先优先级降序，然后时间戳升序】的方式来排列它们。在我的电脑上的效果如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Emacs%E7%9A%84org-mode%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E7%9A%84%E6%95%88%E6%9E%9C.png" alt=""></p><p>可以看到，首先出现的条目是标注为最高的A优先级的两条，然后是在heading内容的开头含有时间戳的条目。</p><p>对我来说，这样的一个好处是可以将未处理过的TODO按照时间顺序列出来，从而避免了所有的TODO条目先是按照文件的名称集中起来，然后又按照它们在文件中的顺序从上往下地排列起来。毕竟文件内的TODO都是聚合在各自不同的更高级的heading之下的，它们之间的上下关系体现不出什么东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="gtd" scheme="https://liutos.github.io/tags/gtd/"/>
    
  </entry>
  
  <entry>
    <title>调用C标准库的exit函数</title>
    <link href="https://liutos.github.io/2019/07/10/%E8%B0%83%E7%94%A8C%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84exit%E5%87%BD%E6%95%B0/"/>
    <id>https://liutos.github.io/2019/07/10/调用C标准库的exit函数/</id>
    <published>2019-07-10T11:58:06.000Z</published>
    <updated>2019-07-10T13:40:54.544Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://liutos.github.io/2019/07/03/%E7%BC%96%E8%AF%91%E5%A4%A7%E4%BA%8E%E8%BF%90%E7%AE%97%E7%AC%A6/">上一篇文章</a>中，实现了对大于号（<code>&gt;</code>）的处理，那么对<code>if</code>表达式的编译也就是信手拈来的事了，不解释太多。在本篇中，将会讲述一下如何产生可以调用来自于C语言标准库的<code>exit(3)</code>函数的汇编代码。</p><p>在Common Lisp中并没有一个叫做<code>EXIT</code>的内置函数，所以如同之前实现的<code>_exit</code>一样，我会新增一种需要识别的<code>(first expr)</code>，即符号<code>exit</code>。为了可以调用C语言标准库中的<code>exit</code>函数，需要遵循调用约定。对于<code>exit</code>这种只有一个参数的函数而言，情形比较简单，只需要跟对<code>_exit</code>一样处理即可。刚开始，我写下的代码是这样的</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="comment">;; 省略不必要的内容</span></span><br><span class="line">  (<span class="name">cond</span> <span class="comment">;; 省略不必要的内容</span></span><br><span class="line">        ((<span class="name">member</span> (<span class="name">first</span> expr) '(_exit exit))</span><br><span class="line">         <span class="comment">;; 暂时以硬编码的方式识别一个函数是否来自于C语言的标准库</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           (call :|_exit|)))))</span><br></pre></td></tr></table></figure><p>对<code>(exit 1)</code>进行编译，会得到如下的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EDI</span><br><span class="line">        CALL _exit</span><br></pre></td></tr></table></figure><p>不过这样的代码经过编译链接之后，一运行就会遇到段错误（segmentation fault）。经过一番放狗搜索后，才知道原来在macOS上调用C函数的时候，需要先将栈对齐到16字节——我将其理解为将指向栈顶的指针对齐到16字节。于是乎，我将<code>jjcc2</code>修改为如下的形式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="comment">;; 省略不必要的内容</span></span><br><span class="line">  (<span class="name">cond</span> <span class="comment">;; 省略不必要的内容</span></span><br><span class="line">        ((<span class="name">member</span> (<span class="name">first</span> expr) '(_exit exit))</span><br><span class="line">         <span class="comment">;; 暂时以硬编码的方式识别一个函数是否来自于C语言的标准库</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           ;; 据这篇回答（https<span class="symbol">://stackoverflow</span>.com/questions/12678230/how-to-print-argv0-in-nasm）所说，在macOS上调用C语言函数，需要将栈对齐到<span class="number">16</span>位</span><br><span class="line">           ;; 假装要对齐的是栈顶地址。因为栈顶地址是往低地址增长的，所以只需要将地址的低<span class="number">16</span>位抹掉就可以了</span><br><span class="line">           (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFF0</span>) %esp)</span><br><span class="line">           (call :|_exit|)))))</span><br></pre></td></tr></table></figure><p>结果发现还是不行。最后，实在没辙了，只好先写一段简单的C代码，然后用<code>gcc -S</code>生成汇编代码，来看看究竟应当如何处理这个栈的对齐要求。一番瞎折腾之后，发现原来是要处理<code>RSP</code>寄存器而不是<code>ESP</code>寄存器——我也不晓得这是为什么，<code>ESP</code>不就是<code>RSP</code>的低32位而已么。</p><p>最后，把<code>jjcc2</code>写成下面这样后，终于可以成功编译<code>(exit 1)</code>了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(get-operand expr <span class="number">0</span>))))</span><br><span class="line">                 globals))</span><br><span class="line">        <span class="comment">;; ((eq (first expr) '_exit)</span></span><br><span class="line">        <span class="comment">;;  ;; 因为知道_exit只需要一个参数，所以将它的第一个操作数塞到EDI寄存器里面就可以了</span></span><br><span class="line">        <span class="comment">;;  ;; <span class="doctag">TODO:</span> 更好的写法，应该是有一个单独的函数来处理这种参数传递的事情（以符合calling convention的方式）</span></span><br><span class="line">        <span class="comment">;;  `((movl ,(get-operand expr 0) %edi)</span></span><br><span class="line">        <span class="comment">;;    (movl #x2000001 %eax)</span></span><br><span class="line">        <span class="comment">;;    (syscall)))</span></span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '&gt;)</span><br><span class="line">         <span class="comment">;; 为了可以把比较之后的结果放入到EAX寄存器中，以我目前不完整的汇编语言知识，可以想到的方法如下</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-greater-than</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           <span class="comment">;; 根据这篇文章（https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions）中的说法，大于号左边的数字应该放在CMP指令的第二个操作数中，右边的放在第一个操作数中</span></span><br><span class="line">           `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">             (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">             (cmpl %ebx %eax)</span><br><span class="line">             (jg ,label-greater-than)</span><br><span class="line">             (movl $<span class="number">0</span> %eax)</span><br><span class="line">             (jmp ,label-end)</span><br><span class="line">             ,label-greater-than</span><br><span class="line">             (movl $<span class="number">1</span> %eax)</span><br><span class="line">             ,label-end)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'if)</span><br><span class="line">         <span class="comment">;; 假定if语句的测试表达式的结果也是放在%eax寄存器中的，所以只需要拿%eax寄存器中的值跟0做比较即可（类似于C语言）</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-else</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">second</span> expr) globals)</span><br><span class="line">                   `((cmpl $<span class="number">0</span> %eax)</span><br><span class="line">                     (je ,label-else))</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                   `((jmp ,label-end)</span><br><span class="line">                     ,label-else)</span><br><span class="line">                   (<span class="name">jjcc2</span> (<span class="name">fourth</span> expr) globals)</span><br><span class="line">                   `(,label-end))))</span><br><span class="line">        ((<span class="name">member</span> (<span class="name">first</span> expr) '(_exit exit))</span><br><span class="line">         <span class="comment">;; 暂时以硬编码的方式识别一个函数是否来自于C语言的标准库</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           ;; 据这篇回答（https<span class="symbol">://stackoverflow</span>.com/questions/12678230/how-to-print-argv0-in-nasm）所说，在macOS上调用C语言函数，需要将栈对齐到<span class="number">16</span>位</span><br><span class="line">           ;; 假装要对齐的是栈顶地址。因为栈顶地址是往低地址增长的，所以只需要将地址的低<span class="number">16</span>位抹掉就可以了</span><br><span class="line">           (and ,(format <span class="literal">nil</span> <span class="string">"$0x~X"</span> <span class="number">#XFFFFFFFFFFFFFFF0</span>) %rsp)</span><br><span class="line">           (call :|_exit|)))))</span><br></pre></td></tr></table></figure><p>生成的汇编代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EDI</span><br><span class="line">        AND $0xFFFFFFFFFFFFFFF0, %RSP</span><br><span class="line">        CALL _exit</span><br></pre></td></tr></table></figure><p>好了，这个时候我就在想，如果想要支持其它来自C语言标准库的函数的话，只要依葫芦画瓢就好了，好像还挺简单的——天真的我如此天真地想着。</p><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://liutos.github.io/2019/07/03/%E7%BC%96%E8%AF%91%E5%A4%A7%E4%BA%8E%E8%BF%90%E7%AE%97%E7%AC%A6/&quot;&gt;上一篇文章&lt;/a&gt;中，实现了对大于号（&lt;code&gt;&amp;gt;&lt;/code&gt;）的处理，那么对&lt;code&gt;if&lt;/code&gt;表达式的编译也就是信手拈来的事了，不解释太多。在本篇中，将会讲述一下如何产生可以调用来自于C语言标准库的&lt;code&gt;exit(3)&lt;/code&gt;函数的汇编代码。&lt;/p&gt;
&lt;p&gt;在Common Lisp中并没有一个叫做&lt;code&gt;EXIT&lt;/code&gt;的内置函数，所以如同之前实现的&lt;code&gt;_exit&lt;/code&gt;一样，我会新增一种需要识别的&lt;code&gt;(first expr)&lt;/code&gt;，即符号&lt;code&gt;exit&lt;/code&gt;。为了可以调用C语言标准库中的&lt;code&gt;exit&lt;/code&gt;函数，需要遵循调用约定。对于&lt;code&gt;exit&lt;/code&gt;这种只有一个参数的函数而言，情形比较简单，只需要跟对&lt;code&gt;_exit&lt;/code&gt;一样处理即可。刚开始，我写下的代码是这样的&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>编译大于运算符</title>
    <link href="https://liutos.github.io/2019/07/03/%E7%BC%96%E8%AF%91%E5%A4%A7%E4%BA%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://liutos.github.io/2019/07/03/编译大于运算符/</id>
    <published>2019-07-03T14:27:24.000Z</published>
    <updated>2019-07-10T12:01:16.935Z</updated>
    
    <content type="html"><![CDATA[<p>原定的计划中这一篇应当是要讲如何编译<a href="http://clhs.lisp.se/Body/s_if.htm" target="_blank" rel="noopener">if</a>表达式的，但是我发现没什么东西可以作为if的test-form的部分的表达式，所以觉得，要不还是先实现一下比较两个数字这样子的功能吧。说干就干，我决定用大于运算符来作为例子——大于运算符就是指<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_eq_sle.htm#GT" target="_blank" rel="noopener"><code>&gt;</code></a>啦。所以，我的目标是要编译下面这样的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">&gt;</span> <span class="number">1</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>并且比较之后的结果要放在<code>EAX</code>寄存器中。鉴于现在这门语言还非常地简陋，没有<a href="http://clhs.lisp.se/Body/t_ban.htm" target="_blank" rel="noopener">布尔类型</a>这样子的东西，所以在此仿照C语言的处置方式，以数值0表示逻辑假，其它的值表示逻辑真。所以上面的表达式在编译成汇编代码并最终运行后，应当可以看到<code>EAX</code>寄存器中的值为0。</p><p>为了编译大于运算符，并且将结果放入到<code>EAX</code>寄存器中，需要用到新的指令<code>CMP</code>、<code>JG</code>，以及<code>JMP</code>了。我的想法是，先将第一个操作数放入到<code>EAX</code>寄存器，将第二个操作数放入到<code>EBX</code>寄存器。然后，使用<code>CMP</code>指令比较这两个寄存器。如果<code>EAX</code>中的数值大于<code>EBX</code>，那么就使用<code>JG</code>指令跳到一个<code>MOV</code>指令上，这道<code>MOV</code>会将寄存器<code>EAX</code>的值修改为1；否则，<code>JG</code>不被执行，执行后续的一道<code>MOV</code>指令，将数值0写入到<code>EAX</code>寄存器，然后使用<code>JMP</code>跳走，避免又执行到了刚才的第一道<code>MOV</code>指令。思路还是挺简单的。</p><p>在修改<code>jjcc2</code>之前，还需要在<code>inside-out/aux</code>中对<code>&gt;</code>予以支持，但没什么特别的，就是往<code>member</code>的参数中加入<code>&gt;</code>这个符号而已。之后，将<code>jjcc2</code>改为如下的形式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(get-operand expr <span class="number">0</span>))))</span><br><span class="line">                 globals))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '_exit)</span><br><span class="line">         <span class="comment">;; 因为知道_exit只需要一个参数，所以将它的第一个操作数塞到EDI寄存器里面就可以了</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 更好的写法，应该是有一个单独的函数来处理这种参数传递的事情（以符合calling convention的方式）</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %edi)</span><br><span class="line">           (movl <span class="number">#x2000001</span> %eax)</span><br><span class="line">           (syscall)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '&gt;)</span><br><span class="line">         <span class="comment">;; 为了可以把比较之后的结果放入到EAX寄存器中，以我目前不完整的汇编语言知识，可以想到的方法如下</span></span><br><span class="line">         (<span class="name">let</span> ((<span class="name">label-greater-than</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>))</span><br><span class="line">               (<span class="name">label-end</span> (<span class="name">intern</span> (<span class="name">symbol-name</span> (<span class="name">gensym</span>)) <span class="symbol">:keyword</span>)))</span><br><span class="line">           <span class="comment">;; 根据这篇文章（https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison_Instructions）中的说法，大于号左边的数字应该放在CMP指令的第二个操作数中，右边的放在第一个操作数中</span></span><br><span class="line">           `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">             (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">             (cmpl %ebx %eax)</span><br><span class="line">             (jg ,label-greater-than)</span><br><span class="line">             (movl $<span class="number">0</span> %eax)</span><br><span class="line">             (jmp ,label-end)</span><br><span class="line">             ,label-greater-than</span><br><span class="line">             (movl $<span class="number">1</span> %eax)</span><br><span class="line">             ,label-end)))))</span><br></pre></td></tr></table></figure><p>然后便可以在REPL中运行下列代码了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">ht</span> (<span class="name">make-hash-table</span>))</span><br><span class="line">       (<span class="name">asm</span> (<span class="name">jjcc2</span> (<span class="name">inside-out</span> '(_exit (&gt; <span class="number">1</span> <span class="number">2</span>))) ht)))</span><br><span class="line">  (<span class="name">stringify</span> asm ht))</span><br></pre></td></tr></table></figure><p>输出的汇编代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">G809: .long 0</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EAX</span><br><span class="line">        MOVL $2, %EBX</span><br><span class="line">        CMPL %EBX, %EAX</span><br><span class="line">        JG G810</span><br><span class="line">        MOVL $0, %EAX</span><br><span class="line">        JMP G811</span><br><span class="line">G810:</span><br><span class="line">        MOVL $1, %EAX</span><br><span class="line">G811:</span><br><span class="line">        MOVL %EAX, G809(%RIP)</span><br><span class="line">        MOVL G809(%RIP), %EDI</span><br><span class="line">        MOVL $33554433, %EAX</span><br><span class="line">        SYSCALL</span><br></pre></td></tr></table></figure><p>编译链接运行后，就可以得到预期的结果了。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原定的计划中这一篇应当是要讲如何编译&lt;a href=&quot;http://clhs.lisp.se/Body/s_if.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;if&lt;/a&gt;表达式的，但是我发现没什么东西可以作为if的test-form的部分的表达式，所以觉得，要不还是先实现一下比较两个数字这样子的功能吧。说干就干，我决定用大于运算符来作为例子——大于运算符就是指&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/f_eq_sle.htm#GT&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;啦。所以，我的目标是要编译下面这样的代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>inside-out/aux如何支持对_exit的调用</title>
    <link href="https://liutos.github.io/2019/06/26/inside-out-aux%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%AF%B9-exit%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>https://liutos.github.io/2019/06/26/inside-out-aux如何支持对-exit的调用/</id>
    <published>2019-06-26T13:44:25.000Z</published>
    <updated>2019-07-10T12:01:04.586Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://liutos.github.io/2019/06/14/%E6%8B%86%E8%A7%A3%E5%B5%8C%E5%A5%97%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/">上一篇文章</a>中，新增了两个函数：<code>inside-out</code>以及<code>inside-out/aux</code>——曾经想过将<code>inside-out/aux</code>放到前者的函数中用<code>labels</code>来定义，但担心不好调试，所以剥离了出来成为一个独立的函数——<code>inside-out</code>基本上只是驱动了后者，真正地将嵌套表达式拆解开来的还是<code>inside-out/aux</code>。因此，为了让让这个编译器最终可以处理如下形式的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">_exit</span> (<span class="name">+</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>就需要先对<code>inside-out/aux</code>进行一番改造，使其可以处理上述代码。</p><p>在此之前，先处理一下<code>inside-out/aux</code>目前的一些问题。在之前的实现中，由于使用了<code>setf</code>对输入参数<code>expr</code>进行了修改，因此在<code>example3</code>中的列表实际上在第二次运行的时候已经不是代码中看到的那样子了。所以，先将<code>inside-out/aux</code>改写为更pure的形式</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> inside-out/aux (<span class="name">expr</span> result)</span><br><span class="line">  <span class="string">"将嵌套的表达式EXPR由内而外地翻出来"</span></span><br><span class="line">  (<span class="name">check-type</span> expr list)</span><br><span class="line">  <span class="comment">;; 出于简单起见，暂时只处理加法运算</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">member</span> (<span class="name">first</span> expr) '(+ - * /))</span><br><span class="line">         (let ((operands '()))</span><br><span class="line">           (if (listp (second expr))</span><br><span class="line">               ;; 第一个操作数也是需要翻出来的</span><br><span class="line">               ;; 翻出来后，result中的第一个元素就是一个没有嵌套表达式的叶子表达式了，可以作为setq的第二个操作数</span><br><span class="line">               (let ((var (gensym)))</span><br><span class="line">                 (setf result (inside-out/aux (second expr) result))</span><br><span class="line">                 (let ((val (pop result)))</span><br><span class="line">                   (push `(setq ,var ,val) result)</span><br><span class="line">                   (push var operands)))</span><br><span class="line">               (push (second expr) operands))</span><br><span class="line">           (if (listp (third expr))</span><br><span class="line">               (let ((var (gensym)))</span><br><span class="line">                 (setf result (inside-out/aux (third expr) result))</span><br><span class="line">                 (let ((val (pop result)))</span><br><span class="line">                   (push `(setq ,var ,val) result)</span><br><span class="line">                   (push var operands)))</span><br><span class="line">               (push (third expr) operands))</span><br><span class="line">           (push (cons (first expr) (nreverse operands)) result)</span><br><span class="line">           result))</span><br><span class="line">        (t</span><br><span class="line">         (push expr result)</span><br><span class="line">         result)))</span><br></pre></td></tr></table></figure><p>其实改动很简单，就是使用一个新的列表<code>operands</code>来承载被修改后的符号或原本的表达式而已。接下来可以开始支持<code>_exit</code>函数了。</p><p>其实要支持<code>_exit</code>也是很简单的，直接模仿对加减乘除的处理即可。将处理第一个操作数部分的代码抄过来，基本上就搞定了。不过这样子不利于以后支持更泛用的函数调用的表达式，因此这里尝试将其改写为稍微通用一点的实现方式。</p><p>通用的地方就在于，不是只考虑两个参数或者一个参数的情况。其实在上一篇文章中应该就可以感受到，对加减乘除的两个参数的处理也是相当有规律的，只需要将调用<code>second</code>和<code>third</code>分别提取输入表达式的第一和第二个参数的代码替换为处理一个来自于循环的变量即可。最终的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> inside-out/aux (<span class="name">expr</span> result)</span><br><span class="line">  <span class="string">"将嵌套的表达式EXPR由内而外地翻出来"</span></span><br><span class="line">  (<span class="name">check-type</span> expr list)</span><br><span class="line">  <span class="comment">;; 出于简单起见，暂时只处理加法运算</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">member</span> (<span class="name">first</span> expr) '(+ - * / _exit))</span><br><span class="line">         (let ((operands '()))</span><br><span class="line">           ;; 对参数列表中的所有表达式都递归地进行【外翻】处理</span><br><span class="line">           (dolist (arg (rest expr))</span><br><span class="line">             (if (listp arg)</span><br><span class="line">                 (let ((var (gensym)))</span><br><span class="line">                   (setf result (inside-out/aux arg result))</span><br><span class="line">                   (let ((val (pop result)))</span><br><span class="line">                     (push `(setq ,var ,val) result)</span><br><span class="line">                     (push var operands)))</span><br><span class="line">                 (push arg operands)))</span><br><span class="line">           (push (cons (first expr) (nreverse operands)) result)</span><br><span class="line">           result))</span><br><span class="line">        (t</span><br><span class="line">         (push expr result)</span><br><span class="line">         result)))</span><br></pre></td></tr></table></figure><p>哈，通用的版本反而是最短的一个XD现在，<code>inside-out</code>函数可以处理刚才的代码了。在REPL中运行如下代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">inside-out</span> '(_exit (+ (+ <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)))</span><br></pre></td></tr></table></figure><p>便可以获取翻转后的“线性”的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">PROGN</span></span><br><span class="line"> (<span class="name">SETQ</span> #<span class="symbol">:G717</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line"> (<span class="name">SETQ</span> #<span class="symbol">:G716</span> (<span class="name">+</span> #<span class="symbol">:G717</span> <span class="number">3</span>))</span><br><span class="line"> (<span class="name">_EXIT</span> #<span class="symbol">:G716</span>))</span><br></pre></td></tr></table></figure><p>如此一来，也没有必要在<code>stringify</code>函数中内置调用<code>_exit</code>函数的固定代码了，<code>stringify</code>改为如下的样子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> stringify (<span class="name">asm</span> globals)</span><br><span class="line">  <span class="string">"根据jjcc2产生的S表达式生成汇编代码字符串"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  <span class="comment">;; 输出globals中的所有变量</span></span><br><span class="line">  <span class="comment">;; <span class="doctag">FIXME:</span> 暂时只支持输出数字</span></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .data~%"</span>)</span><br><span class="line">  (<span class="name">maphash</span> (<span class="name">lambda</span> (<span class="name">k</span> v)</span><br><span class="line">             (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A: .long ~D~%"</span> k v))</span><br><span class="line">           globals)</span><br><span class="line"></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .section __TEXT,__text,regular,pure_instructions~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .globl _main~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"_main:~%"</span>)</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">ins</span> asm)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">3</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A, ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">third</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">2</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">1</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A~%"</span> (<span class="name">first</span> ins))))))</span><br></pre></td></tr></table></figure><p>如果希望调用<code>_exit</code>来验证四则运算的计算结果的话，就显式地调用<code>_exit</code>函数吧，代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> example4 ()</span><br><span class="line">  <span class="string">"处理含有嵌套表达式的_exit函数调用"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">expr</span> '(_exit (+ (- (* (/ <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>) <span class="number">4</span>) <span class="number">5</span>)))</span><br><span class="line">        (<span class="name">ht</span> (<span class="name">make-hash-table</span>)))</span><br><span class="line">    (<span class="name">let*</span> ((<span class="name">expr2</span> (<span class="name">inside-out</span> expr))</span><br><span class="line">           (<span class="name">asm</span> (<span class="name">jjcc2</span> expr2 ht)))</span><br><span class="line">      (<span class="name">stringify</span> asm ht))))</span><br></pre></td></tr></table></figure><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://liutos.github.io/2019/06/14/%E6%8B%86%E8%A7%A3%E5%B5%8C%E5%A5%97%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/&quot;&gt;上一篇文章&lt;/a&gt;中，新增了两个函数：&lt;code&gt;inside-out&lt;/code&gt;以及&lt;code&gt;inside-out/aux&lt;/code&gt;——曾经想过将&lt;code&gt;inside-out/aux&lt;/code&gt;放到前者的函数中用&lt;code&gt;labels&lt;/code&gt;来定义，但担心不好调试，所以剥离了出来成为一个独立的函数——&lt;code&gt;inside-out&lt;/code&gt;基本上只是驱动了后者，真正地将嵌套表达式拆解开来的还是&lt;code&gt;inside-out/aux&lt;/code&gt;。因此，为了让让这个编译器最终可以处理如下形式的代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;_exit&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就需要先对&lt;code&gt;inside-out/aux&lt;/code&gt;进行一番改造，使其可以处理上述代码。&lt;/p&gt;
&lt;p&gt;在此之前，先处理一下&lt;code&gt;inside-out/aux&lt;/code&gt;目前的一些问题。在之前的实现中，由于使用了&lt;code&gt;setf&lt;/code&gt;对输入参数&lt;code&gt;expr&lt;/code&gt;进行了修改，因此在&lt;code&gt;example3&lt;/code&gt;中的列表实际上在第二次运行的时候已经不是代码中看到的那样子了。所以，先将&lt;code&gt;inside-out/aux&lt;/code&gt;改写为更pure的形式&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>时序图绘制工具走马观花</title>
    <link href="https://liutos.github.io/2019/06/18/%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B7%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/"/>
    <id>https://liutos.github.io/2019/06/18/时序图绘制工具走马观花/</id>
    <published>2019-06-18T14:01:00.000Z</published>
    <updated>2019-06-18T14:10:33.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么我会需要绘制时序图"><a href="#为什么我会需要绘制时序图" class="headerlink" title="为什么我会需要绘制时序图"></a>为什么我会需要绘制时序图</h2><p>我司在做一些咋看之下比较复杂的需求的时候，都需要先写设计文档，不过我猜想这种规矩应该在很多公司都有才对，我并没有其它公司没有这种规矩的言外之意。然后呢，我个人比较习惯按照“从外到内”的方式来写设计文档，因此，在文档的开篇我总是会描述一下一个需求的全局视图，一般来说，就是用绘图的方式。对于一些复杂的活动需求里的流程，咋一看觉得会涉及到多个系统间的调用的时候，我就会选择画一幅时序图了。</p><p>需要事先说明的是，我没有正儿八经地系统学习过UML方面的内容，所以我画出来的图都只是一些不算很规范的野鸡时序图，当然了，我也不知道这世界上到底有没有规范的时序图画法。</p><p>为了画时序图，用过几款工具。它们的共同点，就是都是“语绘”的，也就是通过写代码的方式来描述所想要的图，然后让这些工具帮你把这张图给“画出来”。我个人更喜欢这种方式，而不是拖拖拉拉，不过这纯粹是个人喜好的问题而已。</p><h2 id="走马观花"><a href="#走马观花" class="headerlink" title="走马观花"></a>走马观花</h2><p><a href="http://www.websequencediagrams.com是我接触到的第一个“语绘”时序图的工具。打开它之后，就会看到它的实例代码和效果图了，截图如下" target="_blank" rel="noopener">www.websequencediagrams.com是我接触到的第一个“语绘”时序图的工具。打开它之后，就会看到它的实例代码和效果图了，截图如下</a></p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/websequencediagrams%E9%A6%96%E9%A1%B5.png" alt=""></p><p>用这个网站的工具画出来的时序图会有一种【手绘】的感觉</p><p><a href="http://sdedit.sourceforge.net/index.html" target="_blank" rel="noopener"><code>sdedit</code></a>是我第二款使用的绘图工具，是一款用Java开发的本地工具，只需要编写好一个<code>.sd</code>文件，然后用下列的命令处理即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdedit -t png -o a.png a.sd</span><br></pre></td></tr></table></figure><p><code>sdedit</code>绘制时序图的代码的语法跟WebSequenceDiagrams不同，在Emacs中似乎也没有找到别人写好的适合编辑<code>.sd</code>文件的主模式，后来我自己定义了一个简陋的主模式来用，如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> sdedit-highlights</span><br><span class="line">      '((<span class="string">"Actor\\|Node"</span> . font-lock-function-name-face)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define-derived-mode</span> sdedit-mode fundamental-mode <span class="string">"sdedit"</span></span><br><span class="line">  <span class="string">"编辑.sd文件的主模式"</span></span><br><span class="line">  (<span class="name">setq</span> font-lock-defaults '(sdedit-highlights)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;; 代码是从下面这个网页给的例子改动来的</span></span><br><span class="line"><span class="comment">;;; https://www.emacswiki.org/emacs/CompileCommand</span></span><br><span class="line">(<span class="name">add-hook</span> 'sdedit-mode-hook</span><br><span class="line">          (<span class="name">lambda</span> ()</span><br><span class="line">            (<span class="name">unless</span> (<span class="name">file-exists-p</span> <span class="string">"Makefile"</span>)</span><br><span class="line">              (<span class="name">set</span> (<span class="name">make-local-variable</span> 'compile-command)</span><br><span class="line">                   (<span class="name">let*</span> ((<span class="name">buffer-name</span> (<span class="name">buffer-name</span>))</span><br><span class="line">                          (<span class="name">base-name</span> (<span class="name">car</span> (<span class="name">split-string</span> buffer-name <span class="string">"\\."</span>))))</span><br><span class="line">                     (<span class="name">format</span> <span class="string">"/usr/local/bin/sdedit -t png -o %s.png %s.sd"</span> base-name base-name))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-to-list</span> 'auto-mode-alist</span><br><span class="line">             '(<span class="string">"\\.sd$"</span> . sdedit-mode))</span><br></pre></td></tr></table></figure><p>勉勉强强可以接受</p><p>sequencediagram.org则是最近刚发掘到的一个不错的绘制时序图的在线工具。它的绘制语法跟WebSequenceDiagrams是一样的，并且它还有一个不错的教程。打开它的网站后，点击左侧的这个图标</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/sequencediagram.org%E7%9A%84%E6%95%99%E7%A8%8B%E5%85%A5%E5%8F%A3.png" alt=""></p><p>便可以看到详尽的语法教程。</p><p>sequencediagram.org绘制出来的时序图是这三个工具中最符合我的审美的，今后应当会成为我绘制时序图的主力工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="sequencediagram" scheme="https://liutos.github.io/tags/sequencediagram/"/>
    
      <category term="时序图" scheme="https://liutos.github.io/tags/%E6%97%B6%E5%BA%8F%E5%9B%BE/"/>
    
      <category term="语绘" scheme="https://liutos.github.io/tags/%E8%AF%AD%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>拆解嵌套的表达式</title>
    <link href="https://liutos.github.io/2019/06/14/%E6%8B%86%E8%A7%A3%E5%B5%8C%E5%A5%97%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://liutos.github.io/2019/06/14/拆解嵌套的表达式/</id>
    <published>2019-06-14T13:43:23.000Z</published>
    <updated>2019-06-14T13:48:35.140Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://liutos.github.io/2019/06/11/%E6%94%AF%E6%8C%81%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/">上一篇文章</a>中，<code>jjcc2</code>函数已经可以处理加减乘除运算表达式中的变量了。也就是说，现在它可以处理如下的代码了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">setq</span> a (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">  (<span class="name">+</span> a a))</span><br></pre></td></tr></table></figure><p>在我的电脑上，在SLIME中依次运行下面的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> *globals* (<span class="name">make-hash-table</span>))</span><br><span class="line">(<span class="name">stringify</span> (<span class="name">jjcc2</span> '(progn (setq a (+ <span class="number">1</span> <span class="number">2</span>)) (+ a a)) *globals*) *globals*)</span><br></pre></td></tr></table></figure><p>会得到下列的汇编代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">A: .long 0</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EAX</span><br><span class="line">        MOVL $2, %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        MOVL %EAX, A(%RIP)</span><br><span class="line">        MOVL A(%RIP), %EAX</span><br><span class="line">        MOVL A(%RIP), %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        movl %eax, %edi</span><br><span class="line">        movl $0x2000001, %eax</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure><p>现在所需要的，就是要实现一个功能（一般是一个函数），可以将</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>自动转换为上面所给出的<code>progn</code>的形式了。我这里给的例子不好，上面这段代码就算能够自动转换，也不会是最上面那段<code>progn</code>的形式的，起码会有两个变量哈哈。好了，那么怎么把上面的含有嵌套表达式的代码给转换成<code>progn</code>的形式呢？</p><p>跑个题，可以做个CPS变换呀。比如，你可以先把<code>(+ (+ 1 2) (+ 1 2))</code>写成这种形式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+&amp;</span> <span class="number">1</span> <span class="number">2</span> (<span class="name">lambda</span> (<span class="name">a</span>)</span><br><span class="line">          (<span class="name">+&amp;</span> <span class="number">1</span> <span class="number">2</span> (<span class="name">lambda</span> (<span class="name">b</span>)</span><br><span class="line">                    (<span class="name">+</span> a b)))))</span><br></pre></td></tr></table></figure><p>上面的<code>+&amp;</code>表示它是一个带<code>continuation</code>版本的加法运算，它会把两个操作相加之后调用它的continuation。这个写法如果没有记错的话，我是从PG的《On Lisp》里面学来的（逃</p><p>你看，这多简单呀。做完CPS变换之后，只要把每一个有continuation的函数调用都重写成<code>setq</code>，符号就用回调里的参数名，值就是带回调的表达式本身；没有回调的就继续没有。最后把这些<code>setq</code>放到一个<code>progn</code>里去就可以了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">setq</span> a (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">  (<span class="name">setq</span> b (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">  (<span class="name">+</span> a b))</span><br></pre></td></tr></table></figure><p>很久以前还真的写过一个对表达式做CPS变换的玩意，有兴趣的请移步<a href="http://liutos.github.io/2012/09/08/CommonLisp%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84CPS%E5%8F%98%E6%8D%A2/">这篇文章</a>。</p><p>言归正传。因为<code>jjcc2</code>只需要处理两个参数的加减乘除运算，所以不需要做通用的CPS变换那么复杂。我是这么想的：既然只有两个参数，那么我就真的在代码里先处理第一个再处理第二个。对两个参数，我都把它们放到一个<code>setq</code>的求值部分，然后把原来的表达式中的对应位置用一个新的变量名来代替即可，新变量名也好办，只要用<code>gensym</code>来生成就可以了。</p><p>其实这样是不够的，因为作为加减乘除运算的操作数的表达式本身，也可能还有嵌套的子表达式。这里必然有一个递归的过程。新的办法是，我用一个栈来存放所有不再需要被拆解的<code>setq</code>表达式，然后把这个栈在每次递归调用的时候传进去。这样一来，当所有的递归都结束的时候，就得到了一个充满了<code>setq</code>表达式的栈，以及一个所有的嵌套表达式都被替换为变量名的“顶层”表达式。</p><p>好了，说完了思路，上代码吧</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> inside-out/aux (<span class="name">expr</span> result)</span><br><span class="line">  <span class="string">"将嵌套的表达式EXPR由内而外地翻出来"</span></span><br><span class="line">  (<span class="name">check-type</span> expr list)</span><br><span class="line">  <span class="comment">;; 出于简单起见，暂时只处理加法运算</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         (<span class="name">when</span> (<span class="name">listp</span> (<span class="name">second</span> expr))</span><br><span class="line">           <span class="comment">;; 第一个操作数也是需要翻出来的</span></span><br><span class="line">           <span class="comment">;; 翻出来后，result中的第一个元素就是一个没有嵌套表达式的叶子表达式了，可以作为setq的第二个操作数</span></span><br><span class="line">           (<span class="name">let</span> ((<span class="name">var</span> (<span class="name">gensym</span>)))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">inside-out/aux</span> (<span class="name">second</span> expr) result))</span><br><span class="line">             (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">pop</span> result)))</span><br><span class="line">               (<span class="name">push</span> `(setq ,var ,val) result)</span><br><span class="line">               (<span class="name">setf</span> (<span class="name">second</span> expr) var))))</span><br><span class="line">         (<span class="name">when</span> (<span class="name">listp</span> (<span class="name">third</span> expr))</span><br><span class="line">           (<span class="name">let</span> ((<span class="name">var</span> (<span class="name">gensym</span>)))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">inside-out/aux</span> (<span class="name">third</span> expr) result))</span><br><span class="line">             (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">pop</span> result)))</span><br><span class="line">               (<span class="name">push</span> `(setq ,var ,val) result)</span><br><span class="line">               (<span class="name">setf</span> (<span class="name">third</span> expr) var))))</span><br><span class="line">         (<span class="name">push</span> expr result)</span><br><span class="line">         result)</span><br><span class="line">        (<span class="name">t</span></span><br><span class="line">         (<span class="name">push</span> expr result)</span><br><span class="line">         result)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> inside-out (<span class="name">expr</span>)</span><br><span class="line">  (<span class="name">cons</span> 'progn (<span class="name">nreverse</span> (<span class="name">inside-out/aux</span> expr '()))))</span><br></pre></td></tr></table></figure><p>因为用的是栈（其实就是个list），所以最后需要用<code>nreverse</code>反转一下，才能拼上<code>progn</code>。现在，如果喂给<code>inside-out</code>一个嵌套的表达式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">inside-out</span> '(+ (+ <span class="number">1</span> <span class="number">2</span>) (+ <span class="number">3</span> <span class="number">4</span>)))</span><br></pre></td></tr></table></figure><p>就会得到一个由内而外地翻出来的版本</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">PROGN</span></span><br><span class="line"> (<span class="name">SETQ</span> #<span class="symbol">:G688</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line"> (<span class="name">SETQ</span> #<span class="symbol">:G689</span> (<span class="name">+</span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line"> (<span class="name">+</span> #<span class="symbol">:G688</span> #<span class="symbol">:G689</span>))</span><br></pre></td></tr></table></figure><p>锵锵锵，Common Lisp中的unintern symbol再次登场。好了，现在即便是嵌套的加减乘除运算的表达式，只要先经过<code>inside-out</code>处理一下，再喂给<code>jjcc2</code>，也可以编译出结果来了，可喜可贺。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://liutos.github.io/2019/06/11/%E6%94%AF%E6%8C%81%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/&quot;&gt;上一篇文章&lt;/a&gt;中，&lt;code&gt;jjcc2&lt;/code&gt;函数已经可以处理加减乘除运算表达式中的变量了。也就是说，现在它可以处理如下的代码了&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;progn&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;setq&lt;/span&gt; a (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; a a))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在我的电脑上，在SLIME中依次运行下面的代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;defvar&lt;/span&gt; *globals* (&lt;span class=&quot;name&quot;&gt;make-hash-table&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;stringify&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;jjcc2&lt;/span&gt; &#39;(progn (setq a (+ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)) (+ a a)) *globals*) *globals*)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会得到下列的汇编代码&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>支持四则运算中的变量</title>
    <link href="https://liutos.github.io/2019/06/11/%E6%94%AF%E6%8C%81%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/"/>
    <id>https://liutos.github.io/2019/06/11/支持四则运算中的变量/</id>
    <published>2019-06-11T13:30:41.000Z</published>
    <updated>2019-06-11T13:37:53.919Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://liutos.github.io/2019/06/01/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91setq%EF%BC%9F/">上一篇文章</a>中，<code>jjcc2</code>函数实现了对<code>setq</code>这个语句的编译。这么一来，便可以将加减乘除运算中的嵌套表达式都替换为变量了。比如，将</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>) <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>中的嵌套的表达式<code>(+ 1 2)</code>用一个变量<code>G564</code>代替，变成</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">PROGN</span></span><br><span class="line">  (<span class="name">SETQ</span> #<span class="symbol">:G564</span> (<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">  (<span class="name">+</span> #<span class="symbol">:G564</span> <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>PS：上面的结果中的<code>#:G564</code>只是打印出来的时候长这个样子而已，实际地输入这段代码的话，两个<code>#:G564</code>其实是不同的符号，会导致未绑定的变量的错误的。</p><p>言归正传。既然如此，现在就要来支持编译<code>(+ #:G564 3)</code>这样的表达式了。其实这个真的是太简单了，只需要将这个符号塞入到<code>jjcc2</code>的第二个参数的<code>globals</code>中，然后在生成的“汇编指令”的S表达式中，嵌入这个符号即可。</p><p>我刚开始的时候也是这么想的，后来发现这样出来的代码编译不过，哭</p><p>折腾了一小段时间后，才知道原来有一种叫做“RIP-relative”的东西——好吧，我的X64的汇编语言知识也是赶鸭子上架的，遇到什么问题就放狗搜，所以完全不成体系——总之，我找到了解决办法，就是将原本放入一个符号的操作数，替换为类似于下面这样的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G564(%RIP)</span><br></pre></td></tr></table></figure><p>所以对于操作数，实际上还需要先判断一下其类型。如果是整数，就按照原来的方式原样输出；如果是符号，就生成像上面这样的RIP-relative的结构。这部分太经常出现了，于是提炼出了一个专门处理四则运算的操作数的辅助函数<code>get-operand</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> get-operand (<span class="name">expr</span> n)</span><br><span class="line">  <span class="string">"从EXPR中提取出第N个操作数，操作数的下标从0开始计算"</span></span><br><span class="line">  (<span class="name">check-type</span> expr list)</span><br><span class="line">  (<span class="name">check-type</span> n integer)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">e</span> (<span class="name">nth</span> (<span class="number">1</span>+ n) expr)))</span><br><span class="line">    (<span class="name">etypecase</span> e</span><br><span class="line">      (<span class="name">integer</span> e)</span><br><span class="line">      (<span class="name">symbol</span> (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"~A(%RIP)"</span> e)))))</span><br></pre></td></tr></table></figure><p>借助它重写<code>jjcc2</code>，结果如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(get-operand expr <span class="number">0</span>) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(get-operand expr <span class="number">1</span>) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(get-operand expr <span class="number">0</span>))))</span><br><span class="line">                 globals))))</span><br></pre></td></tr></table></figure><p>现在，如果运行下面的这个<code>example1</code>函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> example1 ()</span><br><span class="line">  <span class="string">"验证jjcc2确实可以处理含有变量的加减乘除运算"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">ht</span> (<span class="name">make-hash-table</span>)))</span><br><span class="line">    (<span class="name">setf</span> (<span class="name">gethash</span> 'a ht) <span class="number">1</span>)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">asm</span> (<span class="name">jjcc2</span> '(+ a a) ht)))</span><br><span class="line">      (<span class="name">stringify</span> asm ht))))</span><br></pre></td></tr></table></figure><p>便可以得到下面这段汇编代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">A: .long 1</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL A(%RIP), %EAX</span><br><span class="line">        MOVL A(%RIP), %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        movl %eax, %edi</span><br><span class="line">        movl $0x2000001, %eax</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://liutos.github.io/2019/06/01/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91setq%EF%BC%9F/&quot;&gt;上一篇文章&lt;/a&gt;中，&lt;code&gt;jjcc2&lt;/code&gt;函数实现了对&lt;code&gt;setq&lt;/code&gt;这个语句的编译。这么一来，便可以将加减乘除运算中的嵌套表达式都替换为变量了。比如，将&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;中的嵌套的表达式&lt;code&gt;(+ 1 2)&lt;/code&gt;用一个变量&lt;code&gt;G564&lt;/code&gt;代替，变成&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>如何编译setq？</title>
    <link href="https://liutos.github.io/2019/06/01/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91setq%EF%BC%9F/"/>
    <id>https://liutos.github.io/2019/06/01/如何编译setq？/</id>
    <published>2019-06-01T15:06:03.000Z</published>
    <updated>2019-06-01T15:08:46.041Z</updated>
    
    <content type="html"><![CDATA[<p>Common Lisp中的<code>setq</code>类似于其它语言中的赋值语句，它可以给一个符号对象设定一个值，类似于将一个值赋值给一个变量一样。简单起见，在<code>jjcc2</code>中，我会将所有的符号都作为全局的一个label来实现。也就是说，如果代码中出现了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> a <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这样的代码，那么在最后生成的代码中，就会相应的在<code>.data</code>段中有一个同名的label，其中存放着数值1。</p><p>既然都是全局变量，那么只需要准备一个容器来盛这些变量名即可。现阶段，暂时认为所有的变量都是数值类型即可。简单起见，这个容器直接用Common Lisp内置的<code>HASH-TABLE</code>来表示。</p><a id="more"></a><p>当在<code>jjcc2</code>函数中遭遇到<code>setq</code>这个符号时，整个表的形态是这样的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> var form)</span><br></pre></td></tr></table></figure><p>这时候，首先要将<code>var</code>放入到记录全局变量的哈希表中。然后，递归地调用<code>jjcc2</code>函数，先编译<code>form</code>，得到一系列的汇编代码。然后，生成一条<code>mov</code>语句，将<code>eax</code>寄存器中的内容放到<code>var</code>所指的内存位置中。最终的<code>jjcc2</code>的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span> globals)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr globals))))</span><br><span class="line">           result))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'setq)</span><br><span class="line">         <span class="comment">;; 编译赋值语句的方式比较简单，就是将被赋值的符号视为一个全局变量，然后将eax寄存器中的内容移动到这里面去</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">TODO:</span> 这里expr的second的结果必须是一个符号才行</span></span><br><span class="line">         <span class="comment">;; <span class="doctag">FIXME:</span> 不知道应该赋值什么比较好，先随便写个0吧</span></span><br><span class="line">         (<span class="name">setf</span> (<span class="name">gethash</span> (<span class="name">second</span> expr) globals) <span class="number">0</span>)</span><br><span class="line">         (<span class="name">values</span> (<span class="name">append</span> (<span class="name">jjcc2</span> (<span class="name">third</span> expr) globals)</span><br><span class="line">                         <span class="comment">;; 为了方便stringify函数的实现，这里直接构造出RIP-relative形式的字符串</span></span><br><span class="line">                         `((movl %eax ,(format <span class="literal">nil</span> <span class="string">"~A(%RIP)"</span> (second expr)))))</span><br><span class="line">                 globals))))</span><br></pre></td></tr></table></figure><p>然后还需要修改<code>stringify</code>函数，现在它需要处理传给<code>jjcc2</code>的全局变量的哈希表，将其转化为对应的<code>.data</code>段的声明。代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> stringify (<span class="name">asm</span> globals)</span><br><span class="line">  <span class="string">"根据jjcc2产生的S表达式生成汇编代码字符串"</span></span><br><span class="line">  (<span class="name">check-type</span> globals hash-table)</span><br><span class="line">  <span class="comment">;; 输出globals中的所有变量</span></span><br><span class="line">  <span class="comment">;; <span class="doctag">FIXME:</span> 暂时只支持输出数字</span></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .data~%"</span>)</span><br><span class="line">  (<span class="name">maphash</span> (<span class="name">lambda</span> (<span class="name">k</span> v)</span><br><span class="line">             (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A: .long ~D~%"</span> k v))</span><br><span class="line">           globals)</span><br><span class="line"></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .section __TEXT,__text,regular,pure_instructions~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .globl _main~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"_main:~%"</span>)</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">ins</span> asm)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">3</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A, ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">third</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">2</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">1</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A~%"</span> (<span class="name">first</span> ins)))))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        movl %eax, %edi~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        movl $0x2000001, %eax~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        syscall~%"</span>))</span><br></pre></td></tr></table></figure><p>弄了一个辅助的函数来方便将<code>jjcc2</code>和<code>stringify</code>串起来</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> test (<span class="name">expr</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">ht</span> (<span class="name">make-hash-table</span>)))</span><br><span class="line">    (<span class="name">multiple-value-bind</span> (<span class="name">asm</span> globals)</span><br><span class="line">        (<span class="name">jjcc2</span> expr ht)</span><br><span class="line">      (<span class="name">stringify</span> asm globals))))</span><br></pre></td></tr></table></figure><p>尝试在SLIME中运行</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">test</span> '(setq a (+ <span class="number">1</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>最后得到如下的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">A: .long 0</span><br><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EAX</span><br><span class="line">        MOVL $2, %EBX</span><br><span class="line">        ADDL %EBX, %EAX</span><br><span class="line">        MOVL %EAX, A(%RIP)</span><br><span class="line">        movl %eax, %edi</span><br><span class="line">        movl $0x2000001, %eax</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Common Lisp中的&lt;code&gt;setq&lt;/code&gt;类似于其它语言中的赋值语句，它可以给一个符号对象设定一个值，类似于将一个值赋值给一个变量一样。简单起见，在&lt;code&gt;jjcc2&lt;/code&gt;中，我会将所有的符号都作为全局的一个label来实现。也就是说，如果代码中出现了&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;setq&lt;/span&gt; a &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的代码，那么在最后生成的代码中，就会相应的在&lt;code&gt;.data&lt;/code&gt;段中有一个同名的label，其中存放着数值1。&lt;/p&gt;
&lt;p&gt;既然都是全局变量，那么只需要准备一个容器来盛这些变量名即可。现阶段，暂时认为所有的变量都是数值类型即可。简单起见，这个容器直接用Common Lisp内置的&lt;code&gt;HASH-TABLE&lt;/code&gt;来表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="setq" scheme="https://liutos.github.io/tags/setq/"/>
    
  </entry>
  
  <entry>
    <title>如何编译progn</title>
    <link href="https://liutos.github.io/2019/05/27/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91progn/"/>
    <id>https://liutos.github.io/2019/05/27/如何编译progn/</id>
    <published>2019-05-27T14:38:22.000Z</published>
    <updated>2019-05-27T14:41:00.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="progn是什么玩意"><a href="#progn是什么玩意" class="headerlink" title="progn是什么玩意"></a>progn是什么玩意</h2><p><code>progn</code>是Common Lisp里面的一个special operator，见这份文档的说明：<a href="http://clhs.lisp.se/Body/s_progn.htm" target="_blank" rel="noopener">http://clhs.lisp.se/Body/s_progn.htm</a></p><h2 id="为嘛要编译这东西"><a href="#为嘛要编译这东西" class="headerlink" title="为嘛要编译这东西"></a>为嘛要编译这东西</h2><p>现在已经支持了二元四则运算了，但现在这里有一个大问题，就是这四个运算没办法嵌套着组合使用。比如，遇到下面这样的代码，<code>jjcc2</code>函数就懵逼了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+</span> <span class="number">1</span> (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>那要编译这种代码的话怎么办呢？一个比较直观的做法，是引入临时变量，来保存嵌套在其中的表达式的求值结果，然后再用变量来代替原本嵌套的表达式。修改后的代码可能长这个样子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> a (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">+</span> <span class="number">1</span> a)</span><br></pre></td></tr></table></figure><p>显然，这是有先后的时间依赖关系的两条语句，因此应当使用<code>progn</code>将它们包裹起来，结果如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">progn</span></span><br><span class="line">  (<span class="name">setq</span> a (<span class="name">+</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">  (<span class="name">+</span> <span class="number">1</span> a))</span><br></pre></td></tr></table></figure><p>这样整个表达式的求值结果，或者说它被编译之后的运行结果，应当就是在寄存器<code>EAX</code>中放入整数6了。所以，本篇将来解决对<code>progn</code>的编译问题。</p><h2 id="如何编译progn"><a href="#如何编译progn" class="headerlink" title="如何编译progn"></a>如何编译progn</h2><a id="more"></a><p>其实很简单，<code>progn</code>可能有不定数量的form在其中，那么只需要按照顺序对它们一个个进行编译，输出汇编代码就可以了，因此最终<code>jjcc2</code>被修改为如下的样子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span>)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (idivl %ebx)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) 'progn)</span><br><span class="line">         (<span class="name">let</span> ((<span class="name">result</span> '()))</span><br><span class="line">           (<span class="name">dolist</span> (<span class="name">expr</span> (<span class="name">rest</span> expr))</span><br><span class="line">             (<span class="name">setf</span> result (<span class="name">append</span> result (<span class="name">jjcc2</span> expr))))</span><br><span class="line">           result))))</span><br></pre></td></tr></table></figure><p>就酱就足够了。下一篇，是时候讲一下如何编译<code>setq</code>了。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;progn是什么玩意&quot;&gt;&lt;a href=&quot;#progn是什么玩意&quot; class=&quot;headerlink&quot; title=&quot;progn是什么玩意&quot;&gt;&lt;/a&gt;progn是什么玩意&lt;/h2&gt;&lt;p&gt;&lt;code&gt;progn&lt;/code&gt;是Common Lisp里面的一个special operator，见这份文档的说明：&lt;a href=&quot;http://clhs.lisp.se/Body/s_progn.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://clhs.lisp.se/Body/s_progn.htm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为嘛要编译这东西&quot;&gt;&lt;a href=&quot;#为嘛要编译这东西&quot; class=&quot;headerlink&quot; title=&quot;为嘛要编译这东西&quot;&gt;&lt;/a&gt;为嘛要编译这东西&lt;/h2&gt;&lt;p&gt;现在已经支持了二元四则运算了，但现在这里有一个大问题，就是这四个运算没办法嵌套着组合使用。比如，遇到下面这样的代码，&lt;code&gt;jjcc2&lt;/code&gt;函数就懵逼了&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那要编译这种代码的话怎么办呢？一个比较直观的做法，是引入临时变量，来保存嵌套在其中的表达式的求值结果，然后再用变量来代替原本嵌套的表达式。修改后的代码可能长这个样子&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;setq&lt;/span&gt; a (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;显然，这是有先后的时间依赖关系的两条语句，因此应当使用&lt;code&gt;progn&lt;/code&gt;将它们包裹起来，结果如下&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;progn&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;setq&lt;/span&gt; a (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; a))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样整个表达式的求值结果，或者说它被编译之后的运行结果，应当就是在寄存器&lt;code&gt;EAX&lt;/code&gt;中放入整数6了。所以，本篇将来解决对&lt;code&gt;progn&lt;/code&gt;的编译问题。&lt;/p&gt;
&lt;h2 id=&quot;如何编译progn&quot;&gt;&lt;a href=&quot;#如何编译progn&quot; class=&quot;headerlink&quot; title=&quot;如何编译progn&quot;&gt;&lt;/a&gt;如何编译progn&lt;/h2&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="progn" scheme="https://liutos.github.io/tags/progn/"/>
    
  </entry>
  
  <entry>
    <title>支持减、乘，以及除</title>
    <link href="https://liutos.github.io/2019/05/23/%E6%94%AF%E6%8C%81%E5%87%8F%E3%80%81%E4%B9%98%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%99%A4/"/>
    <id>https://liutos.github.io/2019/05/23/支持减、乘，以及除/</id>
    <published>2019-05-23T13:50:19.000Z</published>
    <updated>2019-05-23T13:56:18.661Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://liutos.github.io/2019/05/17/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/">上一篇文章</a>中，初步搭建了一个输入Common Lisp代码，输出汇编代码的编译器的骨架，实现了二元整数的加法运算。在这个基础上，要想实现减法、乘法，以及除法就是手到擒来的事情了。只需依葫芦画瓢，补充更多的分支情况即可。</p><p>我自己模仿着x64的调用约定，规定四则运算的结果始终放在<code>EAX</code>这个寄存器中。在稍后给出的代码中，对于减法和除法运算，都是把运算符的左操作数放到<code>EAX</code>寄存器中，再从<code>EAX</code>中减去或者除掉右操作数。</p><p>在摸索除法的汇编代码怎么生成时，遇到了个费解的问题，最后才知道，原来需要把<code>EAX</code>寄存器的符号扩展到高位的<code>EDX</code>寄存器中去。对于<code>as</code>这个汇编器来说，需要用到<a href="https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-49/index.html" target="_blank" rel="noopener"><code>CLTD</code></a>指令。</p><p>最后，<code>jjcc2</code>和<code>stringify</code>两个函数被修改为如下的样子</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span>)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (addl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '-)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (subl %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '*)</span><br><span class="line">         <span class="comment">;; 将两个数字相乘的结果放到第二个操作数所在的寄存器中</span></span><br><span class="line">         <span class="comment">;; 因为约定了用EAX寄存器作为存放最终结果给continuation用的寄存器，所以第二个操作数应当为EAX</span></span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (imull %ebx %eax)))</span><br><span class="line">        ((<span class="name">eq</span> (<span class="name">first</span> expr) '/)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (cltd)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (idivl %ebx)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> stringify (<span class="name">asm</span>)</span><br><span class="line">  <span class="string">"根据jjcc2产生的S表达式生成汇编代码字符串"</span></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .section __TEXT,__text,regular,pure_instructions~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .globl _main~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"_main:~%"</span>)</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">ins</span> asm)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">3</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A, ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">third</span> ins))</span><br><span class="line">                       (<span class="name">third</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">2</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A~%"</span></span><br><span class="line">                   (<span class="name">first</span> ins)</span><br><span class="line">                   (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                       (<span class="name">second</span> ins))))</span><br><span class="line">          ((<span class="name">=</span> (<span class="name">length</span> ins) <span class="number">1</span>)</span><br><span class="line">           (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A~%"</span> (<span class="name">first</span> ins)))))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        movl %eax, %edi~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        movl $0x2000001, %eax~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        syscall~%"</span>))</span><br></pre></td></tr></table></figure><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://liutos.github.io/2019/05/17/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/&quot;&gt;上一篇文章&lt;/a&gt;中，初步搭建了一个输入Common Lisp代码，输出汇编代码的编译器的骨架，实现了二元整数的加法运算。在这个基础上，要想实现减法、乘法，以及除法就是手到擒来的事情了。只需依葫芦画瓢，补充更多的分支情况即可。&lt;/p&gt;
&lt;p&gt;我自己模仿着x64的调用约定，规定四则运算的结果始终放在&lt;code&gt;EAX&lt;/code&gt;这个寄存器中。在稍后给出的代码中，对于减法和除法运算，都是把运算符的左操作数放到&lt;code&gt;EAX&lt;/code&gt;寄存器中，再从&lt;code&gt;EAX&lt;/code&gt;中减去或者除掉右操作数。&lt;/p&gt;
&lt;p&gt;在摸索除法的汇编代码怎么生成时，遇到了个费解的问题，最后才知道，原来需要把&lt;code&gt;EAX&lt;/code&gt;寄存器的符号扩展到高位的&lt;code&gt;EDX&lt;/code&gt;寄存器中去。对于&lt;code&gt;as&lt;/code&gt;这个汇编器来说，需要用到&lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-49/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;CLTD&lt;/code&gt;&lt;/a&gt;指令。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;jjcc2&lt;/code&gt;和&lt;code&gt;stringify&lt;/code&gt;两个函数被修改为如下的样子&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Evernote与Leanote</title>
    <link href="https://liutos.github.io/2019/05/21/Evernote%E4%B8%8ELeanote/"/>
    <id>https://liutos.github.io/2019/05/21/Evernote与Leanote/</id>
    <published>2019-05-21T14:38:19.000Z</published>
    <updated>2019-05-21T14:40:13.579Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始重新用起了Evernote，当然还有Leanote，不过不算是“重新“而已。这两者各有各的优缺点，下面分别列举一下</p><h2 id="Evernote的优缺点以及和Leanote的对比"><a href="#Evernote的优缺点以及和Leanote的对比" class="headerlink" title="Evernote的优缺点以及和Leanote的对比"></a>Evernote的优缺点以及和Leanote的对比</h2><p>Evernote可以比较灵活地调整文字的字号，如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Evernote%E4%B8%AD%E7%9A%84%E5%AD%97%E5%8F%B7%E9%80%89%E6%8B%A9.png" alt="image-20190515124117460"></p><a id="more"></a><p>在Leanote中只能选择固定的几种字号，如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Leanote%E7%9A%84%E5%AD%97%E5%8F%B7%E9%80%89%E6%8B%A9.png" alt="Leanote的字号选择"></p><p>Evernote的方式灵活性更高，但从我自身的写作习惯看来，其实不会用到那么多层级的字号。而且，由于Evernote的字号是随意调整的，不像Leanote那般具备语义，所以也不利于生成目录。在Leanote中设置了标题后，便可以在浏览模式下看到导航栏了，如下所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%AF%BC%E8%88%AA%E6%9D%A1.png" alt="导航条"></p><p>Evernote的搜索功能比Leanote强大很多。我在Leanote写了这么一个笔记</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/git%E7%9A%84%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE.png" alt="git的笔记截图"></p><p>然后我在Leanote的搜索框中输入“git 中文”，是搜不到任何东西的。但如果是同样的内容放到Evernote中，再进行搜索，就可以得到自己想要的结果</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD.png" alt="搜索功能"></p><p>而且配合Evernote的浏览器插件，还可以做到在搜索引擎中搜索的同时，将笔记中匹配的内容也展示出来，如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E4%BD%BF%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%90%8C%E6%97%B6%E6%90%9C%E7%B4%A2%E7%AC%94%E8%AE%B0.jpeg" alt="使用搜索引擎的同时搜索笔记"></p><p>在Evernote中使用Emacs的键绑定更方便。在Leanote中其实也可以，无非就是按下ctrl+f前进，按下ctrl+b后退，按下ctrl+n下一行，按下ctrl+p上一行。但是有一个我个人比较习惯的快捷键，就是按下ctrl+e去到行尾，但这个与Leanote的默认快捷键冲突了，所以没法用。</p><p>Evernote中的表格编辑功能更友好更方便，将鼠标放到表格上时，就可以看到直截了当的新增一行的功能，如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E8%A1%A8%E6%A0%BC%E6%96%B0%E5%A2%9E%E4%B8%80%E8%A1%8C.png" alt="表格新增一行"></p><p>相比之下，Leanote中如果要给表格新增一行，需要点击右上角，然后再深入两级菜单后才能找到一个Insert row after的功能</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C.jpeg" alt="表格操作"></p><p>而且如果你不仅仅是要新增一行，那就必须不填地点出这个菜单来操作，可麻烦了。</p><p>Evernote只支持两层的笔记组织形式，也就是一个笔记本，然后笔记本之下就是各自独立的笔记内容了。而Leanote则支持更深的层级，比如下图就是三个目录</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7.png" alt="目录层级"></p><p>当我Leanote中粘贴图片的时候，总是会一次贴入两张，这个问题倒是挺烦人的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始重新用起了Evernote，当然还有Leanote，不过不算是“重新“而已。这两者各有各的优缺点，下面分别列举一下&lt;/p&gt;
&lt;h2 id=&quot;Evernote的优缺点以及和Leanote的对比&quot;&gt;&lt;a href=&quot;#Evernote的优缺点以及和Leanote的对比&quot; class=&quot;headerlink&quot; title=&quot;Evernote的优缺点以及和Leanote的对比&quot;&gt;&lt;/a&gt;Evernote的优缺点以及和Leanote的对比&lt;/h2&gt;&lt;p&gt;Evernote可以比较灵活地调整文字的字号，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Evernote%E4%B8%AD%E7%9A%84%E5%AD%97%E5%8F%B7%E9%80%89%E6%8B%A9.png&quot; alt=&quot;image-20190515124117460&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="https://liutos.github.io/tags/markdown/"/>
    
      <category term="note taking" scheme="https://liutos.github.io/tags/note-taking/"/>
    
      <category term="evernote" scheme="https://liutos.github.io/tags/evernote/"/>
    
      <category term="leanote" scheme="https://liutos.github.io/tags/leanote/"/>
    
  </entry>
  
  <entry>
    <title>一个简陋的四则运算编译器实现</title>
    <link href="https://liutos.github.io/2019/05/17/%E4%B8%80%E4%B8%AA%E7%AE%80%E9%99%8B%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>https://liutos.github.io/2019/05/17/一个简陋的四则运算编译器实现/</id>
    <published>2019-05-17T13:57:50.000Z</published>
    <updated>2019-05-17T14:03:01.321Z</updated>
    
    <content type="html"><![CDATA[<p>本文很水。</p><p>有一天，我心血来潮想要写一个将Common Lisp编译成汇编（x64那种）的编译器。我喜欢Common Lisp这门语言，它非常好玩，有许多有趣的特性（宏、condition system等），并且它的生态很贫瘠，有很多造轮子的机会。因为我懂的还不够多，所以没法从源代码一步到位生成可执行文件，只好先输出汇编代码，再利用现成的汇编器（比如as、nasm）从这些输出内容生成可执行文件。至于这东西是不是真的算是编译器，我也不是很在意。</p><p>好了，我要开始表演了。</p><a id="more"></a><p>你可能看过<a href="https://book.douban.com/subject/3296317/" target="_blank" rel="noopener">龙书</a>，或者其它比较经典的编译原理和实践方面的书。那你应该会知道，编译器还蛮复杂的。但我水平有限，把持不住工业级的产品那么精妙的结构和代码，所以我的编译器很简陋——简陋到起码这个版本一眼就看到尽头了。</p><p>尽管简陋，但身为一名业余爱好者，尝试开发这么一个玩具还是很excited的。由于编译器本身也是用Common Lisp写的，所以就偷个懒不写front end的部分了，聚焦于从CL代码到汇编代码的实现。</p><p>先从最简单的一种情况——二元整数的加法入手，比如下面这段代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">+</span> <span class="number">1</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>对于加法，可以输出<code>ADDL</code>指令，两个参数则随便找两个寄存器放进去就好了。一段简单得不能再简单的代码一下子就写出来了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> jjcc2 (<span class="name">expr</span>)</span><br><span class="line">  <span class="string">"支持两个数的四则运算的编译器"</span></span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">eq</span> (<span class="name">first</span> expr) '+)</span><br><span class="line">         `((movl ,(second expr) %eax)</span><br><span class="line">           (movl ,(third expr) %ebx)</span><br><span class="line">           (addl %eax %ebx)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> stringify (<span class="name">asm</span>)</span><br><span class="line">  <span class="string">"根据jjcc2产生的S表达式生成汇编代码字符串"</span></span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .section __TEXT,__text,regular,pure_instructions~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        .globl _main~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"_main:~%"</span>)</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">ins</span> asm)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        ~A ~A, ~A~%"</span></span><br><span class="line">            (<span class="name">first</span> ins)</span><br><span class="line">            (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">second</span> ins))</span><br><span class="line">                (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">second</span> ins))</span><br><span class="line">                (<span class="name">second</span> ins))</span><br><span class="line">            (<span class="name">if</span> (<span class="name">numberp</span> (<span class="name">third</span> ins))</span><br><span class="line">                (<span class="name">format</span> <span class="literal">nil</span> <span class="string">"$~A"</span> (<span class="name">third</span> ins))</span><br><span class="line">                (<span class="name">third</span> ins))))</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        movl %ebx, %edi~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        movl $0x2000001, %eax~%"</span>)</span><br><span class="line">  (<span class="name">format</span> <span class="literal">t</span> <span class="string">"        syscall~%"</span>))</span><br></pre></td></tr></table></figure><p>在 REPL 中像下面这样运行</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">stringify</span> (<span class="name">jjcc2</span> '(+ <span class="number">1</span> <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>它会输出这些内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        .section __TEXT,__text,regular,pure_instructions</span><br><span class="line">        .globl _main</span><br><span class="line">_main:</span><br><span class="line">        MOVL $1, %EAX</span><br><span class="line">        MOVL $2, %EBX</span><br><span class="line">        ADDL %EAX, %EBX</span><br><span class="line">        movl %ebx, %edi</span><br><span class="line">        movl $0x2000001, %eax</span><br><span class="line">        syscall</span><br></pre></td></tr></table></figure><p>把上面这段汇编代码保存到名为 jjcc.s 的文件，再运行下列的命令，就可以得到一个能跑的 a.out 文件了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as -o jjcc.o jjcc.s</span><br><span class="line">gcc jjcc.o</span><br></pre></td></tr></table></figure><p>运行之后，再输出上一个命令的退出码，就可以看到结果3了。</p><p><code>.section</code>那一行太长，其实可以用<code>.text</code>来代替；指令和寄存器的名字大小写混用；<code>stringify</code>函数中对第二第三个操作数的处理代码很冗余，等等，都是可以吐槽的问题XD</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文很水。&lt;/p&gt;
&lt;p&gt;有一天，我心血来潮想要写一个将Common Lisp编译成汇编（x64那种）的编译器。我喜欢Common Lisp这门语言，它非常好玩，有许多有趣的特性（宏、condition system等），并且它的生态很贫瘠，有很多造轮子的机会。因为我懂的还不够多，所以没法从源代码一步到位生成可执行文件，只好先输出汇编代码，再利用现成的汇编器（比如as、nasm）从这些输出内容生成可执行文件。至于这东西是不是真的算是编译器，我也不是很在意。&lt;/p&gt;
&lt;p&gt;好了，我要开始表演了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="assembly" scheme="https://liutos.github.io/tags/assembly/"/>
    
      <category term="compiler" scheme="https://liutos.github.io/tags/compiler/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="x64" scheme="https://liutos.github.io/tags/x64/"/>
    
      <category term="汇编" scheme="https://liutos.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="编译器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Boostnote及对记笔记的思考</title>
    <link href="https://liutos.github.io/2019/05/07/Boostnote%E5%8F%8A%E5%AF%B9%E8%AE%B0%E7%AC%94%E8%AE%B0%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://liutos.github.io/2019/05/07/Boostnote及对记笔记的思考/</id>
    <published>2019-05-07T15:06:43.000Z</published>
    <updated>2019-05-14T14:57:51.860Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章就是在<a href="https://boostnote.io/" target="_blank" rel="noopener">Boostnote</a> 中写成的XD</p><h2 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h2><p>有一阵子，我沉迷于“笔记软件狩猎”中——就是不停寻找各种各样的笔记软件，再一个个试用，企图从中选出一个最强大的。回想起来，我尝试过有道云笔记、印象笔记、Quiver、Boostnote、OneNote、Yu Writer、Leanote（在本地搭建），等等。大部分都是浅尝辄止，例如OneNote，当我发现它不支持代码块语法高亮时，就放弃了它。目前仍然在使用的是Boostnote，并且也是最令我满意的。</p><a id="more"></a><h2 id="走马观花"><a href="#走马观花" class="headerlink" title="走马观花"></a>走马观花</h2><p>Boostnote自诩为“for developer”的笔记软件，除了书写Markdown以及实时预览之外，还支持绘图（UML、流程图、时序图）、制表，甚至可以添加LaTeX公式。</p><p>GitHub上可以找到官方对Boostnote绘图能力的简单<a href="https://github.com/BoostIO/Boostnote/wiki/Diagram-support" target="_blank" rel="noopener">示例</a>，但我用得极少。不管是画UML、流程图，还是时序图，方法都是“写代码”。画UML用的是PlantUML的语法（你甚至可以在首选项中找到PlantUML服务器的地址），画流程图用的是<a href="http://flowchart.js.org/" target="_blank" rel="noopener">flowchart.js</a>的语法。我自己很喜欢这类语绘的方式，只需要熟悉一下语法，画起来图来比鼠标拖拖拉拉不知道要高到哪里去了。说到时序图，我更喜欢用<a href="http://sdedit.sourceforge.net/example/index.html" target="_blank" rel="noopener">sdedit</a>。</p><p>制表只需要敲入竖线和横线即可。例如，下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|这|是|一|</span><br><span class="line">|-|-|-|</span><br><span class="line">|个|表|格|</span><br></pre></td></tr></table></figure><p>在Boostnote中预览时的效果是如下这样的</p><table><thead><tr><th>这</th><th>是</th><th>一</th></tr></thead><tbody><tr><td>个</td><td>表</td><td>格</td></tr></tbody></table><p>制表在Emacs的<a href="https://orgmode.org/manual/Built_002din-table-editor.html#Built_002din-table-editor" target="_blank" rel="noopener">org-mode</a>中有更风骚的表现。比如，按下tab键可以让光标跳至下一个单元格，同时会自动调整每一列的宽度；甚至，还可以在单元格中使用公式。</p><p>既然可以嵌入LaTeX，那么下列的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ \LaTeX $$</span><br></pre></td></tr></table></figure><p>就能够用来绘制酷炫版的LaTeX logo了，如下所示</p><p>$$ \LaTeX $$</p><p>只可惜这玩意儿不是inline的。</p><p>Markdown这门标记语言原本也支持代码块，但稍微现代的编辑器都应当至少支持语法高亮才行。在Boostnote中即便不进行预览，代码块中的代码也是彩色的。</p><p>Boostnote自动保存笔记内容，这点上每个人的口味可能还是不太一样的。</p><h2 id="槽点"><a href="#槽点" class="headerlink" title="槽点"></a>槽点</h2><p>尽管可以将剪贴板中的图片粘贴到Boostnote的笔记中，却不能将图片复制到剪贴板中。唯一的办法，就是在粘贴了图片后，按照笔记中的文件路径，在Finder中找到这个文件，然后再复制。</p><p>不像Yu Writer和Typora，Boostnote既不支持目录也不支持大纲模式。如果用来写篇幅很长的文章，并且需要频繁在相距比较远的章节之间切换的话，会写得比较辛苦。但也可以认为，Markdown，或者说Boostnote这样的笔记软件，本来也不适合写作大型文档。遇到这种事情，还是应当出动字处理软件（比如Word）或者TeX。</p><p>Boostnote没有将笔记的内容以朴素的Markdown形式保存为一个.md文件，而是存储成后缀名为.cson的文件格式。这意味着，即便哪一天有一款完美的Markdown编辑器出现了，也无法在其中查看和编辑这些Boostnote生成的文档。</p><h2 id="一些胡言乱语"><a href="#一些胡言乱语" class="headerlink" title="一些胡言乱语"></a>一些胡言乱语</h2><ul><li>记笔记的目的是什么？</li><li>我对笔记软件的要求是什么？</li><li>Boostnote是最合适的吗？它又适合做什么呢？</li></ul><p>我不是从入手了Mac之后才开始记笔记的，在此之前，我用Emacs的org-mode来记笔记，但也许称其为FAQ更恰当。使用org-mode，写作方式、浏览方式，以及载体都是一致的——用org-mode的语法来写作，同时写下的也就是所看到的（org-mode没有预览一说），最后，存储的也是纯粹的、敲入的文本。但用org-mode来记笔记也有自己的缺陷：</p><ul><li>在Emacs中浏览的体验不是非常好</li><li>不方便使用行内的代码块</li><li>其它编辑器对.org格式的支持不好</li><li>不方便粘贴图片</li></ul><p>因此，才打算构筑新的笔记系统。但新的笔记系统应当不仅仅可以解决org-mode遇到的问题，而是应该贴合我的核心需求才行。我自己曾经总结过，笔记软件应该满足如下的要求：</p><ul><li>支持Markdown，它是一门我所熟悉的、轻量级的标记语言，也被众多的软件支持</li><li>支持编程语言的语法高亮，毕竟是软件开发方面的笔记，总会涉及到代码的</li><li>以.md文件的形式存储。这个一会儿再聊聊</li><li>支持树形的文件层级结构，因为我可能会给笔记划分比较多的层级，但这个也值得一会儿聊聊</li><li>支持Emacs的keymap，这是我所熟悉的操作方式，减少手离开键盘的次数</li></ul><p>看下来更像是在物色一款好用的Markdown文件编辑器。但一款优秀的Markdown文件编辑器就会是一款优秀的笔记软件吗？我看未必。</p><p>实际上，对代码的语法高亮的要求，暴露了一个关键因素，就是：即便我写入的是Markdown代码，也希望能够以渲染后的效果展示出来。所以，为什么不直接使用富文本来书写笔记内容。如果是富文本的编辑器，那么一般便不会是以朴素的.md文件的格式来存储的了，但这并没有什么太值得在意的，毕竟谁也不会闲着没事就将笔记内容在各个软件间迁移着玩。</p><p>如果是一些可以公开的笔记，那么直接记录到博客中也不失为一个好办法——博客可以被搜索引擎索引，之后如果想要查找记录过的内容的话，也可以借助于搜索引擎强大的搜索能力来实现。不过，现阶段，我更喜欢这些笔记是私密的。</p><p>我的笔记也几乎不会与他人分享，因此不管是书写格式还是存储格式，都只需要我自己用着开心就足够了。大多数情况下，笔记的用途其实是代码片段，在需要的时候能够复制出来略作修改，用到其它地方——例如粘贴到shell中运行，解决一些临时的问题。如果不是因为我喜欢记下最终结果的来龙去脉的话，Boostnote的代码片段功能也许才是最适合我的选择。另外，由于大部分的代码都非常地短，即便没有语法高亮浏览器来也不是大问题，所以语法高亮的需要也就不那么迫切了。</p><p>现在看来，Boostnote并不是最合适的（打脸了）。Evernote和Leanote是我用过的笔记软件中比较强有力的两个竞争者。由于Leanote比Evernote支持更多的目录层级，并且还可以选择创建Markdown笔记（而不仅仅是富文本笔记），所以我大概会选择用Leanote来作为接下来的笔记软件的主力吧。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>用Typora来写，用ElasticSearch来索引笔记，好像也不错？！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章就是在&lt;a href=&quot;https://boostnote.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Boostnote&lt;/a&gt; 中写成的XD&lt;/p&gt;
&lt;h2 id=&quot;来龙去脉&quot;&gt;&lt;a href=&quot;#来龙去脉&quot; class=&quot;headerlink&quot; title=&quot;来龙去脉&quot;&gt;&lt;/a&gt;来龙去脉&lt;/h2&gt;&lt;p&gt;有一阵子，我沉迷于“笔记软件狩猎”中——就是不停寻找各种各样的笔记软件，再一个个试用，企图从中选出一个最强大的。回想起来，我尝试过有道云笔记、印象笔记、Quiver、Boostnote、OneNote、Yu Writer、Leanote（在本地搭建），等等。大部分都是浅尝辄止，例如OneNote，当我发现它不支持代码块语法高亮时，就放弃了它。目前仍然在使用的是Boostnote，并且也是最令我满意的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="boostnote" scheme="https://liutos.github.io/tags/boostnote/"/>
    
      <category term="editor" scheme="https://liutos.github.io/tags/editor/"/>
    
      <category term="markdown" scheme="https://liutos.github.io/tags/markdown/"/>
    
      <category term="note taking" scheme="https://liutos.github.io/tags/note-taking/"/>
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="sequence diagram" scheme="https://liutos.github.io/tags/sequence-diagram/"/>
    
      <category term="typora" scheme="https://liutos.github.io/tags/typora/"/>
    
      <category term="yu writer" scheme="https://liutos.github.io/tags/yu-writer/"/>
    
      <category term="笔记类软件" scheme="https://liutos.github.io/tags/%E7%AC%94%E8%AE%B0%E7%B1%BB%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="编辑器" scheme="https://liutos.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>更过程式的let——vertical-let</title>
    <link href="https://liutos.github.io/2019/03/13/%E6%9B%B4%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%9A%84let%E2%80%94%E2%80%94vertical-let/"/>
    <id>https://liutos.github.io/2019/03/13/更过程式的let——vertical-let/</id>
    <published>2019-03-13T15:02:59.000Z</published>
    <updated>2019-03-13T15:04:17.548Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名自诩的non-trivial的Common Lisp程序员，在编码的时候经常会遇到令人不愉快的地方，其中一个便是<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm#let" target="_blank" rel="noopener">LET</a>。</p><p>一段典型的<code>LET</code>的示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> <span class="number">1</span>))</span><br><span class="line">   a)</span><br></pre></td></tr></table></figure><p>大多数时候，<code>LET</code>不会只有一个绑定。并且，也不会只是绑定一个常量这么简单，而应当是下面这样的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> (<span class="name">foo</span> x y))</span><br><span class="line">      (<span class="name">b</span> (<span class="name">bar</span> z)))</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>有时候我会想看看某一个绑定的值——最好是在它计算完毕后立即查看。如果要查看<code>foo</code>函数的返回值，可以这样写</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> (<span class="name">foo</span> x y))</span><br><span class="line">      (<span class="name">b</span> (<span class="name">bar</span> z)))</span><br><span class="line">  (<span class="name">print</span> a)</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>如果调用<code>foo</code>和<code>bar</code>都顺利的话上面的代码也就够了。比较棘手的情况是，如果<code>a</code>的值不符合预期，会导致<code>b</code>的计算过程出状况（尽管在上面的代码中看似不会）。这种情况多出现在<code>LET*</code>的使用中，如下面所示</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">a</span> (<span class="name">foo</span> x y))</span><br><span class="line">       (<span class="name">b</span> (<span class="name">bar</span> a)))</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>如果错误的<code>a</code>会导致<code>bar</code>的调用出错，那么在调用<code>function1</code>之前才调用<code>print</code>打印<code>a</code>已经为时过晚了——毕竟调用<code>bar</code>的时候就抛出<code>condition</code>往调用链的上游走了。一种方法是写成下面这样子</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">a</span> (<span class="name">let</span> ((<span class="name">tmp</span> (<span class="name">foo</span> x y)))</span><br><span class="line">            (<span class="name">print</span> tmp)</span><br><span class="line">            tmp))</span><br><span class="line">       (<span class="name">b</span> (<span class="name">bar</span> a)))</span><br><span class="line">  (<span class="name">function1</span> a b)</span><br><span class="line">  (<span class="name">function2</span> a b))</span><br></pre></td></tr></table></figure><p>这也太丑了！要不然写成下面这样子？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">a</span> (<span class="name">foo</span> x y)))</span><br><span class="line">  (<span class="name">print</span> a)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">b</span> (<span class="name">bar</span> a)))</span><br><span class="line">    (<span class="name">function1</span> a b)</span><br><span class="line">    (<span class="name">function2</span> a b)))</span><br></pre></td></tr></table></figure><p>本来一个<code>LET</code>就可以做到的事情，这下子用了两个，还导致缩进更深了一级。如果有十个变量需要打印，就会增加十个<code>LET</code>和十层缩进。如果心血来潮想查看一个变量的值，还要大幅调整代码。</p><p>问题大概就出在<code>LET</code>和<code>LET*</code>的语法上。以<code>LET</code>为例，它由截然分开的<code>bindings</code>和<code>forms</code>组成，两者不能互相穿插。因此，如果想在<code>bindings</code>中求值一段表达式，只能将<code>bindings</code>切开，写成两个<code>LET</code>的形式。好像写一个新的宏可以解决这个问题？是的，<code>vertical-let</code>就是。</p><p><code>vertical-let</code>是一个我自己写的宏，源代码<a href="https://github.com/Liutos/clitool/blob/master/cl/sak.lisp#L9" target="_blank" rel="noopener">在此</a>。其用法如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line">  <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line">  a)</span><br></pre></td></tr></table></figure><p>它借鉴了<code>LOOP</code>中绑定变量的方式（即<code>:with</code>和<code>=</code>），绑定变量和用于求值的代码还可以交织在一起，如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line">  <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line">  (<span class="name">print</span> a)</span><br><span class="line">  <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line">  (<span class="name">+</span> a b))</span><br></pre></td></tr></table></figure><p><code>vertical-let</code>最终会展开为<code>LET</code>，比如上面的代码，会展开为如下的代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">LET</span> ((<span class="name">A</span> <span class="number">1</span>))</span><br><span class="line">  (<span class="name">PRINT</span> A)</span><br><span class="line">  (<span class="name">LET</span> ((<span class="name">B</span> <span class="number">2</span>))</span><br><span class="line">    (<span class="name">+</span> A B)))</span><br></pre></td></tr></table></figure><p><code>vertical-let</code>的算法很简单。它遍历表达式列表，当遇到<code>:with</code>时就把接下来的三个元素分别视为变量名、等号，以及待求值的表达式，将三者打包进一个列表中，再压栈；当遇到其它值时，就视为待求值的表达式（将会组成<code>LET</code>的<code>forms</code>部分），也放进列表中再压栈（具体方法参见源代码）。</p><p>将所有值都遍历并压栈后，接下来要遍历这个栈中的元素。先准备两个空的栈——一个存放<code>bindings</code>，一个存放<code>forms</code>。接着，对于每一个从栈中弹出的元素，分为如下两种情况：</p><ol><li>如果表示<code>binding</code>，则直接压入存放<code>bindings</code>的栈，否则；</li><li>如果是待求值的表达式，并且上一个出栈的元素是<code>binding</code>，则说明已经有一段完整的<code>LET</code>的内容被集齐。因此，将目前在两个栈中的内容全部弹出，组合为一个<code>LET</code>表达式再压入存放<code>forms</code>的栈中。然后将方才弹出的表达式也压入<code>forms</code>。重复上述过程直至所有元素都被处理，最后将还在两个栈中的内容也组合为一个<code>LET</code>表达式便结束了。</li></ol><p>全文完</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="common lisp" scheme="https://liutos.github.io/tags/common-lisp/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="macro" scheme="https://liutos.github.io/tags/macro/"/>
    
      <category term="宏" scheme="https://liutos.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>不同工具查看代码分支diff的差异</title>
    <link href="https://liutos.github.io/2019/02/28/%E4%B8%8D%E5%90%8C%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AFdiff%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <id>https://liutos.github.io/2019/02/28/不同工具查看代码分支diff的差异/</id>
    <published>2019-02-28T14:53:46.000Z</published>
    <updated>2019-02-28T14:55:46.131Z</updated>
    
    <content type="html"><![CDATA[<p>本文只是简单地讲述我自己在使用<a href="https://www.gnu.org/software/emacs/index.html" target="_blank" rel="noopener">GNU Emacs</a>、<a href="https://git-fork.com/" target="_blank" rel="noopener">Fork</a>，以及<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>查看Git仓库的不同分支的diff上的经历。</p><h2 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h2><p>当使用Emacs时，我更喜欢用<code>M-x package-install</code>安装的<a href="https://github.com/magit/magit" target="_blank" rel="noopener"><code>magit</code></a>提供的功能——<code>magit-diff</code>，而不是它自带的<code>vc-dir</code>。按下<code>M-x</code>，输入<code>magit-diff</code>并敲下回车后，Emacs会在minibuffer中等待用户输入要比较的分支。就像在shell中使用<code>git-diff</code>一样，只需要输入两个以<code>..</code>连接的分支名并敲下回车，就可以列出它们间的差异。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E4%BD%BF%E7%94%A8magit-diff%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%AE%E5%BC%82.png" alt=""></p><p>上图是master与re两个分支间的差异。<code>magit-diff</code>会列出两个分支间不一致的文件，与直接使用<code>git-diff</code>命令没有不同。往下滚动跨过文件清单后，还可以查看单个文件的差异。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/magit-diff%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E6%97%B6%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82.png" alt=""></p><h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>第一次知道Fork是在知乎闲逛的时候，好像是在浏览“Mac下有什么值得推荐的软件”这类问题时看到的。某一次，为了能直观地查看两个commit间的差异，便试用了一番，效果确实不错。Fork的界面如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Fork%E7%9A%84%E7%95%8C%E9%9D%A2%E6%A6%82%E8%A7%88.png" alt=""></p><p>还记得，当时为了能够比较两个commit间的差异，我还在Fork的菜单栏中翻了很久——虽然是毫无收获。结果发现，原来只需要选中两个commit就可以了。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/Fork%E4%B8%AD%E5%AF%B9%E6%AF%94%E4%B8%A4%E4%B8%AAcommit%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82.png" alt=""></p><p>图片两行蓝色的就是我选中的两个commit——先用鼠标点击其一，按住<code>control</code>键后再选中另一个即可。图片下方的部分与<code>magit-diff</code>差不多，应该也算是一目了然了。</p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>原本我觉得Fork已经足够好了，某一天在用VSCode时才忽然发现，在Fork中显示的代码差异，是没有语法高亮的。通常来说，即使没有语法高亮，查看短小的diff也不成问题。但如果差异的内容很多，或是diff位于一个很长的函数内部，这时光靠diff来做代码审查已经不太够了——因为不好确定在这片diff中出现的变量和函数，到底是不是正确地定义了的。</p><p>后来我发现，VSCode自带的“源代码管理”，即便是在查看diff时也是有语法高亮的——不仅有语法高亮，对于Node.js代码而言，还有ESLint的提示和“跳转到定义”的功能，awesome！不愧是全宇宙最好用的编辑器（笑</p><p>为了可以用VSCode来查看两个分支间的差异，放狗搜了一下，找到了神器<a href="https://github.com/eamodio/vscode-gitlens" target="_blank" rel="noopener">GitLens</a>。</p><p>安装GitLens后，VSCode的最左侧会多出一个菜单项，在其中可以方便地选择两个分支来进行比较。首先，找到一个要比较的分支，选择“Select for Compare”。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%9C%A8GitLens%E4%B8%AD%E9%80%89%E4%B8%AD%E8%A6%81%E6%AF%94%E8%BE%83%E7%9A%84%E5%88%86%E6%94%AF.png" alt=""></p><p>再选中另一个要比较的分支，右键单击选择“Compare with Selected”，然后便可以在下方看到VSCode罗列出不一致的文件清单了。如下图所示</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/%E5%9C%A8GitLens%E4%B8%AD%E9%80%89%E4%B8%AD%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A6%81%E6%AF%94%E8%BE%83%E7%9A%84%E5%88%86%E6%94%AF.png" alt=""></p><p>VSCode是最吼的！</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="visual studio code" scheme="https://liutos.github.io/tags/visual-studio-code/"/>
    
  </entry>
  
  <entry>
    <title>拿Emacs对接我的cuckoo</title>
    <link href="https://liutos.github.io/2019/02/05/%E6%8B%BFEmacs%E5%AF%B9%E6%8E%A5%E6%88%91%E7%9A%84cuckoo/"/>
    <id>https://liutos.github.io/2019/02/05/拿Emacs对接我的cuckoo/</id>
    <published>2019-02-05T07:17:08.000Z</published>
    <updated>2019-02-05T07:19:57.002Z</updated>
    
    <content type="html"><![CDATA[<p>cuckoo是一个我自己开发的类似待办事项的工具，运行在我本地的电脑上。它有如下两个接口：</p><ol><li>传入一个UNIX Epoch时间戳创建提醒</li><li>传入一个标题以及提醒的ID来创建任务</li></ol><p>这样一来，便能在设定的时刻调用<a href="https://github.com/vjeantet/alerter" target="_blank" rel="noopener"><code>alerter</code></a>在屏幕右上角弹出提醒。</p><p>我喜欢用<a href="https://www.gnu.org/software/emacs/index.html" target="_blank" rel="noopener">Emacs</a>的<a href="https://orgmode.org/" target="_blank" rel="noopener">org-mode</a>来安排任务，但可惜的是，org-mode没有定点提醒的功能（如果有的话希望来个人打我的脸XD）。开发了cuckoo后，忽然灵机一动——何不给Emacs添砖加瓦，让它可以把org-mode中的条目内容（所谓的heading）当做任务丢给cuckoo，以此来实现定点提醒呢。感觉是个好主意，马上着手写这么些Elisp函数。</p><p>PS：读者朋友们就不用执着于我的cuckoo究竟是怎样的接口定义了。</p><p>为了实现所需要的功能，让我从结果反过来推导一番。首先，需要提炼一个TODO条目的标题和时间戳（用来创建提醒获取ID），才能调用cuckoo的接口。标题就是org-mode中一个TODO条目的heading text，在Emacs中用下面的代码获取</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">nth</span> <span class="number">4</span> (<span class="name">org-heading-components</span>))</span><br></pre></td></tr></table></figure><p><code>org-headline-components</code>在光标位于TODO条目上的时候，会返回许多信息（参见下图）</p><p><img src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/org-heading-components%E7%9A%84%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3.png" alt=""></p><p>其中下标为4的component就是我所需要的内容。</p><p>接着便是要获取一个提醒的ID。ID当然是从cuckoo的接口中返回的，这就需要能够解析JSON格式的文本。在Emacs中解析JSON序列化后的文本可以用<a href="https://github.com/ryancrum/json.el" target="_blank" rel="noopener">json</a>这个库，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let</span> ((<span class="name">s</span> <span class="string">"&#123;\"remind\":&#123;\"create_at\":\"2019-01-11T14:53:59.000Z\",\"duration\":null,\"id\":41,\"restricted_hours\":null,\"timestamp\":1547216100,\"update_at\":\"2019-01-11T14:53:59.000Z\"&#125;&#125;"</span>))</span><br><span class="line">  (<span class="name">cdr</span> (<span class="name">assoc</span> 'id (<span class="name">cdr</span> (<span class="name">car</span> (<span class="name">json-read-from-string</span> s))))))</span><br></pre></td></tr></table></figure><p>既然知道如何解析（同时还知道如何提取解析后的内容），那么接下来便是要能够获取上述示例代码中的<code>s</code>。<code>s</code>来自于HTTP响应的body，为了发出HTTP请求，可以用Emacs的<a href="https://github.com/tkf/emacs-request" target="_blank" rel="noopener">request</a>库，示例代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">let*</span> ((<span class="name">this-request</span> (<span class="name">request</span></span><br><span class="line">                      <span class="string">"http://localhost:7001/remind"</span></span><br><span class="line">                      <span class="symbol">:data</span> <span class="string">"&#123;\"timestamp\":1547216100&#125;"</span></span><br><span class="line">                      <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">                      <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">                      <span class="symbol">:type</span> <span class="string">"POST"</span></span><br><span class="line">                      <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">                                (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                                  (<span class="name">message</span> <span class="string">"data: %S"</span> data)))</span><br><span class="line">                      <span class="symbol">:sync</span> <span class="literal">t</span>))</span><br><span class="line">       (<span class="name">data</span> (<span class="name">request-response-data</span> this-request)))</span><br><span class="line">  data)</span><br></pre></td></tr></table></figure><p>此处的<code>:sync</code>参数花了我好长的时间才捣鼓出来——看了一下<code>request</code>函数的docstring后才发现，原来需要传递<code>:sync</code>为<code>t</code>才可以让<code>request</code>函数阻塞地调用，否则一调用<code>request</code>就立马返回了<code>nil</code>。</p><p>现在需要的就是构造<code>:data</code>的值了，其中的关键是生成秒级的UNIX Epoch时间戳，这个时间戳可以通过TODO条目的<code>SCHEDULED</code>属性转换而来。比如，一个条目的<code>SCHEDULED</code>属性的值可能是<code>&lt;2019-01-11 Fri 22:15&gt;</code>，将这个字符串传递给<code>date-to-time</code>函数可以解析成代表着秒数的几个数字</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">date-to-time</span> <span class="string">"&lt;2019-01-11 Fri 22:15&gt;"</span>)</span><br></pre></td></tr></table></figure><p>时间戳字符串要怎么拿到？答案是使用org-mode的<code>org-entry-get</code>函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">org-entry-get</span> <span class="literal">nil</span> <span class="string">"SCHEDULED"</span>)</span><br></pre></td></tr></table></figure><p>PS：需要先将光标定位在一个TODO条目上。</p><p>至此，所有的原件都准备齐全了，最终我的Elisp代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> scheduled-to-time (<span class="name">scheduled</span>)</span><br><span class="line">  <span class="string">"将TODO条目的SCHEDULED属性转换为UNIX时间戳"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">lst</span> (<span class="name">date-to-time</span> scheduled)))</span><br><span class="line">    (<span class="name">+</span> (<span class="name">*</span> (<span class="name">car</span> lst) (<span class="name">expt</span> <span class="number">2</span> <span class="number">16</span>))</span><br><span class="line">       (<span class="name">cadr</span> lst))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> create-remind-in-cuckoo (<span class="name">timestamp</span>)</span><br><span class="line">  <span class="string">"往cuckoo中创建一个定时提醒并返回这个刚创建的提醒的ID"</span></span><br><span class="line">  (<span class="name">let</span> (<span class="name">remind-id</span>)</span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:7001/remind"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">json-encode-alist</span></span><br><span class="line">            (<span class="name">list</span> (<span class="name">cons</span> <span class="string">"timestamp"</span> timestamp)))</span><br><span class="line">     <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">     <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">     <span class="symbol">:type</span> <span class="string">"POST"</span></span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">message</span> <span class="string">"返回内容为：%S"</span> data)</span><br><span class="line">                 (<span class="name">let</span> ((<span class="name">remind</span> (<span class="name">json-read-from-string</span> data)))</span><br><span class="line">                   (<span class="name">setq</span> remind-id (<span class="name">cdr</span> (<span class="name">assoc</span> 'id (<span class="name">cdr</span> (<span class="name">car</span> remind))))))))</span><br><span class="line">     <span class="symbol">:sync</span> <span class="literal">t</span>)</span><br><span class="line">    remind-id))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> create-task-in-cuckoo ()</span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">brief</span>)</span><br><span class="line">        (<span class="name">remind-id</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name">setq</span> brief (<span class="name">nth</span> <span class="number">4</span> (<span class="name">org-heading-components</span>)))</span><br><span class="line"></span><br><span class="line">    (<span class="name">let*</span> ((<span class="name">scheduled</span> (<span class="name">org-entry-get</span> <span class="literal">nil</span> <span class="string">"SCHEDULED"</span>))</span><br><span class="line">           (<span class="name">timestamp</span> (<span class="name">scheduled-to-time</span> scheduled)))</span><br><span class="line">      (<span class="name">setq</span> remind-id (<span class="name">create-remind-in-cuckoo</span> timestamp)))</span><br><span class="line">    </span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:7001/task"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">concat</span> <span class="string">"brief="</span> (<span class="name">url-encode-url</span> brief) <span class="string">"&amp;detail=&amp;remind_id="</span> (<span class="name">format</span> <span class="string">"%S"</span> remind-id))</span><br><span class="line">     <span class="symbol">:type</span> <span class="string">"POST"</span></span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">message</span> <span class="string">"任务创建完毕"</span>))))))</span><br></pre></td></tr></table></figure><p>在<code>create-task-in-cuckoo</code>中，之所以没有再传递<code>application/json</code>形式的数据给cuckoo，是因为不管我怎么测试，始终无法避免中文字符在传递到接口的时候变成了<code>\u</code>编码的形式，不得已而为之，只好把中文先做一遍url encoding，然后再通过表单的形式（<code>form/x-www-urlencode</code>）发送给接口了。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
  </entry>
  
</feed>
