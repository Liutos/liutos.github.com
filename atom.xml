<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小打小闹写点bug</title>
  
  <subtitle>乍听之下，不无道理；仔细揣摩，胡说八道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liutos.github.io/"/>
  <updated>2020-07-03T13:26:51.848Z</updated>
  <id>https://liutos.github.io/</id>
  
  <author>
    <name>Liutos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何写一个命令行的秒表</title>
    <link href="https://liutos.github.io/2020/07/03/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E7%A7%92%E8%A1%A8/"/>
    <id>https://liutos.github.io/2020/07/03/如何写一个命令行的秒表/</id>
    <published>2020-07-03T12:47:06.000Z</published>
    <updated>2020-07-03T13:26:51.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>相信各位读者对秒表都不陌生，智能手机上通常都有这样一款软件</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/数字秒表.jpg" alt="来自我的小米手机的截图"></p><p>有一天心血来潮，便想要“复刻”一个命令行版本的秒表程序——主要是想尝试一下新学会的、“原地更新”的技能，而不是一行接一行地输出。程序的运行效果如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/stopwatch的演示效果.gif" alt=""></p><p>那么这是怎么做的呢？</p><h1 id="实现思路及代码"><a href="#实现思路及代码" class="headerlink" title="实现思路及代码"></a>实现思路及代码</h1><h2 id="如何获取流逝的时间长度？"><a href="#如何获取流逝的时间长度？" class="headerlink" title="如何获取流逝的时间长度？"></a>如何获取流逝的时间长度？</h2><p>要实现一个秒表，首先要知道从开始计时至今过了多久。在*nix系统中，表示时刻的事实标准是<a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Epoch Time</a>，在<code>shell</code>脚本中要获取Epoch Time可以用<code>date</code>命令。再用首尾时刻相减便得到了期间流逝的秒数了，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin_at=$(date '+%s')</span><br><span class="line"><span class="meta">#</span> 睡个觉</span><br><span class="line">end_at=$(date '+%s')</span><br><span class="line">((interval=$&#123;end_at&#125; - $&#123;begin_at&#125;))</span><br></pre></td></tr></table></figure><p>双圆括号是一种在<code>shell</code>脚本中执行算术运算的语法，其它语法可以参见<a href="http://faculty.salina.k-state.edu/tim/unix_sg/bash/math.html" target="_blank" rel="noopener">Math in Shell Scripts</a>。</p><h2 id="如何换算为时分秒？"><a href="#如何换算为时分秒？" class="headerlink" title="如何换算为时分秒？"></a>如何换算为时分秒？</h2><p>有了<code>interval</code>中存储的总秒数后，换算成时分秒便是轻而易举的事情，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((hours=$&#123;interval&#125; / 3600))</span><br><span class="line">((minutes=($&#123;interval&#125; % 3600) / 60))</span><br><span class="line">((seconds=($&#123;interval&#125; % 3600) % 60))</span><br></pre></td></tr></table></figure><h2 id="如何输出形如hh-mm-ss的格式？"><a href="#如何输出形如hh-mm-ss的格式？" class="headerlink" title="如何输出形如hh:mm:ss的格式？"></a>如何输出形如<code>hh:mm:ss</code>的格式？</h2><p><code>hh:mm:ss</code>的意思是分别用两个十进制数字显示时分秒，并以冒号分隔它们。如果有任何一个单位的数值小于10，便用字符<code>0</code>填充左侧的空白。按这个格式，凌晨1点2分3秒便会显示为<code>01:02:03</code>。</p><p>要在命令行中打印字符串，最容易想到的便是<code>echo</code>命令，只可惜它不能方便地实现填充字符<code>0</code>的需求。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/强人锁男.jpg" alt=""></p><p>强人所难也不是不行，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hours=1</span><br><span class="line">minutes=2</span><br><span class="line">seconds=3</span><br><span class="line"></span><br><span class="line">if [ "$&#123;hours&#125;" -lt '10' ];</span><br><span class="line">then</span><br><span class="line">   echo -n "0$&#123;hours&#125;"</span><br><span class="line">else</span><br><span class="line">   echo -n "$&#123;hours&#125;"</span><br><span class="line">fi</span><br><span class="line">echo -n ':'</span><br><span class="line">if [ "$&#123;minutes&#125;" -lt '10' ];</span><br><span class="line">then</span><br><span class="line">   echo -n "0$&#123;minutes&#125;"</span><br><span class="line">else</span><br><span class="line">   echo -n "$&#123;minutes&#125;"</span><br><span class="line">fi</span><br><span class="line">echo -n ':'</span><br><span class="line">if [ "$&#123;seconds&#125;" -lt '10' ];</span><br><span class="line">then</span><br><span class="line">   echo -n "0$&#123;seconds&#125;"</span><br><span class="line">else</span><br><span class="line">   echo -n "$&#123;seconds&#125;"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>更优雅的方法是用<code>printf</code>命令来自动填充左侧的字符<code>0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf "%02d:%02d:%02d" $&#123;hours&#125; $&#123;minutes&#125; $&#123;seconds&#125;</span><br></pre></td></tr></table></figure><p><code>printf</code>命令类似于C语言中的<code>printf</code>函数——它也支持打印转义的字符，下文会提到。</p><h2 id="如何覆盖已经打印的内容？"><a href="#如何覆盖已经打印的内容？" class="headerlink" title="如何覆盖已经打印的内容？"></a>如何覆盖已经打印的内容？</h2><p>今年以来我在断断续续地看<a href="https://viewsourcecode.org/snaptoken/kilo/index.html" target="_blank" rel="noopener">Build Your Own Text Editor</a>，学习如何开发文本编辑器。在这本小册子的<a href="https://viewsourcecode.org/snaptoken/kilo/03.rawInputAndOutput.html#clear-the-screen" target="_blank" rel="noopener">第三章</a>中，作者讲述了如何使用终端的转义序列（<code>escape sequence</code>）来控制屏幕上显示的东西——这正是秒表程序所需要的。</p><p>例如，在终端输出转义序列<code>\x1b[2J</code>可以清空屏幕，效果如下</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200703/演示用转义序列清空屏幕.gif" alt=""></p><p>为了覆盖已经打印出来的时分秒，需要：</p><ol><li>先将光标移动到行首；</li><li>再清除从光标开始到行末的内容。</li></ol><p>查阅<a href="https://vt100.net/docs/vt100-ug/chapter3.html" target="_blank" rel="noopener">《VT100 User Guide》第三章</a>可以知道</p><ol><li>要把光标移动到行首可以用转义序列<code>\x1b[8D</code>。之所以是8，是因为按照<code>hh:mm:ss</code>输出时分秒后光标距离行首8个身位；</li><li>要清除光标到行末内容可以用转义序列<code>\x1b[0K</code>（实际上，将光标移到行首只需要使用回车（<code>carriage return</code>）即可，但它被解释为开启新的一行了）。</li></ol><p>更优雅的方法甚至连转义序列也不需要，只要用<code>tput</code>命令即可，示例代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -n '11:22:33'</span><br><span class="line">tput cr</span><br><span class="line">tput el</span><br><span class="line">echo '44:55:66'</span><br></pre></td></tr></table></figure><p>关于<code>cr</code>和<code>el</code>，以及更多可以传给<code>tput</code>命令的参数，可以参见<code>terminfo</code>的<code>man</code>文档。</p><h2 id="如何每隔一秒钟输出一次？"><a href="#如何每隔一秒钟输出一次？" class="headerlink" title="如何每隔一秒钟输出一次？"></a>如何每隔一秒钟输出一次？</h2><p>这大概是整个程序中最简单的需求了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while [ 1 -eq 1 ]</span><br><span class="line">do</span><br><span class="line">    # 此处可以为所欲为</span><br><span class="line">    sleep 0.5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="完整的秒表实现"><a href="#完整的秒表实现" class="headerlink" title="完整的秒表实现"></a>完整的秒表实现</h2><p>至此，完整的秒表程序就可以实现出来了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 秒表，以hh:mm:ss的格式展示数据</span><br><span class="line"></span><br><span class="line">begin_at=$(date '+%s')</span><br><span class="line"></span><br><span class="line">while [ 1 -eq 1 ]</span><br><span class="line">do</span><br><span class="line">    end_at=$(date '+%s')</span><br><span class="line">    # 算术运算：http://faculty.salina.k-state.edu/tim/unix_sg/bash/math.html</span><br><span class="line">    ((interval=$&#123;end_at&#125; - $&#123;begin_at&#125;))</span><br><span class="line">    ((hours=$&#123;interval&#125; / 3600))</span><br><span class="line">    ((minutes=($&#123;interval&#125; % 3600) / 60))</span><br><span class="line">    ((seconds=($&#123;interval&#125; % 3600) % 60))</span><br><span class="line">    tput cr</span><br><span class="line">    tput el</span><br><span class="line">    printf "%02d:%02d:%02d" $&#123;hours&#125; $&#123;minutes&#125; $&#123;seconds&#125;</span><br><span class="line">    sleep 0.5</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行后的效果正如本文开头的GIF所示。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
      <category term="bash" scheme="https://liutos.github.io/tags/bash/"/>
    
      <category term="命令行" scheme="https://liutos.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的NOT EXISTS遭遇战</title>
    <link href="https://liutos.github.io/2020/06/25/MySQL%E7%9A%84NOT-EXISTS%E9%81%AD%E9%81%87%E6%88%98/"/>
    <id>https://liutos.github.io/2020/06/25/MySQL的NOT-EXISTS遭遇战/</id>
    <published>2020-06-25T14:12:40.000Z</published>
    <updated>2020-06-25T14:15:19.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅尝一下NOT-EXISTS"><a href="#浅尝一下NOT-EXISTS" class="headerlink" title="浅尝一下NOT EXISTS"></a>浅尝一下<code>NOT EXISTS</code></h1><p>最近老婆在看视频学习MySQL，然后碰到了这样一道习题：有三个表，分别记录学生、课程，以及学生选修了什么课程的信息，问如何用<code>NOT EXISTS</code>找出选修了所有课程的学生。</p><p>为了避免想破脑袋编造一些尴尬的学生姓名和课程名，我简化了一下习题中的表的结构，只留下它们的ID列。建表语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选修关系</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`elective`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`student_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`student`</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`course_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`course`</span>(<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>还需要给它们塞入一些示例数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">3</span>), (<span class="number">4</span>), (<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> (<span class="string">`id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`elective`</span> (<span class="string">`course_id`</span>, <span class="string">`student_id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>显然，只有<code>id</code>列的值为1和5的学生是选修了全部课程的。用<code>NOT EXISTS</code>写出来的SQL语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>   <span class="string">`student`</span> </span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">                   <span class="keyword">FROM</span>   <span class="string">`course`</span> </span><br><span class="line">                   <span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * </span><br><span class="line">                                      <span class="keyword">FROM</span>   <span class="string">`elective`</span> </span><br><span class="line">                                      <span class="keyword">WHERE</span>  <span class="string">`student`</span>.<span class="string">`id`</span> = </span><br><span class="line">                                             <span class="string">`elective`</span>.<span class="string">`student_id`</span> </span><br><span class="line">                                             <span class="keyword">AND</span> <span class="string">`course`</span>.<span class="string">`id`</span> = </span><br><span class="line">                                     <span class="string">`elective`</span>.<span class="string">`course_id`</span>));</span><br></pre></td></tr></table></figure><p>在<a href="https://dbeaver.io/" target="_blank" rel="noopener">DBEaver</a>中运行后的结果为</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200625/双重NOT_EXISTS的执行结果.jpg" alt="在DBEaver中执行的结果"></p><p>正确地找出了两个选修了所有课程的学生的<code>id</code>。</p><h1 id="如何理解双重NOT-EXISTS"><a href="#如何理解双重NOT-EXISTS" class="headerlink" title="如何理解双重NOT EXISTS"></a>如何理解双重<code>NOT EXISTS</code></h1><p>当第一次被请教这道习题的时候，我其实并不能理解<code>NOT EXISTS</code>的含义。直到后来去看<code>EXISTS</code>的<a href="https://dev.mysql.com/doc/refman/8.0/en/exists-and-not-exists-subqueries.html" target="_blank" rel="noopener">文档</a>，才顿悟了上面的SQL。</p><p>我的理解方法是将双重<code>NOT EXISTS</code>转换为三层循环。以上面的SQL为例，转述为人话就是：找出<code>student</code>表中所有的、<strong>没有</strong>任何一门<code>course</code>表中的课程是<strong>没有</strong>选修的、的学生——双重的 <strong>没有</strong>。</p><p>转换为三层循环大概长这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> student <span class="keyword">of</span> students) &#123;</span><br><span class="line">  <span class="comment">// 是否存在学生未选修的课程</span></span><br><span class="line">  <span class="keyword">let</span> existSuchCourse = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> course <span class="keyword">of</span> courses) &#123;</span><br><span class="line">    <span class="keyword">let</span> existSuchElective = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> elective <span class="keyword">of</span> electives) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elective.student_id === student.id &amp;&amp; elective.course_id === course.id) &#123;</span><br><span class="line">        existSuchElective = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完elective表的记录后，existSuchElective仍然为false，说明的确有一门课程是没有选修记录的</span></span><br><span class="line">    <span class="comment">// 那么便意味着“存在至少一门课程，使得当前被遍历的学生与该课程没有选修关系”。</span></span><br><span class="line">    <span class="keyword">if</span> (!existSuchElective) &#123;</span><br><span class="line">      existSuchCourse = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果遍历完一圈后确实没有找到“未选修”的课程，说明这名学生全都选修了</span></span><br><span class="line">  <span class="keyword">if</span> (!existSuchCourse) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(student);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOT-EXISTS的本质"><a href="#NOT-EXISTS的本质" class="headerlink" title="NOT EXISTS的本质"></a><code>NOT EXISTS</code>的本质</h1><p>即使不强行理解，也可以让MySQL明确告知双重<code>NOT EXISTS</code>是怎么运作的。用<code>EXPLAIN</code>解释上面的SQL的结果如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200625/双重NOT_EXISTS的EXPLAIN结果.jpg" alt=""></p><p>MySQL的<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN命令的文档</a>中说明了如何解读执行计划</p><blockquote><p>EXPLAIN returns a row of information for each table used in the SELECT statement. It lists the tables in the output in the order that MySQL would read them while processing the statement. This means that MySQL reads a row from the first table, then finds a matching row in the second table, and then in the third table, and so on. When all tables are processed, MySQL outputs the selected columns and backtracks through the table list until a table is found for which there are more matching rows. The next row is read from this table and the process continues with the next table.</p></blockquote><p>以上面的<code>EXPLAIN</code>为例，MySQL从<code>student</code>表中读出一行，再从<code>course</code>表中读取一行，最后从<code>elective</code>表中读取一行，然后看看<code>WHERE</code>子句是否能够被满足。如果可以，就输出从<code>student</code>表中读出来的这行数据。上图第2和第3行的<code>select_type</code>都是<code>DEPENDENT SUBQUERY</code>，表示它们依赖于“外层”的查询上下文——<code>elective</code>的<code>WHERE</code>子句依赖于<code>student</code>和<code>course</code>中读出来的行。</p><p>似乎和方才的三重循环有异曲同工之妙呢。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>像<code>NOT EXISTS</code>这么“高阶”的功能我从未在业务代码中读过和使用过——别说<code>NOT EXISTS</code>，就算是<code>EXISTS</code>也是从未有之，甚至连子查询也极少。毕竟“正经的互联网公司”只是把MySQL<del>当妹妹</del>当一个具备复杂查询查询功能的key-value数据库来使用（笑</p><p>比起双重<code>NOT EXISTS</code>，我更可能凭直觉写出基于子查询的解决方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span>   <span class="string">`student`</span> </span><br><span class="line"><span class="keyword">WHERE</span>  <span class="string">`id`</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="string">`student_id`</span> </span><br><span class="line">                <span class="keyword">FROM</span>   <span class="string">`elective`</span> </span><br><span class="line">                <span class="keyword">GROUP</span>  <span class="keyword">BY</span> <span class="string">`student_id`</span> </span><br><span class="line">                <span class="keyword">HAVING</span>( <span class="keyword">Count</span>(<span class="number">0</span>) ) = <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>我甚至觉得会有人把数据库里的行读进内存然后用应用层代码来找出选修了全部课程的学生！</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="database" scheme="https://liutos.github.io/tags/database/"/>
    
      <category term="mysql" scheme="https://liutos.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://liutos.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>用org-mode管理API测试用例</title>
    <link href="https://liutos.github.io/2020/06/10/%E7%94%A8org-mode%E7%AE%A1%E7%90%86API%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>https://liutos.github.io/2020/06/10/用org-mode管理API测试用例/</id>
    <published>2020-06-10T13:31:58.000Z</published>
    <updated>2020-06-10T13:58:19.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API测试用例是什么？"><a href="#API测试用例是什么？" class="headerlink" title="API测试用例是什么？"></a>API测试用例是什么？</h1><p>在互联网大行其道的今天，身为一名电商平台的程序员，必定经常与HTTP API打交道，一个常见的情况便是做API测试。抛开可以用单元测试代替的，很多时候需要真地发出HTTP请求才行。这些负责发出HTTP请求的东西可能是一行<code>curl</code>命令，可能是一个<code>.js</code>文件，也可能是一个在postman中点击按钮的操作，但不管形态如何，它们便是API测试用例。尽管名字中带有“用例”二字，但很多时候是由人来校验结果的，用例更关注发出怎样的HTTP请求。</p><h1 id="为什么要管理它们？"><a href="#为什么要管理它们？" class="headerlink" title="为什么要管理它们？"></a>为什么要管理它们？</h1><p>不同于每天在浏览器中发生成千上万次的、平凡的HTTP（或HTTPS）请求，API测试用例是值得一番精心管理的，因为：</p><ol><li><p>API测试用例通常会重复使用，因此必须将它们持久化保存。也许是保存成shell脚本，也许是保存成脚本语言源文件，也许是保存为某一款软件的数据文件；</p></li><li><p>需要为多个API编写测试用例，因此必须区分不同的API对应的测试用例。例如，负责管理业务资源的服务（比如一个管理商品数据的、提供RESTful API的服务），起码需要提供增删查改的功能，那么也就需要有增删查改对应的API测试用例；</p></li><li><p>需要为多个服务的API编写用例，因此必须区分不同的服务对应的测试用例集。例如，既然有商品服务，那么极可能还有订单服务、优惠券服务、物流服务，等等，每个服务又都有增删查改的功能，这些不同服务的API也需要各自的测试用例；</p></li><li><p>需要区分不同的运行环境。通常本地、开发、测试，以及生产环境是互相隔离的，一个用例中的参数往往不能照搬到另一个环境中。</p></li></ol><p>API、服务，以及环境这三个维度上的区别，使得测试用例的数量显著增加，如不进行管理，当要用时，要么不得不从零开始再写一遍脚本，要么得翻查很久才能找到所需的用例。</p><h1 id="用org-mode管理"><a href="#用org-mode管理" class="headerlink" title="用org-mode管理"></a>用org-mode管理</h1><h2 id="org-mode是什么？"><a href="#org-mode是什么？" class="headerlink" title="org-mode是什么？"></a>org-mode是什么？</h2><p><code>org-mode</code>是一款Emacs编辑器的扩展，它让使用者能够用快速高效的纯文本方式来记笔记、维护待办事项、安排计划，以及编写文档。<code>org-mode</code>的精髓在于它的大纲组织能力，以及依托于Emacs的扩展能力，两者使其正好可以胜任管理API测试用例的工作。一个<code>.org</code>文件的示例如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/org-mode官网示例.jpg" alt="org-mode官网的示例截图"></p><h2 id="如何用org-mode管理API测试用例？"><a href="#如何用org-mode管理API测试用例？" class="headerlink" title="如何用org-mode管理API测试用例？"></a>如何用org-mode管理API测试用例？</h2><p>尽管<code>org-mode</code>提供了丰富的功能，但只是管理API测试用例的话，并用不上太多花里胡哨的东西，只需要<code>org-mode</code>的大纲功能和<code>org-babel</code>特性即可。</p><p>首先用不同的<code>.org</code>文件区分不同的环境。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/用不同的org文件区分环境.jpg" alt=""></p><p>接着用不同层级的headline区分不同的服务、资源类型，以及API。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/用不同层级的headline管理的示例.jpg" alt=""></p><p>然后用<code>org-mode</code>的<a href="https://orgmode.org/manual/Structure-of-Code-Blocks.html" target="_blank" rel="noopener">代码块</a>语法来编写HTTP请求。以请求<code>https://httpbin.org/uuid</code>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC restclient</span><br><span class="line">  GET https://httpbin.org/uuid</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure><p><code>#+BEGIN_SRC</code>和<code>#+END_SRC</code>分别表示开启和结束代码块，<code>restclient</code>表示这个代码块内的代码可以用Emacs的<code>restclient-mode</code>来编辑。在代码块中，<code>GET https://httpbin.org/uuid</code>表示以GET方法请求<code>https://httpbin.org/uuid</code>。</p><p>安装了<a href="https://github.com/pashky/restclient.el" target="_blank" rel="noopener"><code>restclient</code></a>后，将光标定位在代码块上并按下<code>ctrl-c &#39;</code>，可以进入一个单独的buffer编辑其中的源代码</p><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/进入restclient模式的buffer.mp4" type="video/mp4"><br></video><p>最后，如果配置了<code>org-babel</code>，甚至可以直接在代码块上按下<code>ctrl-c ctrl-c</code>来发出HTTP请求。</p><p><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200610/org-mode中发出HTTP请求.mp4" type="video/mp4"><br></video><br>可以看到，HTTP响应的内容会保留在这个<code>.org</code>文件中。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以前我也用过其它的工具来管理API测试用例：</p><ol><li>刚工作的时候用的是Postman，那时候Postman还是Chrome的一个插件；</li><li>后来出于对Firefox浏览器的喜爱，找了一个叫RESTClient的插件来代替postman，久而久之发觉两者的差距蛮大，终究无法代替；</li><li>接着遇到了Emacs中的<code>restclient.el</code>，于是用了好一段时间的纯<code>restclient-mode</code>（没有搭配<code>org-mode</code>）；</li><li>再后来开始用Mac办公了，便开始寻找Mac下的这类工具，遇到了<a href="https://insomnia.rest/" target="_blank" rel="noopener">Insomnia</a>。如果有人找我推荐用于HTTP API测试的GUI工具的话，我会毫无不犹豫地推荐这款。</li></ol><p>再后来，我又回到了Emacs，并用<code>org-mode</code>来管理这些API测试用例。目前这是最适合我的一种方式。</p><p>全文完。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="org-mode" scheme="https://liutos.github.io/tags/org-mode/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="api" scheme="https://liutos.github.io/tags/api/"/>
    
      <category term="http" scheme="https://liutos.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>重定向的时候shell在干什么？</title>
    <link href="https://liutos.github.io/2020/05/22/%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E6%97%B6%E5%80%99shell%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://liutos.github.io/2020/05/22/重定向的时候shell在干什么？/</id>
    <published>2020-05-22T14:49:15.000Z</published>
    <updated>2020-05-22T14:50:16.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“究竟在干什么”是一系列关于软件背后运作原理的文章，每一篇文章旨在讲解一些在日常编程实践中常见但可能并不为人所熟知的技术细节，抛砖引玉，期待激发读者朋友的更多思考。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>每当需要<code>ssh</code>登录到服务器并运行一个比较花时间的脚本时（比如临时从生产环境导出数据），为了能够知道脚本是否运行结束，或者是否出错退出，我都会将脚本的输出内容重定向到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node foobar.js &gt; /tmp/foobar.log 2&gt; /tmp/foobar.err</span><br></pre></td></tr></table></figure><p>如果不在乎将正常的打印和错误混在一起，可以写成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node foobar.js &gt; /tmp/foobar.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>上面代码中的<code>2</code>和<code>1</code>分别是标准错误（C语言中的<code>stderr</code>）和标准输出（C语言中的<code>stdout</code>）的文件描述符，<code>2&gt;&amp;1</code>的意思便是将打印到标准错误中的内容<em>转移</em>到标准输出中去——这个<em>转移</em>在shell中的术语便叫做重定向（redirection）。</p><h1 id="2-gt-amp-1该放哪里？"><a href="#2-gt-amp-1该放哪里？" class="headerlink" title="2&gt;&amp;1该放哪里？"></a><code>2&gt;&amp;1</code>该放哪里？</h1><p><code>bash</code>的<code>man</code>文档中有一个名为<code>REDIRECTION</code>的章节专门介绍了重定向相关的内容，其中有一段有意思的内容</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/bash的文档中对重定向次序的说明.jpg" alt=""></p><p>用<code>ls</code>不方便做演示，我准备了下面这一段Node.js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.error(<span class="string">'Print to standard error.'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Print to standard output.'</span>);</span><br></pre></td></tr></table></figure><p>将代码保存到文件<code>foobar.js</code>中。</p><p>如果将<code>2&gt;&amp;1</code>写在后面，那么<code>foobar.log</code>中会包含两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp node foobar.js &gt; /tmp/foobar.log 2&gt;&amp;1</span><br><span class="line">➜  /tmp cat /tmp/foobar.log</span><br><span class="line">Print to standard error.</span><br><span class="line">Print to standard output.</span><br></pre></td></tr></table></figure><p>否则，<code>foobar.log</code>中只含有一行内容，另一行会出现在终端上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp node foobar.js 2&gt;&amp;1 &gt; /tmp/foobar.log</span><br><span class="line">Print to standard error.</span><br><span class="line">➜  /tmp cat /tmp/foobar.log</span><br><span class="line">Print to standard output.</span><br></pre></td></tr></table></figure><p>那么为什么会这样呢？</p><h1 id="重定向的时候，shell在做些什么？"><a href="#重定向的时候，shell在做些什么？" class="headerlink" title="重定向的时候，shell在做些什么？"></a>重定向的时候，shell在做些什么？</h1><p>以执行<code>node foobar.js &gt; /tmp/foobar.log</code>为例，当shell发现命令中含有重定向的符号时，便开始忙碌起来。</p><p>shell首先用<code>open</code>函数打开文件<code>/tmp/foobar.log</code>，拿到一个文件描述符（一个非负整数）。Node.js的<code>fs</code>模块中有一个<code>open</code>方法，在调用成功时，也是往回调函数传入文件描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.open(<span class="string">'/tmp/cuckoo.log'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`fd for cuckoo.log is <span class="subst">$&#123;fd&#125;</span>`</span>);</span><br><span class="line">  fs.open(<span class="string">'/tmp/cuckoo.err'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`fd for cuckoo.err is <span class="subst">$&#123;fd&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比较奇妙的是，多次运行时拿到的文件描述符总是相同的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  /tmp date; node open.test.js</span><br><span class="line">Fri May 22 21:00:56 CST 2020</span><br><span class="line">fd for cuckoo.log is 21</span><br><span class="line">fd for cuckoo.err is 24</span><br><span class="line">➜  /tmp date; node open.test.js</span><br><span class="line">Fri May 22 21:00:59 CST 2020</span><br><span class="line">fd for cuckoo.log is 21</span><br><span class="line">fd for cuckoo.err is 24</span><br></pre></td></tr></table></figure><p>说回重定向。shell拿到文件描述符后，便调用<code>dup2</code>函数。既然有<code>dup2</code>，那么就有<code>dup</code>。<code>dup</code>接收一个文件描述符作为参数，返回一个新的文件描述符。而<code>dup2</code>则接收两个参数，它可以作为让第二个参数的数字成为一个新的文件描述符，指向与第一个参数相同的文件。</p><p>用图形可以更好地表达<code>dup2</code>的实现原理。下图是一个进程没有重定向时的状态，每个文件描述符都指向它们<em>原本</em>对应的文件</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/before_redirect.jpeg" alt=""></p><p>作为数字的文件描述符，相当于是<em>文件描述符表</em>的数组下标。调用<code>dup2</code>后，就变成了</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/after_redirect.jpeg" alt=""></p><p>可以将<code>dup2</code>理解为：把<em>文件描述符表</em>的一个元素（以<code>dup2</code>的第一个参数作为下标），按位复制到另一个元素中（以<code>dup2</code>的第二个参数作为下标）。</p><p>这样一来，凡是写往文件描述符<code>1</code>的数据，其实都写到了文件<code>/tmp/foobar.log</code>中。</p><p>所以，如果命令中重定向操作是<code>2&gt;&amp;1 &gt; /tmp/foobar.log</code>，那么文件描述符表中下标1和2的元素并不会指向相同的文件</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/放前面.jpeg" alt=""></p><p>如果重定向操作是<code>&gt; /tmp/foobar.log 2&gt;&amp;1</code>，则如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200522/放后面.jpeg" alt=""></p><p>因此，此时不管是写往文件描述符1还是2，最终都<em>重定向</em>到了<code>/tmp/foobar.log</code>中。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果想要严谨地知道<code>bash</code>是如何处理重定向的，可以在GitHub的这个<a href="https://github.com/bminor/bash" target="_blank" rel="noopener">Bash源代码镜像</a>上直接查看，找到根目录下的<a href="https://github.com/bminor/bash/blob/master/redir.c" target="_blank" rel="noopener">redir.c</a>文件即可。</p><p>此外，对于上面的示意图，维基百科的<a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noopener">File descriptor词条</a>也有一幅更严谨的版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="究竟在干什么系列" scheme="https://liutos.github.io/categories/%E7%A9%B6%E7%AB%9F%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
      <category term="bash" scheme="https://liutos.github.io/tags/bash/"/>
    
      <category term="redirection" scheme="https://liutos.github.io/tags/redirection/"/>
    
      <category term="重定向" scheme="https://liutos.github.io/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>程序员特有的画图方式——语绘工具小入门</title>
    <link href="https://liutos.github.io/2020/05/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%89%B9%E6%9C%89%E7%9A%84%E7%94%BB%E5%9B%BE%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E8%AF%AD%E7%BB%98%E5%B7%A5%E5%85%B7%E5%B0%8F%E5%85%A5%E9%97%A8/"/>
    <id>https://liutos.github.io/2020/05/07/程序员特有的画图方式——语绘工具小入门/</id>
    <published>2020-05-07T12:37:04.000Z</published>
    <updated>2020-05-07T13:07:31.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h1><p>虽然程序员多数时候都在与字符打交道，但偶尔也会像建筑或制造业的工程师一样，画一些图，比如：</p><ol><li>为了表达多个系统如何协作以实现业务需求，会画时序图；</li><li>为了表达存储到数据库中的业务实体间的关系，会画ER图；</li><li>为了表达复杂的业务实体在整个生存期中状态的变化，会画状态图。</li></ol><p>除此之外，还有流程图、甘特图、火焰图，等等。</p><p>尽管软件开发过程中产出的这些图不一定逼真、漂亮，或严谨，但凭着图上不同的形状、颜色，以及布局，也可以做到一图胜千言的效果。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/你倒是上个图啊.jpeg" alt=""></p><p>图很有用，画图的工具也同样举足轻重。如果是本地的桌面应用，多数人可能会选择用Windows平台的Visio或macOS平台的OmniGraffle；若说到作图网站，则可能会选择ProcessOn或Draw.io。</p><p>但比起用鼠标拖拖拉拉，我更喜欢用代码来画图。</p><h1 id="用代码画图？"><a href="#用代码画图？" class="headerlink" title="用代码画图？"></a>用代码画图？</h1><p>用代码画图大致上可以分为两类：</p><ol><li>用具体的编程语言控制某种绘图的API画出想要的图形，比如OpenGL、HTML5中的Canvas；</li><li>用DSL描述想要画的图，然后用程序根据DSL生成图片。</li></ol><p>我所说的<em>用代码画图</em>指的是上述的第二类。</p><p>百闻不如一见，以最容易上手的<code>DOT</code>语言为例，将下列内容保存在名为<code>hello.dot</code>的文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line">        Hello -&gt; World</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在shell中运行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot -Tpng hello.dot -o hello.png</span><br></pre></td></tr></table></figure><p>便得到了相应的PNG文件</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/hello.jpeg" alt=""></p><h1 id="更多的栗子"><a href="#更多的栗子" class="headerlink" title="更多的栗子"></a>更多的栗子</h1><p>下面就带各位读者走马观花地看看不同的图可以用哪些工具来绘制。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>说到程序员画的图，最出名的当属流程图了。依稀记得在高中的时候，某一册的数学课本中讲到了算法（也许是辗转相除法），并且给出了图示，那应当就是我第一次见到流程图。上大学后也有一段时间痴迷于寻找能够绘制流程图的DSL，不过一直未果。直到遇到Boostnote后，才知道的确有这样的DSL，那便是<a href="https://flowchart.js.org/" target="_blank" rel="noopener">flowchart.js</a>。</p><p><code>flowchart.js</code>是一个JS编写的、用来绘制流程图的库。比如下面这张图</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/flowchart.jpeg" alt=""></p><p>便是依据下列的DSL生成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p><code>flowchart.js</code>生成的是SVG格式的图片文件，但SVG文件不方便嵌入到Markdown或Confluence的文档中，因此我会把它转换为PNG格式。折腾了一番后，发现在Mac上最靠谱的方法，是将SVG文件嵌入一个HTML文档，再用浏览器打开这个HTML，然后复制图片到<em>预览</em>程序上保存下来。</p><p>遗憾的是，不管是Emacs还是VSCode，似乎都没有辅助编辑<code>flowchart.js</code>的DSL的插件。</p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>有限状态机的示意图也是很常见的图形，尤其是在讲解编译器的书的语法分析章节中。在Graphviz项目官网的<a href="https://graphviz.gitlab.io/gallery/" target="_blank" rel="noopener">Gallery板块</a>中，便有一个有限状态机的例子</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/dfa.jpeg" alt=""></p><p>它由如下的<code>DOT</code>代码描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">digraph finite_state_machine &#123;</span><br><span class="line">rankdir=LR;</span><br><span class="line">size=&quot;8,5&quot;</span><br><span class="line">node [shape = doublecircle]; LR_0 LR_3 LR_4 LR_8;</span><br><span class="line">node [shape = circle];</span><br><span class="line">LR_0 -&gt; LR_2 [ label = &quot;SS(B)&quot; ];</span><br><span class="line">LR_0 -&gt; LR_1 [ label = &quot;SS(S)&quot; ];</span><br><span class="line">LR_1 -&gt; LR_3 [ label = &quot;S($end)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_6 [ label = &quot;SS(b)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_5 [ label = &quot;SS(a)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_4 [ label = &quot;S(A)&quot; ];</span><br><span class="line">LR_5 -&gt; LR_7 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_5 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_6 -&gt; LR_6 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_6 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_7 -&gt; LR_8 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_7 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_8 -&gt; LR_6 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_8 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不少工具将<code>DOT</code>语言作为中间媒介来实现绘图的功能。</p><p>与<code>flowchart.js</code>不同，Emacs和VSCode都可以很好地支持<code>DOT</code>代码的编辑和预览。Emacs上有<code>dot-mode</code>，VSCode则有<a href="https://marketplace.visualstudio.com/items?itemName=Stephanvs.dot" target="_blank" rel="noopener">Graphviz (dot) language support for Visual Studio Code</a>这个插件。</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>我画得最多的当属时序图。在旧文<a href="https://liutos.github.io/2019/06/18/%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%BB%98%E5%88%B6%E5%B7%A5%E5%85%B7%E8%B5%B0%E9%A9%AC%E8%A7%82%E8%8A%B1/">《时序图绘制工具走马观花》</a>中，提到了三个工具：</p><ol><li><a href="https://www.websequencediagrams.com/" target="_blank" rel="noopener">WebSequenceDiagrams</a>，一个在线绘制时序图的网站；</li><li><a href="http://sdedit.sourceforge.net/" target="_blank" rel="noopener">sdedit</a>，一个本地的命令行兼GUI绘图工具；</li><li><a href="https://sequencediagram.org/" target="_blank" rel="noopener">SequenceDiagram</a>，也是一个网站。</li></ol><p>当时倾向于使用<code>sdedit</code>。时过境迁，如今的<code>WebSequenceDiagrams</code>变得更好看了，而我也选择了<a href="https://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a>作为绘制时序图的主力工具。下面这张图是<code>PlantUML</code>官网给出的例子</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/sequencediagram.jpeg" alt=""></p><p>它依据如下的代码生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">用户 -&gt; 认证中心: 登录操作</span><br><span class="line">认证中心 -&gt; 缓存: 存放(key=token+ip,value=token)token</span><br><span class="line"></span><br><span class="line">用户 &lt;- 认证中心 : 认证成功返回token</span><br><span class="line">用户 -&gt; 认证中心: 下次访问头部携带token认证</span><br><span class="line">认证中心 &lt;- 缓存: key=token+ip获取token</span><br><span class="line">其他服务 &lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务</span><br><span class="line">其他服务 -&gt; 用户: 信息</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>Emacs的<code>plantuml-mode</code>，以及VSCode的<a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml" target="_blank" rel="noopener">PlantUML</a>插件都可以为<code>PlantUML</code>的DSL提供语法高亮。</p><p>下载了<code>PlantUML</code>的<code>jar</code>包后，在Emacs中添加如下的配置，就可以不依赖远程服务器来生成PNG格式的图片了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> plantuml-default-exec-mode 'jar)</span><br><span class="line">(<span class="name">setq</span> plantuml-jar-path <span class="string">"/path/to/plantuml.jar"</span>)</span><br></pre></td></tr></table></figure><h2 id="UML用例图"><a href="#UML用例图" class="headerlink" title="UML用例图"></a>UML用例图</h2><p>在《架构整洁之道》一书中，作者提出了一个软件架构模式，其中有一层便是<em>用例</em>。看完这本书后，我越发地喜欢作者这一套架构模式，渐渐开始在设计文档中给出需求的典型用例——尽管是文字描述。再后来，才知道原来UML中已经有一类专门用于描述用例的图形方法——用例图。</p><p>用于画用例图的依然是<code>PlantUML</code>。下列这张图</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/用例图.jpeg" alt=""></p><p>便是依据如下的源代码生成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">left to right direction</span><br><span class="line">actor 员工 as yg</span><br><span class="line">actor 顾客 as gk</span><br><span class="line">actor 餐厅员工 as ctyg</span><br><span class="line">actor A2 as a2</span><br><span class="line">actor 送餐员 as scy</span><br><span class="line">rectangle cos &#123;</span><br><span class="line">        note &quot;没注册工资\n支付的采用\n送餐时收费&quot; as mzc</span><br><span class="line">        usecase 查看菜单 as ckcd</span><br><span class="line">        usecase 注册 as zc</span><br><span class="line">        usecase 登录 as dl</span><br><span class="line">        usecase 订餐 as dc</span><br><span class="line">        usecase &quot;预约/覆盖预约&quot; as yy</span><br><span class="line">        usecase 备餐 as bc</span><br><span class="line">        usecase 请求送餐 as qqsc</span><br><span class="line">        usecase 记录送餐 as jlsc</span><br><span class="line">        usecase 打印送餐说明 as dyscsm</span><br><span class="line">        usecase 记录收费 as jlsf</span><br><span class="line">        zc .&gt; dl : &lt;&lt;extends&gt;&gt;</span><br><span class="line">        dl .&gt; dc : &lt;&lt;extends&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line">actor A1 as a1</span><br><span class="line">note bottom of a1 : 已注册工资支付</span><br><span class="line"></span><br><span class="line">yg &lt;|-- gk</span><br><span class="line">gk &lt;|-- ctyg</span><br><span class="line">ctyg &lt;|-- a2</span><br><span class="line">ctyg &lt;|-- scy</span><br><span class="line"></span><br><span class="line">yg -- ckcd</span><br><span class="line">yg ---- zc</span><br><span class="line">yg --- dl</span><br><span class="line">gk -- dc</span><br><span class="line">gk ---- yy</span><br><span class="line">ctyg -- bc</span><br><span class="line">ctyg --- qqsc</span><br><span class="line">scy -- jlsc</span><br><span class="line">scy --- dyscsm</span><br><span class="line">scy -- mzc</span><br><span class="line">jlsf -- mzc</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>比较遗憾的是，<code>PlantUML</code>自动排版的结果显得不那么整齐，左下角有一个明显的三角形空白区域——这也是DSL大法的一个缺点，即无法完美地控制最终的排列效果。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>最开始接触UML的时候，学习的便是类图——尽管接触得最早，画得却最少。比起类图，ER图反而画得更多一点。</p><p>如果要画类图，首选的工具是<a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener"><code>mermaid</code></a>。跟<code>PlantUML</code>一样，<code>mermaid</code>也是一个大而全的东西，除了画UML类图，也可以画流程图、时序图，以及UML状态图等。下面这张图</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200507/类图.jpeg" alt=""></p><p>便是<code>mermaid-cli</code>依据如下的源代码生成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  Image &lt;|-- BMP</span><br><span class="line">  Image &lt;|-- GIF</span><br><span class="line">  Image &lt;|-- JPEG</span><br><span class="line">  Image: +setImpl()</span><br><span class="line">  Image: +parseFile()</span><br><span class="line"></span><br><span class="line">  ImageImpl &lt;|-- WinImpl</span><br><span class="line">  ImageImpl &lt;|-- LinuxImpl</span><br><span class="line">  ImageImpl: +doPaint()</span><br><span class="line"></span><br><span class="line">  Image ..&gt; ImageImpl</span><br></pre></td></tr></table></figure><p>Emacs用户可以安装<code>mermaid-mode</code>，VSCode用户则可以使用<a href="https://marketplace.visualstudio.com/items?itemName=vstirbu.vscode-mermaid-preview" target="_blank" rel="noopener">Mermaid Preview</a>这个插件，来辅助编辑<code>mermaid</code>的源文件。</p><p>方才提到的<code>mermaid-cli</code>是一个命令行程序，用于在本地根据<code>mermaid</code>的源文件产生PNG格式的图片，安装也很简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mermaid.cli</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有许多的图可以用DSL来绘制，感兴趣的读者可以到<code>mermaid</code>或<code>PlantUML</code>的官网了解一番，这里不再一一举例。</p><p>用DSL来绘图有一些优点：</p><ol><li>不需要借助鼠标工具，纯键盘党的福音；</li><li>源代码为纯文本，生成器跨多平台，可以在多个平台甚至网页上编辑和查看，不受单一软件厂商的约束；</li><li>方便修改，改完不需要来回调整各个图形的位置。</li></ol><p>但也有一些缺点：</p><ol><li>不直观，生成图片前不好猜测最终的效果；</li><li>无法准确地控制图中所有元素的排列和位置，有时候得不到想要的效果；</li><li>需要学习不同的DSL，学习成本比可视化工具要高。</li></ol><p>就像软件开发中没有银弹一样，画图工具也没有万金油，关键还是要因地制宜地选择最合适的工具来解决眼前的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="sequence diagram" scheme="https://liutos.github.io/tags/sequence-diagram/"/>
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="vscode" scheme="https://liutos.github.io/tags/vscode/"/>
    
      <category term="tool" scheme="https://liutos.github.io/tags/tool/"/>
    
      <category term="绘图" scheme="https://liutos.github.io/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>你或许不知道，shell不能比较大小</title>
    <link href="https://liutos.github.io/2020/04/26/%E4%BD%A0%E6%88%96%E8%AE%B8%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%8Cshell%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/"/>
    <id>https://liutos.github.io/2020/04/26/你或许不知道，shell不能比较大小/</id>
    <published>2020-04-26T13:19:01.000Z</published>
    <updated>2020-04-26T14:25:16.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“究竟在干什么”是一系列关于软件开发过程中背后运作原理的文章，每一篇文章旨在讲解一些在日常编程实践中常见但可能并不为人所熟知的技术细节，抛砖引玉，期待激发读者朋友的更多思考。</p></blockquote><h1 id="如何在shell中比较大小？"><a href="#如何在shell中比较大小？" class="headerlink" title="如何在shell中比较大小？"></a>如何在shell中比较大小？</h1><p>如果在搜索引擎中搜索“shell 比较”，那么得到的结果基本上都在告诉你要写<code>[ blablabla ]</code>这样的代码</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/搜索“shell比较”的结果.jpg" alt=""></p><p>例如，如果想知道当前的UNIX时间是否已经以<code>16</code>开头，可以用下列的shell代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">ts=$(date '+%s')</span><br><span class="line">if [ "$&#123;ts&#125;" -gt 1600000000 -a "$&#123;ts&#125;" -lt 1700000000 ]; then</span><br><span class="line">    echo '当前的UNIX时间戳已经以16开头啦。'</span><br><span class="line">else</span><br><span class="line">    echo '当前的UNIX时间戳还没以16开头哦。'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>当我写这个的时候，<code>date &#39;+%s&#39;</code>的值为<code>1587901648</code>，所以运行后走的是<code>else</code>的分支。</p><p>除了用<code>-gt</code>表示大于之外，还有各种各样的其它比较运算符，例如下列的四个运算符</p><table><thead><tr><th>运算符</th><th>作用</th><th>示例代码</th></tr></thead><tbody><tr><td><code>-ge</code></td><td>大于或等于</td><td><code>[ 2 -ge 1 ]</code></td></tr><tr><td><code>-eq</code></td><td>等于</td><td><code>[ 1 -eq 1 ]</code></td></tr><tr><td><code>-le</code></td><td>小于或等于</td><td><code>[ 2 -le 3 ]</code></td></tr><tr><td><code>-lt</code></td><td>小于</td><td><code>[ 3 -lt 4 ]</code></td></tr></tbody></table><p>还有一些“测试”类型的运算符，例如</p><table><thead><tr><th>运算符</th><th>作用</th><th>示例代码</th></tr></thead><tbody><tr><td><code>-b file</code></td><td>测试<code>file</code>是否存在并且是个块设备</td><td><code>[ -b /dev/disk0 ]</code></td></tr><tr><td><code>-c file</code></td><td>测试<code>file</code>是否存在并且是个字符设备</td><td><code>[ -c /dev/tty ]</code></td></tr></tbody></table><h1 id="是shell的语法么？"><a href="#是shell的语法么？" class="headerlink" title="[是shell的语法么？"></a><code>[</code>是shell的语法么？</h1><p>大部分写shell代码的人或许会认为，<code>[]</code>是shell语言用于实现一系列的比较操作的特殊语法。但实际上，<code>[]</code>并不是一个语法——<code>[</code>是一个独立的命令行程序，<code>]</code>则什么都不是，仅仅是一个普通的字符。</p><p>在bash中使用<code>which</code>命令可以看到<code>[</code>的真面目</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/which方括号的结果.jpg" alt=""></p><p><code>[</code>是一个独立的程序，对，你没有看错（鲍尔默脸）。而且<code>[</code>有它自己的man文档</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/方括号的man文档.jpg" alt=""></p><p>在man文档中出现了另外一个命令<code>test</code>，它和<code>[</code>的功能是一模一样的。或许<code>test</code>是一个“yet another [”？真相却更简单一点——<code>test</code>和<code>[</code>是同一个东西</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/左方括号和test是同一个东西.jpg" alt=""></p><h1 id="源代码的二三事"><a href="#源代码的二三事" class="headerlink" title="[源代码的二三事"></a><code>[</code>源代码的二三事</h1><p>可以在GitHub上找到<code>[</code>和<code>test</code>的<a href="https://github.com/freebsd/freebsd/blob/master/bin/test/test.c" target="_blank" rel="noopener">源代码</a>，代码很短，稍微读一下可以发现不少有意思的地方。</p><p>众所周知，如果在shell代码中使用<code>[</code>做比较运算，必须写上对应的右方括号<code>]</code>。但既然<code>[</code>是一个普通的外部程序，那么这个匹配括号的检查显然不会是shell来做的——没错，<code>[</code>自己会检查是否有写上相应的右方括号，这一段逻辑在源文件的<code>main</code>函数开始不久就出现了。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/检测右方括号是否存在.jpg" alt=""></p><p>这个检查只有在程序被以<code>[</code>的名字启动的时候才会生效，所以<code>test 1 -eq 1</code>是不需要写括号的。</p><p>其实除了上文中给出的那些比较和测试运算符之外，<code>[</code>也支持复杂的逻辑运算表达式，比如文章开头的示例代码中的<code>-a</code>就是逻辑与的意思。在代码的注释中还贴心地给出了所接受的参数的BNF</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/test接受的语法.jpg" alt=""></p><p>而解析参数的过程则是一个手写的递归下降语法分析器，在源代码中可以找到与上面的产生式对应的多个函数：<code>oexpr</code>、<code>aexpr</code>、<code>nexpr</code>、<code>primary</code>，以及<code>binop</code>。</p><p>由于在shell语言中，0表示逻辑真，而1表示逻辑假（与C语言相反），所以在<code>main</code>函数中，如果发现传入的第一个参数为感叹号（<code>!</code>，表示逻辑取反），则将<code>oexpr</code>的调用结果直接返回，否则需要将结果取反后再从<code>main</code>函数中返回——给操作系统。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/调用oexpr后取反.jpg" alt=""></p><h1 id="shell真的不原生支持比较？"><a href="#shell真的不原生支持比较？" class="headerlink" title="shell真的不原生支持比较？"></a>shell真的不原生支持比较？</h1><p>尽管在bash中，<code>[</code>的确是作为一个外部程序存在的，但在zsh中却相反</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200426/test作为内置命令.jpg" alt=""></p><p>而且，即使是bash也并非完全没有原生的比较操作——此处需要召唤<code>[[</code>。<code>[[</code>是shell的<em>保留字</em>，它是一个<em>less suprise</em>版本的<code>[</code>，在Stack Overflow上有不少关于它的问答值得一看：</p><ol><li><a href="https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash" target="_blank" rel="noopener">https://stackoverflow.com/questions/3427872/whats-the-difference-between-and-in-bash</a></li><li><a href="https://stackoverflow.com/questions/669452/is-double-square-brackets-preferable-over-single-square-brackets-in-ba" target="_blank" rel="noopener">https://stackoverflow.com/questions/669452/is-double-square-brackets-preferable-over-single-square-brackets-in-ba</a></li></ol><p>第二个链接的回答中还给出了一个值得一看的、关于bash中的“测试”功能的<a href="http://mywiki.wooledge.org/BashGuide/Practices#Bash_Tests" target="_blank" rel="noopener">指引</a>，其中甚至提到了</p><blockquote><p>It can produce surprising results, especially for people starting shell scripting that think [ ] is part of the shell syntax.</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不得不承认，本文标题党了一把，shell还是自身就具备比较大小这样的功能的。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="究竟在干什么系列" scheme="https://liutos.github.io/categories/%E7%A9%B6%E7%AB%9F%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
      <category term="bash" scheme="https://liutos.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>一条正则表达式闹的乌龙</title>
    <link href="https://liutos.github.io/2020/04/20/%E4%B8%80%E6%9D%A1%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%97%B9%E7%9A%84%E4%B9%8C%E9%BE%99/"/>
    <id>https://liutos.github.io/2020/04/20/一条正则表达式闹的乌龙/</id>
    <published>2020-04-20T12:26:47.000Z</published>
    <updated>2020-04-20T13:27:45.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我要编写一个Elisp函数，其核心逻辑涉及到替换字符串中一个符合某种模式的子串。举个例子，字符串为<code>&quot;[2020-02-15 Sat 14:19]《业务逻辑需要关心同步还是异步吗？》&quot;</code>，需要替换的是其中的<code>[2020-02-15 Sat 14:19]</code>。</p><p>这个由日期和时间组成的前缀在每一次我按下<code>C-c c t</code>的时候会自动产生，因为在<code>org-capture-templates</code>中就是这么设置的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> org-capture-templates</span><br><span class="line">      '((<span class="string">"t"</span> <span class="string">"Todo"</span> entry (file+headline <span class="string">"~/Dropbox/gtd/inbox.org"</span> <span class="string">"Tasks"</span>)</span><br><span class="line">         <span class="string">"* TODO %U%?\n  :PROPERTIES:\n  :CREATED_AT: %U\n  :ID: %(uuidgen-4)\n  :END:"</span>)))</span><br></pre></td></tr></table></figure><p>更具体一点，它们产生自其中的转义序列<code>%U</code>（详情可以参见org-mode的文档<a href="https://orgmode.org/manual/Template-expansion.html#Template-expansion" target="_blank" rel="noopener">Template expansion</a>）。</p><p>经过一番不是特别仔细的搜索后，我决定用<code>string-match</code>和<code>replace-match</code>函数来完成上述替换子串的需求。</p><p>然后便闹了两个乌龙。</p><h1 id="string-match不支持扩展的正则语法"><a href="#string-match不支持扩展的正则语法" class="headerlink" title="string-match不支持扩展的正则语法"></a><code>string-match</code>不支持扩展的正则语法</h1><p>为了匹配形如<code>[2020-02-15 Sat 14:19]</code>这样的字符串，我的直觉便驱使我写出了这样的正则表达式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"^\\[\\d+-\\d+-\\d+ \\w+ \\d+:\\d+\\]"</span></span><br></pre></td></tr></table></figure><p>在Node.js或其它支持<a href="https://www.regular-expressions.info/shorthand.html" target="_blank" rel="noopener">Shorthand Character Classes</a>的语言中，上面的正则表达式是可用的。</p><p>但是Elisp偏偏不是这样的语言！（Elisp所支持的正则表达式语法可以参见这篇<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexps.html" target="_blank" rel="noopener">文档</a>）因此，在Elisp中只好用下面这个正则表达式</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"^\\[[0-9]+-[0-9]+-[0-9]+ [A-Za-z]+ [0-9]+:[0-9]+\\]"</span></span><br></pre></td></tr></table></figure><p>虽然Elisp不支持<code>Shorthand Character Classes</code>，但它确实支持<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Char-Classes.html#Char-Classes" target="_blank" rel="noopener"><code>Character Classes</code></a>，但这样写出来的正则表达式更长了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"^\\[[[:digit:]]+-[[:digit:]]+-[[:digit:]]+ [[:alpha:]]+ [[:digit:]]+:[[:digit:]]+\\]"</span></span><br></pre></td></tr></table></figure><p>我猜你宁可写前一种对吧。</p><h1 id="replace-match不返回新字符串"><a href="#replace-match不返回新字符串" class="headerlink" title="replace-match不返回新字符串"></a><code>replace-match</code>不返回新字符串</h1><p>这货是用来修改一个buffer中的内容的……</p><h1 id="一种Workaround"><a href="#一种Workaround" class="headerlink" title="一种Workaround"></a>一种Workaround</h1><p>最后我根据需求的实际情况，综合使用<code>string-match</code>、<code>substring</code>，以及<code>format</code>实现了替换子串的功能</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt-org--starts-with-timestamp-p (<span class="name">text</span>)</span><br><span class="line">  <span class="string">"返回T或NIL表示输入字符串是否以一个inactive timestamp开头。"</span></span><br><span class="line">  <span class="comment">;; Emacs的正则表达式并不支持如\d和\w这样的类，所以要写成[0-9]和[A-Za-z]的形式</span></span><br><span class="line">  (<span class="name">string-match</span> <span class="string">"^\\[[0-9]+-[0-9]+-[0-9]+ [A-Za-z]+ [0-9]+:[0-9]+\\]"</span> text))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-org--delay-timestamp (<span class="name">text</span> new-timestamp)</span><br><span class="line">  <span class="string">"用NEW-TIMESTAMP替换TEXT中的inactive timestamp。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果TEXT没有以inactive timestamp开头，则直接添加NEW-TIMESTAMP。"</span></span><br><span class="line">  (<span class="name">format</span> <span class="string">"%s%s"</span> new-timestamp</span><br><span class="line">          (<span class="name">if</span> (<span class="name">lt-org--starts-with-timestamp-p</span> text)</span><br><span class="line">              (<span class="name">substring</span> text <span class="number">22</span>)</span><br><span class="line">              text)))</span><br></pre></td></tr></table></figure><p>过了很久后，我终于发现了在Elisp中做字符串替换的正确做法……</p><h1 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h1><p>只要用<code>replace-regexp-in-string</code>函数就足够了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">replace-regexp-in-string</span> <span class="string">"^\\[[0-9]+-[0-9]+-[0-9]+ [A-Za-z]+ [0-9]+:[0-9]+\\]"</span> <span class="string">"abc"</span> <span class="string">"[2020-02-15 Sat 14:19]《业务逻辑需要关心同步还是异步吗？》"</span>)</span><br></pre></td></tr></table></figure><p>结果为<code>&quot;abc《业务逻辑需要关心同步还是异步吗？》&quot;</code>，替换很成功。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如何在浩如烟海的知识（搜索引擎、在线文档）中找到自己需要的东西，也是一门学问啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>数据库schema不是CRUD服务的一切</title>
    <link href="https://liutos.github.io/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93schema%E4%B8%8D%E6%98%AFCRUD%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%B8%80%E5%88%87/"/>
    <id>https://liutos.github.io/2020/04/14/数据库schema不是CRUD服务的一切/</id>
    <published>2020-04-14T05:42:22.000Z</published>
    <updated>2020-04-14T13:05:46.751Z</updated>
    
    <content type="html"><![CDATA[<center>谨以本文向我脑海中那些不成熟的想法致敬。</center><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>受疫情影响呆在家中的这段时间里，我收尾了<a href="https://book.douban.com/subject/26915970/" target="_blank" rel="noopener">《Clean Architecture》</a>。这本书给了我许多新知识和启发，包括本文的中心论点——数据库schema不是CRUD服务的一切，也是在读书过程中想到的。在书中，作者的原话是</p><blockquote><p>But the database is not the data model</p></blockquote><p>它出现在书中第六部分《Details》的第一个章节中。作者认为，从架构的角度来看，数据库不是一个实体而是一个细节，不足以成为架构中的一个元素。他甚至打了个比方：数据库对于架构而言，就好像门把手对于房子一般。并且，作者进一步澄清了他的观点：他口中所说的数据库，不是指的数据模型。应用内的数据结构对架构而言至关重要，但数据库并不是数据模型。</p><p>这不禁让我回忆起了自己早期写设计文档的套路。</p><p>在我的从业生涯早期（说得好像我从业很久了一样），每当需要开发一个新的Web服务时，必须先写一份简要的设计文档，向上级清楚地表达我的实现思路，包括：</p><ol><li>如何与其它服务协作完成产品提出的需求；</li><li>服务的接口描述；</li><li>数据的存储结构；</li><li>关键的算法等。</li></ol><p>那时候的我会先考虑数据的存储结构，然后定义接口，最后才是与其它服务的协作。这些早期设计文档的其中一个特点是：接口的响应格式，与数据的存储结构是相同的。</p><p>比方说我要设计一个网上商城的订单服务，可能会提供如下查询特定订单的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /order/:id</span><br></pre></td></tr></table></figure><p>其响应格式可能如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  order: &#123;</span><br><span class="line">    id: <span class="string">'F122663A-A5DC-451A-9B79-92DCE2EE41F1'</span>,</span><br><span class="line">    price: <span class="string">'100.00'</span>,</span><br><span class="line">    products: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        name: <span class="string">'MacBook Pro'</span>,</span><br><span class="line">        price: <span class="string">'19999.00'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        name: <span class="string">'iPhone'</span>,</span><br><span class="line">        price: <span class="string">'6999.00'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保存这种“不平坦”的对象，将会用MongoDB作为存储——除了文档的主键<code>_id</code>之外，其它字段在接口和存储之间一一对应。</p><p>不仅仅是响应格式，在这个Web服务内所操作的也是同样结构的对象。用<a href="https://mongodb.github.io/node-mongodb-native/" target="_blank" rel="noopener">MongoDB Node.JS Driver</a>获得的订单恰好是一个JS对象，它与collection的文档有着一模一样的结构。之后这些对象会在代码内到处流通，不加修饰地使用。定义了数据库schema（就算是用MongoDB也有一套脑内的schema）后，其它的一切也就跟着确定了。</p><p>业界甚至有工具可以直接从数据库得到API，比如<a href="https://github.com/PostgREST/postgrest" target="_blank" rel="noopener">postgrest</a>。</p><p>很多时候，数据库schema成了一个应用内事实上的数据模型。但是，即便它们可以偶然一样，也不要认为它们总应该一样。</p><h1 id="适合存储，不一定适合计算"><a href="#适合存储，不一定适合计算" class="headerlink" title="适合存储，不一定适合计算"></a>适合存储，不一定适合计算</h1><p>以MySQL为例，在<code>CREATE TABLE</code>语句中某一列的类型实际上决定的是存储时分配的空间的多少。但适合存储的类型，并不一定也适合业务逻辑的运算。</p><p>比如说，要在MySQL中存储“开关型”的数据，即诸如“是否启用”或“是否已支付”这样非此即彼的状态时，通常定义为<code>TINYINT</code>类型，用0表示逻辑假（“未启用”和“未支付”），1表示逻辑真（“已启用”和“已支付”）。但对代码而言，比起用数值类型，布尔类型才是更恰当的选择。尤其是当所选择的语言并没有将0与<code>false</code>、1与<code>true</code>等价起来的时候——在Common Lisp中，<code>(if 0 1 2)</code>的求值结果为1。</p><h1 id="适合计算，不一定适合存储"><a href="#适合计算，不一定适合存储" class="headerlink" title="适合计算，不一定适合存储"></a>适合计算，不一定适合存储</h1><p>通常数据结构在内存中比在磁盘上要容易表达得多，所以代码中使用的数据结构会比数据库中存储的要灵活不少，这同样造成了两者的不匹配。</p><p>以我自己开发的提醒工具<a href="https://github.com/Liutos/cuckoo" target="_blank" rel="noopener"><code>cuckoo</code></a>为例，应用内有两种对象：任务和提醒。任务描述了要做的事情，提醒描述了在什么时候该告诉用户。显然，提醒是一个依赖于任务的弱实体。在cuckoo的代码中，任务是<code>Task</code>类的实例对象，有一个名为<code>remind</code>的成员变量存储着提醒。</p><p>但这样的结构不方便存储在MySQL中。遵照关系型数据库设计的第一范式，任务和提醒分别被存储在<code>t_task</code>和<code>t_remind</code>表中，两者通过<code>t_task.remind_id</code>联系起来。</p><p>当然，也可以在一开始就用MongoDB来存储这些数据（甚至可以用对象数据库？不过我没玩过）。尤其是cuckoo只是一个小玩意儿，MySQL和MongoDB都足以胜任。但作为一名有理想的程序员，在做设计的时候，不应该让低层细节过分干预高层策略。（在《Clean Architecture》中，越是接近I/O的越是low-level，反之则是high-level。）</p><h1 id="面向业务逻辑，而非存储结构"><a href="#面向业务逻辑，而非存储结构" class="headerlink" title="面向业务逻辑，而非存储结构"></a>面向业务逻辑，而非存储结构</h1><p>业务逻辑和规则才是一个服务的核心，应该把更多精力花在实现业务逻辑的数据结构和算法上。</p><p>以网上商城中常见的优惠券功能为例。优惠券服务所管理的优惠券往往有着各种效果、条件，以及限制。为了保持灵活性，优惠券类（下称<code>Coupon</code>）的实例对象中会有三种接口类型的成员变量：</p><ol><li><code>Effect</code>类型的变量<code>effect</code>，负责实现优惠效果的计算逻辑；</li><li><code>Condition</code>数组类型的变量<code>conditions</code>，负责实现使用条件的检查逻辑；</li><li><code>Restriction</code>数组类型的变量<code>restrictions</code>，负责实现使用限制的检查逻辑。</li></ol><p>三个接口可以有各种各样的实现——定额减免、折扣减免、某年月日前可用、不可用于电子产品，等等。如此，优惠券功能具备了极大的灵活性，业务可以随心所欲，产品可以为所欲为，老板数钱数到手软，公司业绩蒸蒸日上。</p><p>那么如何存储<code>Effect</code>、<code>Condition</code>、<code>Restriction</code>、<code>Coupon</code>类的实例对象呢？没有唯一的选择，既可以存储在MySQL中，也可以存储在MongoDB中，或者别的什么数据库中。不管这些数据最终如何持久化，都不会影响作为高层策略的优惠券业务逻辑。反过来，如果在代码中处理的不是类、接口，以及实例对象，而是直接从数据库中取出来的、贫血模型的行（或文档），处理起来就不是很优雅了——可以预见 ，代码中会充斥着许多的<code>if-else</code>判断逻辑。</p><p>数据库只是帮忙从磁盘中读取数据的软件，它的schema不应该直接成为应用的数据模型。</p><h1 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h1><p>不应该在HTTP接口的响应中直接暴露数据库的schema。</p><p>不说别的，光是数据库schema与接口规格所使用的命名规则就足以造成差异了。也许在MySQL中用<a href="https://en.wikipedia.org/wiki/Snake_case" target="_blank" rel="noopener"><code>snake case</code></a>命名一列，却又在HTTP响应的JSON对象中用<a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank" rel="noopener"><code>camel case</code></a>命名字段。</p><p>此外，除非这些接口仅仅实现增删查改、没有任何的业务逻辑或规则，否则一个服务更应当提供与业务需求恰好契合的接口。仍然以上文的优惠券服务为例，尽管内部可能<code>Effect</code>、<code>Condition</code>、<code>Restriction</code>、<code>Coupon</code>等诸多概念，但<del>煮不在乎</del>用户不在乎，他们只想看到用人话说出来的优惠券效果以及使用规则——用户甚至不关心条件和限制有何不同。</p><p>如果优惠券服务直接将数据库中的行（或文档）序列化成JSON返回给调用者，会导致封装的泄露。每一个查询优惠券的调用方，都必须了解优惠券的内部表示形式，必须知道效果由<code>effect</code>描述、用券后的订单金额是多少、<code>conditions</code>中有关于过期与否的信息，等等。每增加一个优惠券服务的使用者，就相应地增加一套描述这些内容的代码。甚至当优惠券服务自身重构的时候，也许牵连到众多的调用方。</p><p>如果直接将存储结构暴露给调用者的话，又何必再做一个Web服务呢。</p><h1 id="切勿矫枉过正"><a href="#切勿矫枉过正" class="headerlink" title="切勿矫枉过正"></a>切勿矫枉过正</h1><p>的确存在这样的例子，数据库schema、数据模型，以及HTTP响应结构三者相同。这是因为比起维护数据库schema与数据模型的转换规则，以及DTO与数据模型的转换规则而言，在领域代码中直接使用数据库schema来表达数据模型的成本更低一点。尽管数据库schema不是Web服务的一切，但很多时候可以因地制宜地妥协一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="database" scheme="https://liutos.github.io/tags/database/"/>
    
      <category term="mysql" scheme="https://liutos.github.io/tags/mysql/"/>
    
      <category term="数据库" scheme="https://liutos.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="architecture" scheme="https://liutos.github.io/tags/architecture/"/>
    
      <category term="架构" scheme="https://liutos.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>改良在Emacs中浏览笔记的方式</title>
    <link href="https://liutos.github.io/2020/03/29/%E6%94%B9%E8%89%AF%E5%9C%A8Emacs%E4%B8%AD%E6%B5%8F%E8%A7%88%E7%AC%94%E8%AE%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://liutos.github.io/2020/03/29/改良在Emacs中浏览笔记的方式/</id>
    <published>2020-03-29T08:56:39.000Z</published>
    <updated>2020-03-29T09:00:07.194Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><p>半年前我在<a href="https://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/">这篇文章</a>中展示了在Emacs中查阅笔记的效果——用<a href="https://github.com/tkf/emacs-request" target="_blank" rel="noopener">emacs-request</a>请求ElasticSearch查询关键字、基于<a href="https://github.com/emacs-helm/helm" target="_blank" rel="noopener">helm</a>以下拉菜单的方式展示查询结果的标题（即问题），最后打开浏览器查看笔记内容。稍加使用就发现一些不足之处：</p><ol><li>需要离开Emacs打开浏览器。我更希望能在Emacs中查看；</li><li>ES的响应内容为JSON，要快速地辨认出<code>question</code>和<code>answer</code>字段比较困难；</li><li>一个问题的答案往往是多行的，但在浏览器中<code>answer</code>字段是以一行的形式展示的，不利于阅读。</li></ol><p>为了解决这些问题，我实现了一种新的查看笔记内容的方式。</p><h1 id="改良后的效果"><a href="#改良后的效果" class="headerlink" title="改良后的效果"></a>改良后的效果</h1><a id="more"></a><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200329/改良后的笔记查阅方式.mp4" type="video/mp4"><br></video><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>我的目标是：</p><ol><li>在不脱离Emacs的情况下浏览笔记内容；</li><li>提供org-mode的语法高亮。</li></ol><p>为此，先用被选中笔记的<code>_id</code>请求ES，取回完整的JSON。接着，将<code>_source</code>中的<code>question</code>和<code>answer</code>字段的内容拼接在一起（以<code>\n</code>作为分隔符）。最后，在Emacs中新建一个buffer、启用org-mode、插入拼接后的内容，并设置该buffer为只读。大功告成！</p><p>完整的代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 调用ElasticSearch查询笔记</span></span><br><span class="line">(<span class="name">require</span> 'request)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq (<span class="name">query</span>)</span><br><span class="line">  <span class="string">"向ElasticSearch查询QUERY匹配的笔记"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">response</span>))</span><br><span class="line">    (<span class="name">request</span></span><br><span class="line">     <span class="string">"http://localhost:9200/faq/_search"</span></span><br><span class="line">     <span class="symbol">:data</span> (<span class="name">encode-coding-string</span></span><br><span class="line">            (<span class="name">json-encode</span></span><br><span class="line">             (<span class="name">list</span></span><br><span class="line">              (<span class="name">cons</span> <span class="string">"query"</span> (<span class="name">list</span></span><br><span class="line">                             (<span class="name">cons</span> <span class="string">"multi_match"</span> (<span class="name">list</span></span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"fields"</span> (<span class="name">list</span> <span class="string">"answer"</span> <span class="string">"question"</span>))</span><br><span class="line">                                                  (<span class="name">cons</span> <span class="string">"query"</span> query)))))))</span><br><span class="line">            'utf-8)</span><br><span class="line">     <span class="symbol">:headers</span> '((<span class="string">"Content-Type"</span> . <span class="string">"application/json"</span>))</span><br><span class="line">     <span class="symbol">:parser</span> 'buffer-string</span><br><span class="line">     <span class="symbol">:success</span> (<span class="name">cl-function</span></span><br><span class="line">               (<span class="name">lambda</span> (<span class="name">&amp;key</span> data <span class="symbol">&amp;allow-other-keys</span>)</span><br><span class="line">                 (<span class="name">setq</span> data (<span class="name">decode-coding-string</span> data 'utf-8))</span><br><span class="line">                 (<span class="name">setq</span> response (<span class="name">json-read-from-string</span> data))))</span><br><span class="line">     <span class="symbol">:sync</span> <span class="literal">t</span>)</span><br><span class="line">    response))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> make-faq-candidates (<span class="name">response</span>)</span><br><span class="line">  <span class="string">"将查询ElasticSearch的结果构造为helm可以识别的candidates格式"</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">hits</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits (<span class="name">cdr</span> (<span class="name">assoc</span> 'hits response))))))</span><br><span class="line">    (<span class="name">mapcar</span> (<span class="name">lambda</span> (<span class="name">doc</span>)</span><br><span class="line">              (<span class="name">let</span> ((<span class="name">_source</span> (<span class="name">cdr</span> (<span class="name">assoc</span> '_source doc))))</span><br><span class="line">                (<span class="name">cons</span> (<span class="name">cdr</span> (<span class="name">assoc</span> 'question _source))</span><br><span class="line">                      <span class="comment">;; (cdr (assoc 'answer (assoc '_source doc)))</span></span><br><span class="line">                      (<span class="name">cdr</span> (<span class="name">assoc</span> '_id doc)))))</span><br><span class="line">            hits)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> faq-query <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> faq-candidates ()</span><br><span class="line">  (<span class="name">make-faq-candidates</span> (<span class="name">faq</span> faq-query)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;; 创建新的buffer并将ElasticSearch的内容展示在其中</span></span><br><span class="line">(<span class="name">defun</span> show-faq (<span class="name">text</span>)</span><br><span class="line">  <span class="comment">;; 创建一个buffer，显示它并选中这个窗口</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">buffer</span> (<span class="name">get-buffer-create</span> <span class="string">"*FAQ*"</span>)))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">window</span> (<span class="name">display-buffer</span> buffer)))</span><br><span class="line">      (<span class="name">select-window</span> window)</span><br><span class="line">      <span class="comment">;; 用新的内容覆盖原来的内容</span></span><br><span class="line">      (<span class="name">setq</span> inhibit-read-only <span class="literal">t</span>)</span><br><span class="line">      (<span class="name">org-mode</span>)</span><br><span class="line">      (<span class="name">erase-buffer</span>)</span><br><span class="line">      (<span class="name">insert</span> text)</span><br><span class="line">      (<span class="name">read-only-mode</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> faq-helm-sources</span><br><span class="line">      `((name . <span class="string">"FAQ at Emacs"</span>)</span><br><span class="line">        (candidates . faq-candidates)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    (let (response</span><br><span class="line">                          (url (format <span class="string">"http://localhost:9200/faq/_doc/%s"</span> candidate)))</span><br><span class="line">                      (message <span class="string">"url is %s"</span> url)</span><br><span class="line">                      (request</span><br><span class="line">                       url</span><br><span class="line">                       :parser 'buffer-string</span><br><span class="line">                       :success (cl-function</span><br><span class="line">                                 (lambda (&amp;key data &amp;allow-other-keys)</span><br><span class="line">                                   (setq data (decode-coding-string data 'utf-8))</span><br><span class="line">                                   (setq response (json-read-from-string data))))</span><br><span class="line">                       :sync <span class="literal">t</span>)</span><br><span class="line">                      ;; 从文档中提取出问题和答案，拼装成原本在.org文件中的模样</span><br><span class="line">                      (let ((answer (cdr (assoc 'answer (assoc '_source response))))</span><br><span class="line">                            (question (cdr (assoc 'question (assoc '_source response)))))</span><br><span class="line">                        (show-faq</span><br><span class="line">                         (concat question <span class="string">"\n"</span> answer))))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-ask ()</span><br><span class="line">  <span class="string">"交互式地从minibuffer中读取笔记的关键词并展示选项"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">content</span> (<span class="name">read-from-minibuffer</span> <span class="string">"笔记关键词："</span>)))</span><br><span class="line">    (<span class="name">setq</span> faq-query content)</span><br><span class="line">    (<span class="name">helm</span> <span class="symbol">:sources</span> '(faq-helm-sources))))</span><br></pre></td></tr></table></figure><p>与之前版本的差异主要在于：</p><ol><li>变量<code>faq-helm-sources</code>中的<code>action</code>部分多了很多内容，主要是请求ES和拼接字段；</li><li>新增了<code>show-faq</code>函数用于显示问题及其答案。</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>挺好奇各位读者朋友是怎么记笔记和看笔记的XD</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;半年前我在&lt;a href=&quot;https://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/&quot;&gt;这篇文章&lt;/a&gt;中展示了在Emacs中查阅笔记的效果——用&lt;a href=&quot;https://github.com/tkf/emacs-request&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;emacs-request&lt;/a&gt;请求ElasticSearch查询关键字、基于&lt;a href=&quot;https://github.com/emacs-helm/helm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;helm&lt;/a&gt;以下拉菜单的方式展示查询结果的标题（即问题），最后打开浏览器查看笔记内容。稍加使用就发现一些不足之处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要离开Emacs打开浏览器。我更希望能在Emacs中查看；&lt;/li&gt;
&lt;li&gt;ES的响应内容为JSON，要快速地辨认出&lt;code&gt;question&lt;/code&gt;和&lt;code&gt;answer&lt;/code&gt;字段比较困难；&lt;/li&gt;
&lt;li&gt;一个问题的答案往往是多行的，但在浏览器中&lt;code&gt;answer&lt;/code&gt;字段是以一行的形式展示的，不利于阅读。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决这些问题，我实现了一种新的查看笔记内容的方式。&lt;/p&gt;
&lt;h1 id=&quot;改良后的效果&quot;&gt;&lt;a href=&quot;#改良后的效果&quot; class=&quot;headerlink&quot; title=&quot;改良后的效果&quot;&gt;&lt;/a&gt;改良后的效果&lt;/h1&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>我是怎么把笔记导入ElasticSearch的</title>
    <link href="https://liutos.github.io/2020/03/26/%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%85%A5ElasticSearch%E7%9A%84/"/>
    <id>https://liutos.github.io/2020/03/26/我是怎么把笔记导入ElasticSearch的/</id>
    <published>2020-03-26T14:51:56.000Z</published>
    <updated>2020-03-26T15:01:26.980Z</updated>
    
    <content type="html"><![CDATA[<p>尽管我最近开始用<a href="https://github.com/tamlok/vnote" target="_blank" rel="noopener">VNote</a>做读书或读在线文档的笔记，但更多的时候，我把经验型知识都记录在一个名为<code>my_note</code>的Git仓库中。这个仓库中有许多.org`文件：</p><ol><li><code>TeX.org</code>，记录与<code>LaTeX</code>相关的问题和解决方法；</li><li><code>asm.org</code>，记录的是与编写汇编语言程序相关的问题和解决办法；</li><li><code>cl.org</code>，记录的是与编写Common Lisp代码相关的问题和解决办法；</li></ol><p>这些内容被我称为FAQ。尽管不同的文件记载着不同方面的内容，但它们的格式是一致的：</p><ol><li>每个文件都以org-mode的语法书写；</li><li>文件中只有一级条目，没有嵌套；</li><li>每一个条目的标题就是一个问题的表述，下方的文字则是这个问题的答案。</li></ol><p>A picture is worth a thousand words</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200326/TeX笔记中的内容.jpeg" alt=""></p><p>这些问题都比较常见（不然怎么叫FAQ呢——也许上图的不算常见吧），回过头来查找的机率很高。显然，在纷繁复杂的文字中凭肉眼寻找关键字是低效的，即使是祭出<code>grep</code>，用正则表达式这样的大杀器来查找也不是特别称手——因为并不知道怎样的正则表达式可以匹配到寻找的内容——也许多写了关键词，也许少写了，也许顺序不对。</p><p>对于搜索这类非结构的文字资料来说，全文检索是一个更好的选择，因此，我是把这些内容丢进ElasticSearch里再查找的。</p><h1 id="解析并导入到ElasticSearch"><a href="#解析并导入到ElasticSearch" class="headerlink" title="解析并导入到ElasticSearch"></a>解析并导入到ElasticSearch</h1><a id="more"></a><p>FAQ中的每一个条目，都对应ElasticSearch中的一个文档，它们都存储在索引<code>faq</code>中。一个文档有如下的字段：</p><ol><li><code>answer</code>，即问题的答案；</li><li><code>path</code>，文件绝对路径，表示文档来自于哪一个文件中的条目；</li><li><code>question</code>，即问题的描述；</li><li><code>questionLineNum</code>，即问题存在于文件的第几行。</li></ol><p>解析这些文件的逻辑也很简单：每当读入行首为星号的一行后（这一行即为问题），便继续读入后续的每一行直到再次遇到行首为星号的行为止，这些后续读入的行组成了这个问题的答案。有了问题和答案，便可以导入到ElasticSearch中。最终的脚本如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'co-request'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseFaqOrg</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(path).toString(<span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="keyword">const</span> lines = content.split(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">const</span> qas = [];</span><br><span class="line">  <span class="keyword">let</span> answer = [];</span><br><span class="line">  <span class="keyword">let</span> lineNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> mode;</span><br><span class="line">  <span class="keyword">let</span> question;</span><br><span class="line">  <span class="keyword">let</span> questionLineNum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> lines) &#123;</span><br><span class="line">    lineNum += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (line.startsWith(<span class="string">'*'</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mode === <span class="string">'answer'</span>) &#123;</span><br><span class="line">        <span class="comment">// 在遇到星号的时候模式已经处于answer中，说明在此之前还有未处理的QA</span></span><br><span class="line">        qas.push(&#123;</span><br><span class="line">          answer: answer.join(<span class="string">'\n'</span>),</span><br><span class="line">          path,</span><br><span class="line">          question,</span><br><span class="line">          questionLineNum</span><br><span class="line">        &#125;);</span><br><span class="line">        answer = [];</span><br><span class="line">        question = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mode = <span class="string">'question'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mode = <span class="string">'answer'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mode === <span class="string">'answer'</span>) &#123;</span><br><span class="line">      answer.push(line);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      question = line;</span><br><span class="line">      questionLineNum = lineNum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (question) &#123;</span><br><span class="line">    qas.push(&#123;</span><br><span class="line">      answer: answer.join(<span class="string">'\n'</span>),</span><br><span class="line">      question</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(JSON.stringify(qas, null, 2));</span></span><br><span class="line">  <span class="keyword">return</span> qas;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dropFaq</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> request(&#123;</span><br><span class="line">    method: <span class="string">'delete'</span>,</span><br><span class="line">    url: <span class="string">'http://localhost:9200/faq'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重建faq索引并写入全量的笔记数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line">  <span class="keyword">await</span> dropFaq();</span><br><span class="line">  <span class="keyword">const</span> dir = <span class="string">'/Users/liutos/Documents/Projects/my_note/faq/'</span>;</span><br><span class="line">  <span class="keyword">const</span> basenames = fs.readdirSync(dir);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> basename <span class="keyword">of</span> basenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> path = dir + basename;</span><br><span class="line">    <span class="keyword">const</span> type = basename.match(<span class="regexp">/(.*)\.org/</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> qas = parseFaqOrg(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> qa <span class="keyword">of</span> qas) &#123;</span><br><span class="line">      <span class="keyword">await</span> request(&#123;</span><br><span class="line">        body: qa,</span><br><span class="line">        json: <span class="literal">true</span>,</span><br><span class="line">        method: <span class="string">'post'</span>,</span><br><span class="line">        url: <span class="string">'http://localhost:9200/faq/_doc'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`文件<span class="subst">$&#123;path&#125;</span>处理完毕`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果想知道我是如何在Emacs中查询这些FAQ的，可以参见<a href="http://liutos.github.io/2019/10/20/%E5%9C%A8Emacs%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0%E6%9F%A5%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%9D%E8%AF%95/">《在Emacs中搭建笔记查阅系统的尝试》</a>这篇文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管我最近开始用&lt;a href=&quot;https://github.com/tamlok/vnote&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VNote&lt;/a&gt;做读书或读在线文档的笔记，但更多的时候，我把经验型知识都记录在一个名为&lt;code&gt;my_note&lt;/code&gt;的Git仓库中。这个仓库中有许多.org`文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TeX.org&lt;/code&gt;，记录与&lt;code&gt;LaTeX&lt;/code&gt;相关的问题和解决方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;asm.org&lt;/code&gt;，记录的是与编写汇编语言程序相关的问题和解决办法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cl.org&lt;/code&gt;，记录的是与编写Common Lisp代码相关的问题和解决办法；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些内容被我称为FAQ。尽管不同的文件记载着不同方面的内容，但它们的格式是一致的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个文件都以org-mode的语法书写；&lt;/li&gt;
&lt;li&gt;文件中只有一级条目，没有嵌套；&lt;/li&gt;
&lt;li&gt;每一个条目的标题就是一个问题的表述，下方的文字则是这个问题的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A picture is worth a thousand words&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200326/TeX笔记中的内容.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些问题都比较常见（不然怎么叫FAQ呢——也许上图的不算常见吧），回过头来查找的机率很高。显然，在纷繁复杂的文字中凭肉眼寻找关键字是低效的，即使是祭出&lt;code&gt;grep&lt;/code&gt;，用正则表达式这样的大杀器来查找也不是特别称手——因为并不知道怎样的正则表达式可以匹配到寻找的内容——也许多写了关键词，也许少写了，也许顺序不对。&lt;/p&gt;
&lt;p&gt;对于搜索这类非结构的文字资料来说，全文检索是一个更好的选择，因此，我是把这些内容丢进ElasticSearch里再查找的。&lt;/p&gt;
&lt;h1 id=&quot;解析并导入到ElasticSearch&quot;&gt;&lt;a href=&quot;#解析并导入到ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;解析并导入到ElasticSearch&quot;&gt;&lt;/a&gt;解析并导入到ElasticSearch&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>弥补org-refile的不足</title>
    <link href="https://liutos.github.io/2020/03/21/%E5%BC%A5%E8%A1%A5org-refile%E7%9A%84%E4%B8%8D%E8%B6%B3/"/>
    <id>https://liutos.github.io/2020/03/21/弥补org-refile的不足/</id>
    <published>2020-03-21T09:10:57.000Z</published>
    <updated>2020-03-21T09:12:59.657Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A#%E6%90%9C%E9%9B%86" target="_blank" rel="noopener">GTD</a>的第一条原则是“搜集”，为此我有一个<code>inbox.org</code>文件，专门记录所有的新想法、新任务。我会在每晚的固定时间处理其中的内容——有些可以马上开始做并做完，更多的则是移动到其它<code>.org</code>文件中，等待排期。</p><p>org-mode有一个内置的快捷键<code>C-c C-w</code>，专门完成将条目（org-mode的术语，即<code>.org</code>文件中带星号前缀的一行，参见<a href="https://orgmode.org/worg/org-glossary.html#entry" target="_blank" rel="noopener">An Explanation of Basic Org-Mode Concepts</a>）移动到其它<code>.org</code>文件的需求，但它有一个缺陷——不能把条目移动到其它<code>.org</code>文件的顶层，而这是我经常需要做的。</p><p>为了移动到顶层，需要：</p><ol><li>使用<code>org-cut-subtree</code>命令剪切当前条目（其实还会包括条目的子节点，但<code>inbox.org</code>中的条目基本上都没有子节点）；</li><li>打开目标的<code>.org</code>文件；</li><li>将光标定位到文件末尾；</li><li>使用<code>org-paste-subtree</code>命令粘贴条目。</li></ol><p>为了轻松完成上述四个步骤，<code>org-refile-to-eof</code>函数应运而生。</p><a id="more"></a><h1 id="org-refile-to-eof函数"><a href="#org-refile-to-eof函数" class="headerlink" title="org-refile-to-eof函数"></a>org-refile-to-eof函数</h1><p>废话不多说，直接亮相吧</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; 定义一个Helm的source，以便选择要粘贴的.org文件</span></span><br><span class="line">(<span class="name">defvar</span> *org-refile-eof--helm-source* <span class="literal">nil</span></span><br><span class="line">  <span class="string">"用于提供目标.org文件下拉菜单的来源"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;; 将当前条目剪切并粘贴到某个目标.org文件的末尾</span></span><br><span class="line">(<span class="name">defun</span> org-refile-to-eof ()</span><br><span class="line">  <span class="string">"将当前条目剪切到一个.org文件的末尾。"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  <span class="comment">;; 先调用Helm获取目标.org文件。这里需要处理没有选中任何文件的情况</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">path</span> (<span class="name">helm</span> <span class="symbol">:sources</span> '(*org-refile-eof--helm-source*))))</span><br><span class="line">    (<span class="name">when</span> path</span><br><span class="line">      (<span class="name">org-cut-subtree</span>)</span><br><span class="line">      (<span class="name">save-excursion</span></span><br><span class="line">        <span class="comment">;; 打开选中的文件的buffer，并移动到最后</span></span><br><span class="line">        (<span class="name">find-file</span> path)</span><br><span class="line">        (<span class="name">end-of-buffer</span>)</span><br><span class="line">        <span class="comment">;; 调用org-paste-subtree粘贴进去</span></span><br><span class="line">        (<span class="name">org-paste-subtree</span>)))))</span><br></pre></td></tr></table></figure><p>变量<code>*org-refile-eof--helm-source*</code>定义了<code>helm</code>函数所要求的下拉列表名称、选项，以及选中后的处理逻辑（Helm的使用可以从<a href="http://wikemacs.org/wiki/How_to_write_helm_extensions" target="_blank" rel="noopener">How to write helm extension</a>入门）。在我的环境中，它的值是</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> *org-refile-eof--helm-source*</span><br><span class="line">      '((name . <span class="string">"refile到下列的哪个文件"</span>)</span><br><span class="line">        (candidates . org-agenda-files)</span><br><span class="line">        (action . (lambda (candidate)</span><br><span class="line">                    candidate))))</span><br></pre></td></tr></table></figure><p>现在，只需要敲入<code>M-: org-refile-to-eof RET</code>便能轻松完成之前繁琐的四个步骤。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果有迫切需求的话，我会考虑将<code>org-refile</code>（也就是<code>C-c C-w</code>对应的命令）和<code>org-refile-to-eof</code>合并在一起。例如，按下<code>C-c C-w</code>时调用的是<code>org-refile</code>，而按下<code>C-u C-c C-w</code>时调用的则是<code>org-refile-to-eof</code>，想想也有点小激动呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%BD%E7%AE%A1%E5%8E%BB%E5%81%9A#%E6%90%9C%E9%9B%86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GTD&lt;/a&gt;的第一条原则是“搜集”，为此我有一个&lt;code&gt;inbox.org&lt;/code&gt;文件，专门记录所有的新想法、新任务。我会在每晚的固定时间处理其中的内容——有些可以马上开始做并做完，更多的则是移动到其它&lt;code&gt;.org&lt;/code&gt;文件中，等待排期。&lt;/p&gt;
&lt;p&gt;org-mode有一个内置的快捷键&lt;code&gt;C-c C-w&lt;/code&gt;，专门完成将条目（org-mode的术语，即&lt;code&gt;.org&lt;/code&gt;文件中带星号前缀的一行，参见&lt;a href=&quot;https://orgmode.org/worg/org-glossary.html#entry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;An Explanation of Basic Org-Mode Concepts&lt;/a&gt;）移动到其它&lt;code&gt;.org&lt;/code&gt;文件的需求，但它有一个缺陷——不能把条目移动到其它&lt;code&gt;.org&lt;/code&gt;文件的顶层，而这是我经常需要做的。&lt;/p&gt;
&lt;p&gt;为了移动到顶层，需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;org-cut-subtree&lt;/code&gt;命令剪切当前条目（其实还会包括条目的子节点，但&lt;code&gt;inbox.org&lt;/code&gt;中的条目基本上都没有子节点）；&lt;/li&gt;
&lt;li&gt;打开目标的&lt;code&gt;.org&lt;/code&gt;文件；&lt;/li&gt;
&lt;li&gt;将光标定位到文件末尾；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;org-paste-subtree&lt;/code&gt;命令粘贴条目。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了轻松完成上述四个步骤，&lt;code&gt;org-refile-to-eof&lt;/code&gt;函数应运而生。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>程序员的记账工具——ledger与ledger-mode</title>
    <link href="https://liutos.github.io/2020/03/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%AE%B0%E8%B4%A6%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94ledger%E4%B8%8Eledger-mode/"/>
    <id>https://liutos.github.io/2020/03/19/程序员的记账工具——ledger与ledger-mode/</id>
    <published>2020-03-19T14:40:01.000Z</published>
    <updated>2020-03-19T14:44:49.754Z</updated>
    
    <content type="html"><![CDATA[<p>上大学后不久我开始用挖财记账，当时记得很随意，不会去追究一些不知道花在哪里的钱，不时就要强行修正账户余额，就这么一直用到了2019年中。后来挖财的启动时间越来越长，同时我不想看启动时的广告，便动了换记账软件的念头。</p><p>本想着试试<a href="https://wiz.money/" target="_blank" rel="noopener">MoneyWiz</a>，但其价格令人望而却步，于是决定继续物色免费的记账工具，不久便遇到了<a href="https://www.gnucash.org/index.phtml?lang=zh_CN" target="_blank" rel="noopener">GnuCash</a>。由于它是GNU出品的，让我对其一开始便比较有好感，加上想尝试一下复式记账，便在同年9月份换到了GnuCash上。</p><p>可惜好景不长，我很快便发现了GnuCash的不足：</p><ol><li>启动速度随着录入数据的增多显著变慢；</li><li>UI不够美观；</li><li>比较依赖鼠标操作；</li><li>交易时间的精度只到天，且无法轻松调整一笔交易的位置——这一点是我尤其在意的，因为着意味着一旦我有一笔交易漏记了，再追加回去后，整个账本的交易数据次序也与银行记录的不一致了。</li></ol><p>于是我抛弃了GnuCash，投向了ledger（以及ledger-mode）的怀抱。</p><h1 id="ledger和ledger-mode"><a href="#ledger和ledger-mode" class="headerlink" title="ledger和ledger-mode"></a>ledger和ledger-mode</h1><a id="more"></a><h2 id="ledger"><a href="#ledger" class="headerlink" title="ledger"></a>ledger</h2><p><a href="https://www.ledger-cli.org/" target="_blank" rel="noopener">ledger</a>是一个基于复式记账的、生成财务报表的命令行程序——它不具备录入的功能，它只生成报表。</p><p>要使用ledger，必须先将交易数据按它的语法写在一个文本文件中，然后才用ledger读取这个文件，生成各种各样的报表。百闻不如一见，下图便是ledger生成的报表</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/WX20200308-213943@2x.jpeg" alt=""></p><h2 id="ledger-mode"><a href="#ledger-mode" class="headerlink" title="ledger-mode"></a>ledger-mode</h2><p>记录交易数据的源文件是纯文本格式的，可以用任何文本编辑器（text editor，不是word processor）来编辑。如果打算用Emacs，那么就不容错过<a href="https://github.com/ledger/ledger-mode" target="_blank" rel="noopener">ledger-mode</a>了。</p><p>ledger-mode是一个Emacs主模式，为编辑ledger的源文件（一般以<code>ledger</code>为后缀名）提供诸多便利。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/交易明细源文件.jpeg" alt=""></p><p>比如在上图中，ledger提供了语法高亮：日期（<code>2020-03-04</code>）和描述（<code>利口福</code>）是红色的，金额（<code>-32</code>）和货币（<code>CNY</code>）是紫色的，注释（分号及其后面的内容）是灰色的。ledger-mode还提供自动缩进，在输入了<code>利口福</code>并回车后，光标会自动定位到字母<code>L</code>的位置，下一行也是如此——连续敲入两个回车得到一行空行，标志着一笔交易记录结束。ledger-mode还支持在Emacs内查看ledger输出的报表（见下文）。</p><h1 id="ledger的优势"><a href="#ledger的优势" class="headerlink" title="ledger的优势"></a>ledger的优势</h1><p>用ledger记账至少有以下优势：</p><ol><li>交易数据保存在本地，有利于保护用户的隐私；</li><li>交易数据保存为纯文本文件，用户可以依自己的喜好选择编辑工具（比如我就喜欢用Emacs），即使哪天ledger没法用了，这些数据也依旧可以查看；</li><li>ledger支持自由定制符合个人习惯的资产和支出的层级。例如，我在<code>Assets</code>账户下细分了<code>Checking</code>和<code>Investment</code>子账户分别囊括消费和投资账户；<code>Checking</code>下细分了三个储蓄卡、微信零钱，及支付宝余额账户；<code>Investment</code>下细分了<code>Fund</code>和<code>WMP</code>，分别表示基金和银行理财产品；<code>Expense</code>下有一个<code>Food</code>，从上面的截图中可以看到，<code>Food</code>下进一步分了十个子账户——只要愿意，就可以随意定制账户名称和层级；</li><li>ledger支持给每一笔交易添加<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Metadata" target="_blank" rel="noopener">元数据</a>，其中一种便是<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Metadata-tags" target="_blank" rel="noopener">tag</a>（标签）。tag增强了ledger生成报表的灵活度，比如我给在公司点外卖的支出打上<code>:公司:</code>的tag后，便可以让ledger只生成在公司就餐的支出报表；</li></ol><h1 id="ledger的用法"><a href="#ledger的用法" class="headerlink" title="ledger的用法"></a>ledger的用法</h1><h2 id="初始化账户"><a href="#初始化账户" class="headerlink" title="初始化账户"></a>初始化账户</h2><p>用ledger记账，要先初始化每个账户的余额。基于复式记账的原则，ledger要求每一笔交易中所有账户的金额变化之和为0，因此若要往储蓄卡资产账户中“充值”，就必须从另一个账户中减去等额的钱。在ledger中，这个“另一个账户”便是<code>Equity</code>。（在ledger的在线文档中有一个章节<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Understanding-Equity" target="_blank" rel="noopener">Understanding Equity</a>可以帮助理解）。</p><p>所以，初始化账户余额就是添加一笔交易，将与账户余额等量的钱从<code>Equity:Opening Balance</code>流到<code>Assets</code>下的细分账户中，如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/初始化账户.jpeg" alt=""></p><p>尽管在上图中，金额<code>123</code>后的货币为<code>CNY</code>，但ledger并不理解这三个字母是否真的为合法的货币名称——ledger只要求用户指定了即可。（可以参见ledger在线文档的<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Commodities-and-Currencies" target="_blank" rel="noopener">Commodities and Currencies</a>章节）</p><p>PS：在上图中没有明确写出<code>Equity:Opening Balance</code>的变化为<code>-123 CNY</code>，是因为ledger足够“聪明”，可以自己补足这个信息。</p><p>现在可以用ledger输出报表了</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/第一次查看资产余额.jpeg" alt=""></p><h2 id="记录第一笔交易"><a href="#记录第一笔交易" class="headerlink" title="记录第一笔交易"></a>记录第一笔交易</h2><p>有了钱便可以开始买买买了。假设早餐在楼下肠粉店花了6块钱吃了一份鸡蛋肠，可以记为</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/记录第一笔早餐消费.jpeg" alt=""></p><p>用ledger输出新的资产报表</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/一笔交易后的总资产.jpeg" alt=""></p><p>还可以用ledger输出支出账户的明细，示例代码为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledger -f a.ledger register 'Expense'</span><br></pre></td></tr></table></figure><h2 id="其它报表命令"><a href="#其它报表命令" class="headerlink" title="其它报表命令"></a>其它报表命令</h2><p>除了查看资产余额和支出明细之外，我常用的报表还包括：</p><ol><li><code>ledger -f a.txt balance ^assets and \( not 公积金 \) or ^liabilities</code>，查看不含公积金的资产和负债的余额，主要用于核对账本（<code>a.txt</code>文件）与银行卡、信用卡余额是否一致；</li><li><code>ledger -S &#39;-date&#39; -f ~/Dropbox/Accounting/a.txt register Liabilities</code>，查看信用卡的交易明细，用于在账单日核对银行的信用卡账单明细。参数<code>-S &#39;date&#39;表示按日期由近及远、从上往下排序</code>；</li><li><code>ledger -e 10/01 -f a.txt balance &#39;^Asset&#39; and \( not &#39;公积金&#39; \) or &#39;^Liabilities&#39;</code>，统计至上月末为止的净资产（资产减去负债），用于了解自己的资产是上升还是下降的趋势。参数<code>-e 10/01</code>表示计算范围截止于10月1日——每次运行时需要调整为本月一号；</li><li><code>ledger -b 11/01 -e 11/30 -f a.txt balance &#39;^Expense:Food&#39;</code>，统计上个月在用餐方面的总支出，用于核对上个月的饮食开支是否超支。参数<code>-b 11/01</code>表示计算范围开始于11月1日——每次运行时需要调整为上个月一号。</li></ol><h3 id="在Emacs中查看报表"><a href="#在Emacs中查看报表" class="headerlink" title="在Emacs中查看报表"></a>在Emacs中查看报表</h3><p>ledger-mode允许用户直接在Emacs中查看报表：先按下组合键<code>C-c C-o C-r</code>，然后在minibuffer中输入报表名称，最后输入完整的调用ledger的命令即可。Emacs会打开一个新的buffer展示ledger的输出</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200319/在Emacs内查看ledger报表的效果.jpeg" alt=""></p><h2 id="账户划分方法"><a href="#账户划分方法" class="headerlink" title="账户划分方法"></a>账户划分方法</h2><p>ledger中划分账户的自由度很高，以下是我划分的一部分，供读者参考。</p><p>首先按照ledger在线文档的<a href="https://www.ledger-cli.org/3.0/doc/ledger3.html#Structuring-your-Accounts" target="_blank" rel="noopener">Structuring your Accounts</a>的要求，划分出五个顶层的账户：</p><ol><li><code>Assets</code>，表示用户的资产；</li><li><code>Equity</code>，用于初始化时作为账户余额的来源；</li><li><code>Expense</code>，表示用户的支出；</li><li><code>Income</code>，表示用户的收入；</li><li><code>Liabilities</code>，表示用户的负债。</li></ol><p>在<code>Assets</code>账户下，我还划分了</p><ol><li><code>Assets:Checking</code>，表示用于消费的账户，其下还划分了储蓄卡账户、微信零钱、支付宝余额账户；</li><li><code>Assets:Investment:Fund</code>，表示购买的基金，其下为不同的基金划分不同的账户；</li><li><code>Assets:Investment:WMP</code>，表示购买的理财产品，其下按理财产品代号划分不同的账户。</li></ol><p>在<code>Expense</code>账户下，我细分了：</p><ol><li><code>Expense:Clothes</code>，表示衣服鞋饰的支出；</li><li><code>Expense:Education</code>，表示书籍、文具的支出；</li><li><code>Expense:Entertainment</code>，表示电影、游戏等娱乐方面的支出；</li><li><code>Expense:Food</code>，表示买菜、就餐方面的支出。</li></ol><p>还有其它的许多账户，就不一一赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上大学后不久我开始用挖财记账，当时记得很随意，不会去追究一些不知道花在哪里的钱，不时就要强行修正账户余额，就这么一直用到了2019年中。后来挖财的启动时间越来越长，同时我不想看启动时的广告，便动了换记账软件的念头。&lt;/p&gt;
&lt;p&gt;本想着试试&lt;a href=&quot;https://wiz.money/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MoneyWiz&lt;/a&gt;，但其价格令人望而却步，于是决定继续物色免费的记账工具，不久便遇到了&lt;a href=&quot;https://www.gnucash.org/index.phtml?lang=zh_CN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GnuCash&lt;/a&gt;。由于它是GNU出品的，让我对其一开始便比较有好感，加上想尝试一下复式记账，便在同年9月份换到了GnuCash上。&lt;/p&gt;
&lt;p&gt;可惜好景不长，我很快便发现了GnuCash的不足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动速度随着录入数据的增多显著变慢；&lt;/li&gt;
&lt;li&gt;UI不够美观；&lt;/li&gt;
&lt;li&gt;比较依赖鼠标操作；&lt;/li&gt;
&lt;li&gt;交易时间的精度只到天，且无法轻松调整一笔交易的位置——这一点是我尤其在意的，因为着意味着一旦我有一笔交易漏记了，再追加回去后，整个账本的交易数据次序也与银行记录的不一致了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是我抛弃了GnuCash，投向了ledger（以及ledger-mode）的怀抱。&lt;/p&gt;
&lt;h1 id=&quot;ledger和ledger-mode&quot;&gt;&lt;a href=&quot;#ledger和ledger-mode&quot; class=&quot;headerlink&quot; title=&quot;ledger和ledger-mode&quot;&gt;&lt;/a&gt;ledger和ledger-mode&lt;/h1&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="工具" scheme="https://liutos.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="tool" scheme="https://liutos.github.io/tags/tool/"/>
    
      <category term="accounting" scheme="https://liutos.github.io/tags/accounting/"/>
    
      <category term="double-entry accounting" scheme="https://liutos.github.io/tags/double-entry-accounting/"/>
    
      <category term="ledger" scheme="https://liutos.github.io/tags/ledger/"/>
    
      <category term="复式记账" scheme="https://liutos.github.io/tags/%E5%A4%8D%E5%BC%8F%E8%AE%B0%E8%B4%A6/"/>
    
      <category term="记账" scheme="https://liutos.github.io/tags/%E8%AE%B0%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>优化org-mode管理观影进度</title>
    <link href="https://liutos.github.io/2020/02/21/%E4%BC%98%E5%8C%96org-mode%E7%AE%A1%E7%90%86%E8%A7%82%E5%BD%B1%E8%BF%9B%E5%BA%A6/"/>
    <id>https://liutos.github.io/2020/02/21/优化org-mode管理观影进度/</id>
    <published>2020-02-21T14:14:55.000Z</published>
    <updated>2020-02-21T14:16:46.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在之前的<a href="https://liutos.github.io/2020/02/11/%E6%8F%90%E5%8D%87%E6%9D%A1%E7%9B%AE%E4%B8%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9/">文章</a>中，我提到自己用org-mode管理工作日午餐和晚餐要看的动画及其进度。简单来说，就是为每部动画创建同名的二级条目（它们有一个共同的一级条目叫“动画”），每当准备看新一集时，就在对应二级条目下创建形如“观看第X话”的三级条目并设为TODO。</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg" alt=""></p><p>按这种方式，在《钢炼FA》下最终会创建出64个三级条目——而可怜的Emacs甚至一屏只能显示50行！这些“阅后即焚”的三级条目浪费了其它（或许）更有价值的内容的展示空间，因此最好将每一个切换至 <code>DONE</code>状态的三级条目藏起来。</p><p>org-mode可以“<a href="https://orgmode.org/manual/Internal-archiving.html" target="_blank" rel="noopener">internal archive</a>”一个条目，但这样仍无法节省它们占据的纵向空间。后来，我想到了org-mode的<a href="https://orgmode.org/manual/Drawers.html" target="_blank" rel="noopener">drawer</a>特性。</p><a id="more"></a><h1 id="思路及函数定义"><a href="#思路及函数定义" class="headerlink" title="思路及函数定义"></a>思路及函数定义</h1><p>基于drawer的方案很直接：在<code>org-after-todo-state-change-hook</code>中新增一个钩子。每当一个条目切换至<code>DONE</code>状态、并满足一些条件（比如条目的heading符合“观看第X话”这个模式）时，就将heading的文本与当前时间一起追加到父级条目下、名为“观看进度”的drawer的末端。</p><p>org-mode没有内置的函数可以往某个条目的某个drawer中追加内容，需要自行利用“移动光标”和“字符串搜索”来实现。最终的成品如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">require</span> 'cl)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> lt-org-move-episode-to-drawer ()</span><br><span class="line">  <span class="string">"往上级heading的drawer中插入一个内容，并删除当前heading。"</span></span><br><span class="line">  <span class="comment">;; 用cl-block来实现nonlocal-exit</span></span><br><span class="line">  (<span class="name">cl-block</span> lt-org-move-episode-to-drawer</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">state</span> org-state))</span><br><span class="line">      (<span class="name">unless</span> (<span class="name">string=</span> state <span class="string">"DONE"</span>)</span><br><span class="line">        (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer)))</span><br><span class="line"></span><br><span class="line">    (<span class="name">let</span> ((<span class="name">tags</span> (<span class="name">org-get-tags-at</span>))</span><br><span class="line">          (<span class="name">text</span> (<span class="name">nth</span> <span class="number">4</span> (<span class="name">org-heading-components</span>))))</span><br><span class="line">      <span class="comment">;; 只处理内容以“观看”开头、带有“动画”标签的heading</span></span><br><span class="line">      (<span class="name">unless</span> (<span class="name">and</span> (<span class="name">or</span> (<span class="name">string-prefix-p</span> <span class="string">"观看"</span> text)</span><br><span class="line">                       (<span class="name">string-prefix-p</span> <span class="string">"继续阅读"</span> text))</span><br><span class="line">                   (<span class="name">or</span> (<span class="name">member</span> <span class="string">"动画"</span> tags)</span><br><span class="line">                       (<span class="name">member</span> <span class="string">"阅读"</span> tags)))</span><br><span class="line">        (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer))</span><br><span class="line"></span><br><span class="line">      (<span class="name">save-excursion</span></span><br><span class="line">        (<span class="name">let</span> (<span class="name">current-position</span>)</span><br><span class="line">          <span class="comment">;; 记下当前的位置，之后搜索的时候到这里为止</span></span><br><span class="line">          (<span class="name">setq</span> current-position (<span class="name">point</span>))</span><br><span class="line">          <span class="comment">;; 往上走一级，以便寻找一个名字叫做“观看进度”的drawer</span></span><br><span class="line">          (<span class="name">widen</span>)</span><br><span class="line">          (<span class="name">outline-up-heading</span> <span class="number">1</span>)</span><br><span class="line">          (<span class="name">unless</span> (<span class="name">search-forward</span> <span class="string">":观看进度:"</span> current-position <span class="literal">t</span>)</span><br><span class="line">            (<span class="name">message</span> <span class="string">"请自行创建“观看进度”的drawer"</span>)</span><br><span class="line">            (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer))</span><br><span class="line"></span><br><span class="line">          <span class="comment">;; 继续往前找到:END:的标记</span></span><br><span class="line">          (<span class="name">unless</span> (<span class="name">search-forward</span> <span class="string">":END:"</span> current-position <span class="literal">t</span>)</span><br><span class="line">            (<span class="name">message</span> <span class="string">"请确保有完整的“观看进度”的drawer"</span>)</span><br><span class="line">            (<span class="name">cl-return-from</span> lt-org-move-episode-to-drawer))</span><br><span class="line">          <span class="comment">;; 往左走五步</span></span><br><span class="line">          (<span class="name">backward-char</span> <span class="number">5</span>)</span><br><span class="line">          <span class="comment">;; 开辟一行新的，然后把刚刚完成的任务的内容和时间戳放进来</span></span><br><span class="line">          (<span class="name">org-open-line</span> <span class="number">1</span>)</span><br><span class="line">          (<span class="name">insert</span> (<span class="name">format</span> <span class="string">"“%s” DONE at %s"</span> text (<span class="name">current-time-string</span>)))))</span><br><span class="line">      (<span class="name">org-cut-subtree</span>))))</span><br></pre></td></tr></table></figure><p>别忘了加入到钩子中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">add-hook</span> 'org-after-todo-state-change-hook 'lt-org-move-episode-to-drawer <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><code>lt-org-move-episode-to-drawer</code>的缺点在于它会删掉切换至<code>DONE</code>状态的条目，因此这个观看记录在<code>*Org Agenda*</code>中会完全消失——这一点尚能接受。</p><p>此外，上面的<code>defun</code>完全可以修改为<code>cl-defun</code>，并移除<code>cl-block</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;在之前的&lt;a href=&quot;https://liutos.github.io/2020/02/11/%E6%8F%90%E5%8D%87%E6%9D%A1%E7%9B%AE%E4%B8%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9/&quot;&gt;文章&lt;/a&gt;中，我提到自己用org-mode管理工作日午餐和晚餐要看的动画及其进度。简单来说，就是为每部动画创建同名的二级条目（它们有一个共同的一级条目叫“动画”），每当准备看新一集时，就在对应二级条目下创建形如“观看第X话”的三级条目并设为TODO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;按这种方式，在《钢炼FA》下最终会创建出64个三级条目——而可怜的Emacs甚至一屏只能显示50行！这些“阅后即焚”的三级条目浪费了其它（或许）更有价值的内容的展示空间，因此最好将每一个切换至 &lt;code&gt;DONE&lt;/code&gt;状态的三级条目藏起来。&lt;/p&gt;
&lt;p&gt;org-mode可以“&lt;a href=&quot;https://orgmode.org/manual/Internal-archiving.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;internal archive&lt;/a&gt;”一个条目，但这样仍无法节省它们占据的纵向空间。后来，我想到了org-mode的&lt;a href=&quot;https://orgmode.org/manual/Drawers.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;drawer&lt;/a&gt;特性。&lt;/p&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>免除频繁输入ssh密码的烦恼</title>
    <link href="https://liutos.github.io/2020/02/19/%E5%85%8D%E9%99%A4%E9%A2%91%E7%B9%81%E8%BE%93%E5%85%A5ssh%E5%AF%86%E7%A0%81%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    <id>https://liutos.github.io/2020/02/19/免除频繁输入ssh密码的烦恼/</id>
    <published>2020-02-19T03:40:18.000Z</published>
    <updated>2020-02-19T03:42:19.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在入手MacBook Pro前，我的开发环境主要是一个运行在VirtualBox中的Mint发行版。在这个系统中，只要运行一次<code>git push</code>并输入passphrase（下称密码）后，之后便不再需要输入了——即使ssh登录远程机器也是如此。</p><p>但用上Mac后发现，这里的ssh没有这个方便的特性——每次运行<code>git push</code>或<code>ssh</code>，都需要输入密码，颇不方便。</p><p>为了避免一遍又一遍地输入密码，每次登录后，我都会运行<code>ssh-add</code>来一劳永逸地解决问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>自从升级到macOS Catalina后，如果在合盖睡眠前没有注销的话，下次开盖唤醒极有可能卡死在登录界面。无奈之下，我每天都需要注销并在第二天重新登录，以至于每天都得运行<code>ssh-add</code>并输入密码。久而久之，这也挺烦人的。</p><h1 id="一次失败的优化"><a href="#一次失败的优化" class="headerlink" title="一次失败的优化"></a>一次失败的优化</h1><a id="more"></a><p>为了省却每次都输入长达14个字符的密码的烦恼，我想到了<code>expect(1)</code>，这是一种可以交互式地控制其它命令的脚本语言。遗憾的是，经过一番折腾，仍然没办法成功让expect把密码输入给<code>ssh-add</code>，我只好继续寻找其它的办法。</p><h1 id="一次成功的优化"><a href="#一次成功的优化" class="headerlink" title="一次成功的优化"></a>一次成功的优化</h1><p>某天在阅读<code>ssh-add</code>的<code>man</code>文档时，了解到原来<code>ssh-add</code>有一个<code>-K</code>选项，可以在添加身份到<code>ssh-agent</code>时，将密码存储到用户的keychain中。同时还有一个<code>-A</code>选项，可以让<code>ssh-add</code>使用来自于keychain的密码——这意味着可以不用一遍又一遍地输入！</p><p>那么接下来要做的事情已经很清楚了。先手动运行一次带<code>-K</code>选项的<code>ssh-add</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>并输入密码——这将会是在Mac上的最后一次输入。再用<code>-A</code>选项调用<code>ssh-add</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">ssh-add -A ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>我把上面这段代码保存为文件<code>/Users/liutos/SourceCode/shell/auto_ssh_add/auto_ssh_add.sh</code>，它很快就会被用到。最后，写一个Launchd的配置文件<code>~/Library/LaunchAgents/com.liutos.tools.sshAdd.plist</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.liutos.tools.sshAdd<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>Program<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/liutos/SourceCode/shell/auto_ssh_add/auto_ssh_add.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/auto_ssh_add.log<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/auto_ssh_add.err<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从现在起，再也不需要一遍又一遍地输入ssh的密码了——一次也不需要。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>要是有哪些读者朋友成功地用<code>expect</code>实现自动输入密码的，还望不吝赐教;)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;在入手MacBook Pro前，我的开发环境主要是一个运行在VirtualBox中的Mint发行版。在这个系统中，只要运行一次&lt;code&gt;git push&lt;/code&gt;并输入passphrase（下称密码）后，之后便不再需要输入了——即使ssh登录远程机器也是如此。&lt;/p&gt;
&lt;p&gt;但用上Mac后发现，这里的ssh没有这个方便的特性——每次运行&lt;code&gt;git push&lt;/code&gt;或&lt;code&gt;ssh&lt;/code&gt;，都需要输入密码，颇不方便。&lt;/p&gt;
&lt;p&gt;为了避免一遍又一遍地输入密码，每次登录后，我都会运行&lt;code&gt;ssh-add&lt;/code&gt;来一劳永逸地解决问题&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-add ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;自从升级到macOS Catalina后，如果在合盖睡眠前没有注销的话，下次开盖唤醒极有可能卡死在登录界面。无奈之下，我每天都需要注销并在第二天重新登录，以至于每天都得运行&lt;code&gt;ssh-add&lt;/code&gt;并输入密码。久而久之，这也挺烦人的。&lt;/p&gt;
&lt;h1 id=&quot;一次失败的优化&quot;&gt;&lt;a href=&quot;#一次失败的优化&quot; class=&quot;headerlink&quot; title=&quot;一次失败的优化&quot;&gt;&lt;/a&gt;一次失败的优化&lt;/h1&gt;
    
    </summary>
    
    
      <category term="macos" scheme="https://liutos.github.io/tags/macos/"/>
    
      <category term="shell" scheme="https://liutos.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://liutos.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>重构vertical-let，支持解构</title>
    <link href="https://liutos.github.io/2020/02/12/%E9%87%8D%E6%9E%84vertical-let%EF%BC%8C%E6%94%AF%E6%8C%81%E8%A7%A3%E6%9E%84/"/>
    <id>https://liutos.github.io/2020/02/12/重构vertical-let，支持解构/</id>
    <published>2020-02-12T07:36:46.000Z</published>
    <updated>2020-02-12T07:41:42.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《实战Common Lisp》系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。MAKE COMMON LISP GREAT AGAIN。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>因为觉得Common Lisp原生的<code>let</code>操作符在许多时候不够好用，我编写了<code>vertical-let</code>。（详情可以参见这篇<a href="https://liutos.github.io/2019/03/13/%E6%9B%B4%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%9A%84let%E2%80%94%E2%80%94vertical-let/">文章</a>）比起原生的<code>let</code>，<code>vertical-let</code>的优势在于：</p><ol><li>有效减少代码的缩进——尤其是嵌套使用<code>let</code>的时候；</li><li>方便增减binding，对其余代码的布局没有影响。</li></ol><p>除了<code>let</code>，<code>destructuring-bind</code>也是一个常用的声明binding的语法。但如果用在<code>vertical-let</code>中的话，会打乱原有的代码布局。比如原本的代码为</p><a id="more"></a><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line"> <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line"> <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line"> (<span class="name">+</span> a b))</span><br></pre></td></tr></table></figure><p>如果加入<code>destructuring-bind</code>，就会导致从它之后的代码都增加了一级缩进</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line"> <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line"> <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line"> (<span class="name">destructuring-bind</span> (<span class="name">c</span>) '(<span class="number">3</span>)</span><br><span class="line">   (<span class="name">+</span> a b c))) <span class="comment">; &lt;- 这一行开始多了一级缩进，之后的代码全都受到影响</span></span><br></pre></td></tr></table></figure><p>我更希望能写成下面这样</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">vertical-let</span></span><br><span class="line"> <span class="symbol">:with</span> a = <span class="number">1</span></span><br><span class="line"> <span class="symbol">:with</span> b = <span class="number">2</span></span><br><span class="line"> <span class="symbol">:with</span> (<span class="name">c</span>) = '(<span class="number">3</span>)</span><br><span class="line"> (<span class="name">+</span> a b c))</span><br></pre></td></tr></table></figure><p>然而<code>vertical-let</code>目前的实现方式很难支持这种新语法。</p><p>在<code>vertical-let</code>内部，将参数分成了“binding”和“form”两种类型，压入到同一个栈中，再逐一弹出处理。如果要支持展开成<code>destructuring-bind</code>，那么：</p><ol><li>如果弹出的是“binding”，就需要决定是将其与旧的合并（都是<code>let</code>的binding的情况），还是先处理已有的变量<code>bindings</code>和<code>forms</code>中的内容（这里又涉及到是组成<code>let</code>还是组成<code>destructuring-bind</code>）；</li><li>如果弹出的是“form”，也要考虑与上述场景类似的情况。</li></ol><p>可想而知，这会让<code>vertical-let</code>的代码膨胀得厉害，并且显得很混乱。因此，必须先优化一番<code>vertical-let</code>。</p><h1 id="重构vertical-let"><a href="#重构vertical-let" class="headerlink" title="重构vertical-let"></a>重构vertical-let</h1><p>新的思路是：</p><ol><li>从尾部开始遍历<code>vertical-let</code>的参数列表；</li><li>如果遍历到的元素不是符号<code>:with</code>，就认为是一个可以求值的表达式，将其压栈。显然，这个栈的元素的顺序，与<code>vertical-let</code>的参数列表的顺序是一致的，可以直接用于合成<code>let</code>表达式；</li><li>如果遍历到的元素是符号<code>:with</code>，就从栈中弹出三个元素（它们依次是变量名、等号、待求值的表达式）；</li><li>将变量名、待求值的表达式，以及栈内所有元素组成只有一个binding的的<code>let</code>表达式，重新压栈。</li></ol><p>当参数列表遍历完后，再看看这个栈：</p><ol><li>如果只有一个元素，就是<code>vertical-let</code>的展开结果；</li><li>否则，将它们作为<code>progn</code>的参数，返回一个<code>progn</code>表达式。</li></ol><h1 id="支持destructuring-bind"><a href="#支持destructuring-bind" class="headerlink" title="支持destructuring-bind"></a>支持destructuring-bind</h1><p>在上面的算法中，遇到符号<code>:with</code>后只需要构造出<code>let</code>表达式即可。为了支持展开成<code>destructuring-bind</code>，需要根据栈顶元素类型来做不同处理：</p><ol><li>如果是<code>cons</code>，就展开为<code>destructuring-bind</code>——毕竟<code>destructuring-bind</code>是无法嵌套的；</li><li>如果是<code>symbol</code>，就展开为<code>let</code>（如果栈只有一个元素并且是<code>let</code>表达式，那么可以将新的binding合并进去，减少展开后代码的缩进）。</li></ol><p>现在，可以完整地实现<code>vertical-let</code>了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> vertical-let/aux (<span class="name">forms</span>)</span><br><span class="line">  <span class="string">"将FORMS转换为基于DESTRUCTURING-BIND和LET*实现的形式。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">将:WITH VAR = VAL . FORMS形式的代码转换为(LET* ((VAR VAL)) . FORMS)；</span></span><br><span class="line"><span class="string">将:WITH (VAR1 VAR2) = VAL . FORMS形式的代码转换为(DESTRUCTURING-BIND (VAR1 VAR2) VAL . FORMS)。"</span></span><br><span class="line">  (<span class="name">check-type</span> forms list)</span><br><span class="line">  (<span class="name">setf</span> forms (<span class="name">reverse</span> forms))</span><br><span class="line">  (<span class="name">let</span> (<span class="name">form</span></span><br><span class="line">        (<span class="name">stack</span> '()))</span><br><span class="line">    (<span class="name">block</span> <span class="literal">nil</span></span><br><span class="line">      (<span class="name">loop</span></span><br><span class="line">         (<span class="name">when</span> (<span class="name">null</span> forms)</span><br><span class="line">           (<span class="name">return-from</span> <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">         (<span class="name">setf</span> form (<span class="name">pop</span> forms))</span><br><span class="line">         (<span class="name">cond</span> ((<span class="name">eq</span> form <span class="symbol">:with</span>)</span><br><span class="line">                (<span class="name">let</span> ((<span class="name">place</span> (<span class="name">pop</span> stack)))</span><br><span class="line">                  <span class="comment">;; 下一个元素必须是一个名称为等号的符号</span></span><br><span class="line">                  (<span class="name">let</span> ((<span class="name">e</span> (<span class="name">pop</span> stack)))</span><br><span class="line">                    (<span class="name">assert</span> (<span class="name">symbolp</span> e))</span><br><span class="line">                    (<span class="name">assert</span> (<span class="name">string=</span> (<span class="name">symbol-name</span> e) <span class="string">"="</span>)))</span><br><span class="line">                  (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">pop</span> stack)))</span><br><span class="line">                    (<span class="name">etypecase</span> place</span><br><span class="line">                      (<span class="name">cons</span></span><br><span class="line">                       <span class="comment">;; 展开为DESTRUCTURING-BIND</span></span><br><span class="line">                       (<span class="name">setf</span> stack `((destructuring-bind ,place ,val ,@stack))))</span><br><span class="line">                      (<span class="name">symbol</span></span><br><span class="line">                       <span class="comment">;; 如果STAKC中仅有一个LET*表达式就将新的绑定合并进去，否则创建新的LET*表达式</span></span><br><span class="line">                       (<span class="name">cond</span> ((<span class="name">and</span> (<span class="name">=</span> (<span class="name">length</span> stack) <span class="number">1</span>)</span><br><span class="line">                                   (<span class="name">consp</span> (<span class="name">car</span> stack))</span><br><span class="line">                                   (<span class="name">eq</span> (<span class="name">caar</span> stack) 'let*))</span><br><span class="line">                              (<span class="name">let*</span> ((<span class="name">form</span> (<span class="name">pop</span> stack))</span><br><span class="line">                                     (<span class="name">bindings</span> (<span class="name">second</span> form)))</span><br><span class="line">                                (<span class="name">setf</span> (<span class="name">second</span> form)</span><br><span class="line">                                      `((,place ,val) ,@bindings))</span><br><span class="line">                                (<span class="name">push</span> form stack)))</span><br><span class="line">                             (<span class="name">t</span></span><br><span class="line">                              (<span class="name">setf</span> stack `((let* ((,place ,val)) ,@stack))))))))</span><br><span class="line">                  ))</span><br><span class="line">               (<span class="name">t</span></span><br><span class="line">                (<span class="name">push</span> form stack)))))</span><br><span class="line">    </span><br><span class="line">    (<span class="name">if</span> (<span class="name">=</span> (<span class="name">length</span> stack) <span class="number">1</span>)</span><br><span class="line">        (<span class="name">car</span> stack)</span><br><span class="line">        `(progn ,@stack))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defmacro</span> vertical-let* (<span class="name">&amp;body</span> body)</span><br><span class="line">  <span class="string">"不需要不停缩进的LET*"</span></span><br><span class="line">  (<span class="name">vertical-let/aux</span> body))</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>除了<code>let</code>和<code>destructuring-bind</code>，Common Lisp还提供了名为<code>multiple-value-bind</code>的宏，用于捕捉从一个函数返回的多个值。如果又要修改<code>vertical-let</code>的话，多半就是为了支持它了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《实战Common Lisp》系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。MAKE COMMON LISP GREAT AGAIN。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;因为觉得Common Lisp原生的&lt;code&gt;let&lt;/code&gt;操作符在许多时候不够好用，我编写了&lt;code&gt;vertical-let&lt;/code&gt;。（详情可以参见这篇&lt;a href=&quot;https://liutos.github.io/2019/03/13/%E6%9B%B4%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%9A%84let%E2%80%94%E2%80%94vertical-let/&quot;&gt;文章&lt;/a&gt;）比起原生的&lt;code&gt;let&lt;/code&gt;，&lt;code&gt;vertical-let&lt;/code&gt;的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有效减少代码的缩进——尤其是嵌套使用&lt;code&gt;let&lt;/code&gt;的时候；&lt;/li&gt;
&lt;li&gt;方便增减binding，对其余代码的布局没有影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了&lt;code&gt;let&lt;/code&gt;，&lt;code&gt;destructuring-bind&lt;/code&gt;也是一个常用的声明binding的语法。但如果用在&lt;code&gt;vertical-let&lt;/code&gt;中的话，会打乱原有的代码布局。比如原本的代码为&lt;/p&gt;
    
    </summary>
    
      <category term="实战CommonLisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98CommonLisp/"/>
    
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
      <category term="macro" scheme="https://liutos.github.io/tags/macro/"/>
    
      <category term="宏" scheme="https://liutos.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>提升条目为第一个孩子节点</title>
    <link href="https://liutos.github.io/2020/02/11/%E6%8F%90%E5%8D%87%E6%9D%A1%E7%9B%AE%E4%B8%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E8%8A%82%E7%82%B9/"/>
    <id>https://liutos.github.io/2020/02/11/提升条目为第一个孩子节点/</id>
    <published>2020-02-11T03:25:46.000Z</published>
    <updated>2020-02-11T08:10:40.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我用Emacs的org-mode来管理看动画的进度</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg" alt="org-mode中的动画清单"></p><p>每个工作日的午餐和晚餐，我都会安排一部下饭动画。为了每顿饭可以看不同的动画，我的做法是：</p><a id="more"></a><ol><li>从清单的尾部选择一部动画（比如选中了《鬼灭之刃》）；</li><li>在这部动画下创建一个子节点（比如“观看第17话”），设置为TODO状态，并设定SCHEDULED属性为第二天的午餐或晚餐的时间；</li><li>把动画的条目移动到当前父节点的第一个孩子节点的位置上（也就是排到《动物狂想曲》的上面），这样接下来就不会立即再选到这部动画来看了。</li></ol><p>要移动到第一个孩子节点，可以先剪切再粘贴，也可以用org-mode提供的快捷键<code>M-↑</code>。但<code>M-↑</code>只能往上移动一级，如果要移动至第一个孩子节点的位置，就需要不停地按这个快捷键。为了简化这个步骤，我定义了一个新的命令和快捷键来代劳。</p><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>这个函数非常简单，只需要持续调用<code>M-↑</code>快捷键对应的命令，直到它出错自己结束即可。为了知道<code>M-↑</code>对应的是哪一个函数，在一个主模式为org-mode的buffer中，按下<code>C-h k</code>，再按下<code>M-↑</code>，可以看到它对应的函数为<code>org-move-subtree-up</code>。</p><p>现在，可以定义这个短小精悍的函数了</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> up-to-top ()</span><br><span class="line">  <span class="string">"将当前条目一直移动到最上面"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">loop</span></span><br><span class="line">   (<span class="name">org-move-subtree-up</span>)))</span><br></pre></td></tr></table></figure><p>我把它绑定到了快捷键C-c o u上</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-key</span> org-mode-map <span class="string">"\C-cou"</span> 'up-to-top)</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>用org-mode来记录动画的观看进度，会在动画的条目下创建出许多形如“观看XX话”这样的条目。如果是《钢炼》这种六十多集的动画，展开时看到这一大串子条目还是颇为震撼和困扰的。为了解决这个问题，我在org-mode中还定制了一些其它功能，下次再给大家讲解一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;我用Emacs的org-mode来管理看动画的进度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/loading.png&quot; data-original=&quot;https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200211/动画清单.jpeg&quot; alt=&quot;org-mode中的动画清单&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个工作日的午餐和晚餐，我都会安排一部下饭动画。为了每顿饭可以看不同的动画，我的做法是：&lt;/p&gt;
    
    </summary>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98Elisp/"/>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>all-first-registers-to-strings</title>
    <link href="https://liutos.github.io/2020/01/25/all-first-registers-to-strings/"/>
    <id>https://liutos.github.io/2020/01/25/all-first-registers-to-strings/</id>
    <published>2020-01-25T12:38:09.000Z</published>
    <updated>2020-01-27T08:31:27.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是《实战Common Lisp》系列的第一篇文章。本系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><del>众所周知，</del>Common Lisp没有内置多少处理字符串的函数，下面的代码便能看到所有以STRING开头的函数名：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">do-external-symbols</span> (<span class="name">s</span> <span class="symbol">:cl</span>)</span><br><span class="line">  (<span class="name">when</span> (<span class="name">and</span> (<span class="name">fboundp</span> s)</span><br><span class="line">             (<span class="name">equal</span> (<span class="name">search</span> <span class="string">"STRING"</span> (<span class="name">symbol-name</span> s)) <span class="number">0</span>))</span><br><span class="line">    (<span class="name">print</span> s)))</span><br></pre></td></tr></table></figure><p>屈指可数，而且大部分是比较两个字符串的！很多其它语言中的“标配”是不存在的，比如想要将多个字符串连接起来这么简单的功能都没有！要么自己实现，要么依赖第三方库，比如<a href="https://github.com/vindarel/cl-str" target="_blank" rel="noopener"><code>cl-str</code></a>提供的<code>join</code>函数。</p><p>标准库也没有内置正则表达式，好在有一个优秀的第三方库可以用：<a href="http://edicl.github.io/cl-ppcre/" target="_blank" rel="noopener"><code>cl-ppcre</code></a>。一种使用正则的常见需求是提取符合某种模式的内容，比如提取一篇Markdown文章中所有的图片链接。图片链接可以由下列正则括号的部分匹配：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"!\\[.*\\]\\((.*)\\)"</span></span><br></pre></td></tr></table></figure><p>在cl-ppcre中这个括号匹配的部分叫做第一个register。我想要写一个能够提取出字符串中所有符合这段正则的第一个register，分两步走：</p><ol><li>先实现一个<code>all-first-registers-to-strings</code>函数，实现通用的、提取一个字符串中所有符合某段正则的子串的第一个register的内容；</li><li>基于<code>all-first-registers-to-strings</code>实现一个<code>extract-image-paths</code>。</li></ol><a id="more"></a><h1 id="all-first-registers-to-strings"><a href="#all-first-registers-to-strings" class="headerlink" title="all-first-registers-to-strings"></a><code>all-first-registers-to-strings</code></h1><p>要实现这个函数，需要借助cl-ppcre的<code>scan</code>函数。根据<a href="http://edicl.github.io/cl-ppcre/#scan" target="_blank" rel="noopener">scan函数的文档</a>，当正则匹配成功时，它的第三、第四个返回值表示正则中register的起点和终点在字符串中的偏移——它们是两个数组，起点和终点一一对应。有了起点和终点的偏移，再使用<code>CL:SUBSEQ</code>便能提取出register对应的子串。如果要把字符串中所有匹配register的内容都拿出来，就反复调用scan函数，直到再也没有匹配成功为止。</p><p><code>all-first-registers-to-strings</code>的定义如下：</p><p><script src="https://gist.github.com/Liutos/045aa43b5b3698d7e7c460d3f0c90858.js"></script></p><ul><li>为了不停地在<code>target-string</code>中前进，用变量<code>pos</code>存储<code>scan</code>函数的第二个返回值，并作为下一次调用<code>scan</code>时的<code>start</code>参数——显然，<code>pos</code>的初始值为0；</li><li>为了跳出<code>loop</code>，使用了<code>return-from</code>直接从函数返回；</li><li>用<code>push</code>收集最终结果，再用<code>nreverse</code>处理成最终的返回值——印象中《On Lisp》也说过这是一种比较常见的手法。</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>有了<code>all-first-registers-to-strings</code>，就可以轻松实现<code>extract-image-paths</code>了：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> extract-image-paths (<span class="name">content</span>)</span><br><span class="line">  <span class="string">"从博文内容CONTENT中提取出图片的绝对路径。"</span></span><br><span class="line">  (<span class="name">all-first-registers-to-strings</span> <span class="string">"!\\[.*\\]\\((.*)\\)"</span> content))</span><br></pre></td></tr></table></figure><p>显然，这个<code>all-first-registers-to-strings</code>函数实现得很糟糕，尤其是<code>loop</code>的用法实在是太不Lispy了。Common Lisp的<code>loop</code>的用法纷繁复杂如天上的星星，多半可以用更优雅的方法来重写一遍，这个就留给各位读者作为私下的乐趣吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是《实战Common Lisp》系列的第一篇文章。本系列主要讲述在使用Common Lisp时能派上用场的小函数，希望能为Common Lisp的复兴做一些微小的贡献。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;&lt;del&gt;众所周知，&lt;/del&gt;Common Lisp没有内置多少处理字符串的函数，下面的代码便能看到所有以STRING开头的函数名：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;do-external-symbols&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:cl&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;when&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;and&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;fboundp&lt;/span&gt; s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             (&lt;span class=&quot;name&quot;&gt;equal&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;search&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;STRING&quot;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;symbol-name&lt;/span&gt; s)) &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;print&lt;/span&gt; s)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;屈指可数，而且大部分是比较两个字符串的！很多其它语言中的“标配”是不存在的，比如想要将多个字符串连接起来这么简单的功能都没有！要么自己实现，要么依赖第三方库，比如&lt;a href=&quot;https://github.com/vindarel/cl-str&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;cl-str&lt;/code&gt;&lt;/a&gt;提供的&lt;code&gt;join&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;标准库也没有内置正则表达式，好在有一个优秀的第三方库可以用：&lt;a href=&quot;http://edicl.github.io/cl-ppcre/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;cl-ppcre&lt;/code&gt;&lt;/a&gt;。一种使用正则的常见需求是提取符合某种模式的内容，比如提取一篇Markdown文章中所有的图片链接。图片链接可以由下列正则括号的部分匹配：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;!\\[.*\\]\\((.*)\\)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在cl-ppcre中这个括号匹配的部分叫做第一个register。我想要写一个能够提取出字符串中所有符合这段正则的第一个register，分两步走：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先实现一个&lt;code&gt;all-first-registers-to-strings&lt;/code&gt;函数，实现通用的、提取一个字符串中所有符合某段正则的子串的第一个register的内容；&lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;all-first-registers-to-strings&lt;/code&gt;实现一个&lt;code&gt;extract-image-paths&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="实战CommonLisp" scheme="https://liutos.github.io/categories/%E5%AE%9E%E6%88%98CommonLisp/"/>
    
    
      <category term="lisp" scheme="https://liutos.github.io/tags/lisp/"/>
    
      <category term="commonlisp" scheme="https://liutos.github.io/tags/commonlisp/"/>
    
  </entry>
  
  <entry>
    <title>快速设置任务的开始时间（下）</title>
    <link href="https://liutos.github.io/2020/01/10/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://liutos.github.io/2020/01/10/快速设置任务的开始时间（下）/</id>
    <published>2020-01-10T15:12:41.000Z</published>
    <updated>2020-02-11T08:10:12.870Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p></blockquote><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在<a href="https://liutos.github.io/2020/01/09/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8A%EF%BC%89/">上一篇文章</a>的末尾，我说有一个更优雅的办法实现快速设置任务的开始时间，本文便来揭秘这个办法。</p><a id="more"></a><h1 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h1><blockquote><p>如果说我看得比别人更远些，那是因为我站在巨人的肩膀上。<br>——牛顿</p></blockquote><p>既要支持预设选项，又要能够方便选择，一个显而易见的办法就是使用下拉列表。要在Emacs中弹出下拉列表，不需要从零开始造轮子，只要基于<a href="https://github.com/emacs-helm/helm" target="_blank" rel="noopener">Helm</a>即可轻松做到。Helm是一个增量补全及选择的框架，利用它的API，可以轻松实现带补全功能的下拉列表，并在选中某一项后执行特定的代码。</p><p>这份<a href="https://wikemacs.org/wiki/How_to_write_helm_extensions" target="_blank" rel="noopener">文档</a>清晰地说明了如何使用Helm的API。在展示具体代码前，先看看成品的效果是怎样的</p><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200110/基于Helm快速选择开始时间.mp4" type="video/mp4"><br></video><h1 id="show-the-code"><a href="#show-the-code" class="headerlink" title="show the code"></a>show the code</h1><p>Helm的用法朴实无华，只要调用名为<code>helm</code>的函数即可。<code>helm</code>有一个叫<code>sources</code>的重要参数，它接收一个<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-List-Type.html" target="_blank" rel="noopener">association list</a>，并要求其中有以如下三个符号为<code>car</code>的<code>cons</code>：</p><ol><li><code>name</code>。对应的<code>cdr</code>部分是下拉列表的名字；</li><li><code>candidates</code>。对应的<code>cdr</code>部分是下拉列表的所有候选项；</li><li><code>action</code>。对应的<code>cdr</code>部分是一个函数，代表选中某一项后的处理逻辑。</li></ol><p><code>candidates</code>可以是一个association list（这也是前述的文档以及我接下来的用法），其中每个<code>cons</code>的<code>car</code>部分将作为候选项被展示，<code>cdr</code>部分则是一个“真实值”（就像是HTML的option标签的文本与它的<code>value</code>属性间的关系）。Helm贴心地提供了名为<code>helm-marked-candidates</code>的函数，帮助在这种情况下，获取被选中的候选项对应的<code>cdr</code>部分的内容。为了利用这个便捷的特性，我将候选项定义为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> *schedule-shortcuts*</span><br><span class="line">      '((<span class="string">"午餐"</span> . (<span class="number">12</span> <span class="number">0</span>))</span><br><span class="line">        (<span class="string">"午休"</span> . (<span class="number">13</span> <span class="number">0</span>))</span><br><span class="line">        (<span class="string">"晚餐"</span> . (<span class="number">18</span> <span class="number">35</span>))</span><br><span class="line">        (<span class="string">"晚上在家"</span> . (<span class="number">22</span> <span class="number">5</span>))))</span><br></pre></td></tr></table></figure><p>要传给<code>helm</code>函数的<code>sources</code>参数的值为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> *helm-quick-schedule-source*</span><br><span class="line">  `((name . <span class="string">"设置TODO的SCHEDULED属性"</span>)</span><br><span class="line">    (candidates . *schedule-shortcuts*)</span><br><span class="line">    (action . (lambda (candidate)</span><br><span class="line">                (helm-marked-candidates)))))</span><br></pre></td></tr></table></figure><p>有了<code>*helm-quick-schedule-source*</code>，便可以一窥Helm的风采。按下<code>M-:</code>并输入<code>(helm :sources *helm-quick-schedule-source*)↵</code>，会打开一个新的buffer，其中纵向列出了“午餐”、“午休”、“晚餐”，以及“晚上在家”四个选项。可以上下移动，也可以输入目标选项的部分内容，Helm会根据输入过滤候选项。按下回车后，<code>helm</code>函数返回一个列表，装载着所选中的项对应的<code>cdr</code>部分——这是因为在<code>*helm-quick-schedule-source*</code>中<code>action</code>的部分就是直接返回这个<code>cdr</code>。</p><p>最后，只需将<code>helm</code>与上一篇文章中定义的<code>lt-next-todo</code>结合起来即可：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> helm-quick-schedule ()</span><br><span class="line">  <span class="string">"从下拉列表选择完后SCHEDULED模式后修改当前TODO条目的SCHEDULED属性。"</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">spec</span> (<span class="name">car</span> (<span class="name">helm</span> <span class="symbol">:sources</span> '(*helm-quick-schedule-source*)))))</span><br><span class="line">    (<span class="name">when</span> spec</span><br><span class="line">      (<span class="name">apply</span> 'lt-next-todo spec))))</span><br></pre></td></tr></table></figure><p>把它绑定到<code>C-c l s</code>上</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-key</span> org-mode-map <span class="string">"\C-cls"</span> 'helm-quick-schedule)</span><br></pre></td></tr></table></figure><p>现在，当处于<code>org-mode</code>模式下的buffer时，只需要按下<code>C-c l s</code>，便可以轻松选择一个开始时间并在眨眼间设置为光标所在任务的SCHEDULED属性。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Emacs的Helm插件本身已经提供了非常丰富的功能，例如<code>helm-bufferss-list</code>。我还利用Helm实现查询笔记的入口，待时机成熟了，一定将这方面的心得分享出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“实战Elisp”系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://liutos.github.io/2020/01/09/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;上一篇文章&lt;/a&gt;的末尾，我说有一个更优雅的办法实现快速设置任务的开始时间，本文便来揭秘这个办法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>快速设置任务的开始时间（上）</title>
    <link href="https://liutos.github.io/2020/01/09/%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%B6%E9%97%B4%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://liutos.github.io/2020/01/09/快速设置任务的开始时间（上）/</id>
    <published>2020-01-09T12:53:16.000Z</published>
    <updated>2020-01-09T14:35:53.748Z</updated>
    
    <content type="html"><![CDATA[<p>本文是“实战Elisp”系列的第一篇。本系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。</p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>用Emacs的org-mode安排业余时间颇有些时日，渐渐地开始编写一些Elisp函数来改善自己的使用体验。</p><p>日程管理中一个常见的需求，便是给任务设定一个开始时间。在org-mode中，这可以调用函数org-schedule实现：将光标移动到一个任务上，再按下C-c C-s，会出现一个日历界面，帮助选择日期和时间来作为日程的开始时间。具体效果如下图所示</p><a id="more"></a><video controls><br>  <source src="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200109/org-mode设定任务开始时间.mp4" type="video/mp4"><br></video><p>久而久之发现，设置的开始时间不外乎是中午12点、下午1点、晚上10点等。这是因为业余时间是相对固定的，比如午饭、午休，以及晚上在家洗完澡等。有规律便有优化的空间。既然每次输入的内容都一样，干脆预设几个开始时间，直接选择即可。</p><h1 id="平凡的实现"><a href="#平凡的实现" class="headerlink" title="平凡的实现"></a>平凡的实现</h1><p>一个朴素的想法，是为这些固定的时间点各自编写一个Elisp函数，并绑定到不同的快捷键上，每次设置开始时间时就按下对应的快捷键。循着这个思路，我定义了如下的Elisp函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt-lunch-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为中午12点"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">12</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name">defun</span> lt-rest-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为下午1点"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">13</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name">defun</span> lt-supper-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为傍晚6点35分"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">18</span> <span class="number">35</span>))</span><br><span class="line">(<span class="name">defun</span> lt-night-todo ()</span><br><span class="line">  <span class="string">"将开始时间设置为晚上10点"</span></span><br><span class="line">  (<span class="name">lt-next-todo</span> <span class="number">22</span> <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>lt-next-todo的定义如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> lt-next-todo (<span class="name">hour</span> minute)</span><br><span class="line">  <span class="string">"设置光标所在行为一个TODO条目，并设置其SCHEDULED为HOUR:MINUTE。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果当前的时间已经晚于HOUR:MINUTE，那么将会设定为明天的目标小时。"</span></span><br><span class="line">  (<span class="name">cl-assert</span> (<span class="name">integerp</span> hour))</span><br><span class="line">  (<span class="name">cl-assert</span> (<span class="name">integerp</span> minute))</span><br><span class="line">  (<span class="name">org-todo</span> <span class="string">"TODO"</span>)</span><br><span class="line">  (<span class="name">org-set-tags</span> <span class="literal">nil</span> <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">current-hour</span> (<span class="name">string-to-number</span> (<span class="name">format-time-string</span> <span class="string">"%H"</span>)))</span><br><span class="line">        scheduled)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">&gt;</span> current-hour hour)</span><br><span class="line">           (<span class="name">setf</span> scheduled (<span class="name">format</span> <span class="string">"+1d %02d:%02d"</span> hour minute)))</span><br><span class="line">          (<span class="name">t</span> (<span class="name">setf</span> scheduled (<span class="name">format</span> <span class="string">"%02d:%02d"</span> hour minute))))</span><br><span class="line">    (<span class="name">message</span> <span class="string">"scheduled: %s"</span> scheduled)</span><br><span class="line">    (<span class="name">org-schedule</span> <span class="literal">nil</span> scheduled)))</span><br></pre></td></tr></table></figure><p>除了绑定不同快捷键，也可以直接调用：将光标移动到任务标题上，按下M-:，输入lt-lunch-todo，最后按下回车。鉴于每次都按这么多键实在是太麻烦，我又编写了四个AppleScript脚本代劳键盘操作，再用BetterTouchTools定制了四个Touchbar按钮，以便一键调用这四个AppleScript脚本。举个例子，负责调用lt-lunch-todo的AppleScript脚本的内容为</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"Emacs"</span></span><br><span class="line"><span class="built_in">activate</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br><span class="line"><span class="keyword">tell</span> <span class="built_in">application</span> <span class="string">"System Events"</span></span><br><span class="line">keystroke <span class="string">":"</span> using &#123;option down&#125;</span><br><span class="line">keystroke <span class="string">"(lt-lunch-todo)"</span></span><br><span class="line">keystroke <span class="literal">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">tell</span></span><br></pre></td></tr></table></figure><p>BetterTouchTools中的按钮的设置如下图所示</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/20200109/BTT的四个快捷按钮.jpeg" alt=""></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这套方法用久后发现缺陷蛮多：</p><ol><li>要定义很多高度雷同的Elisp函数；</li><li>要编写很多高度雷同的AppleScript脚本；</li><li>要定制很多高度雷同的BetterTouchTools按钮；</li></ol><p>高度雷同、高度雷同、高度雷同，重要的事情说三遍。有规律便有优化的空间，于是我换了一种更好的方式，实现了可扩展的、优雅的快速设置任务开始时间的办法。</p><p>欲知后事如何，且听下回分解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是“实战Elisp”系列的第一篇。本系列旨在讲述我使用Elisp定制Emacs的经验，抛砖引玉，还请广大Emacs同好不吝赐教——如果真的有广大Emacs用户的话，哈哈哈。&lt;/p&gt;
&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;用Emacs的org-mode安排业余时间颇有些时日，渐渐地开始编写一些Elisp函数来改善自己的使用体验。&lt;/p&gt;
&lt;p&gt;日程管理中一个常见的需求，便是给任务设定一个开始时间。在org-mode中，这可以调用函数org-schedule实现：将光标移动到一个任务上，再按下C-c C-s，会出现一个日历界面，帮助选择日期和时间来作为日程的开始时间。具体效果如下图所示&lt;/p&gt;
    
    </summary>
    
    
      <category term="emacs" scheme="https://liutos.github.io/tags/emacs/"/>
    
      <category term="elisp" scheme="https://liutos.github.io/tags/elisp/"/>
    
      <category term="实战Elisp" scheme="https://liutos.github.io/tags/%E5%AE%9E%E6%88%98Elisp/"/>
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="https://liutos.github.io/2020/01/02/2019%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://liutos.github.io/2020/01/02/2019年总结/</id>
    <published>2020-01-02T14:06:19.000Z</published>
    <updated>2020-01-02T14:17:07.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>9102年都已经过去好几天了，现在才来产出年终总结。</p><h1 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h1><h2 id="cuckoo——定时提醒工具"><a href="#cuckoo——定时提醒工具" class="headerlink" title="cuckoo——定时提醒工具"></a>cuckoo——定时提醒工具</h2><p>在<a href="https://liutos.github.io/2018/12/29/2018%E5%B9%B4%E5%BA%A6%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">18年的总结</a>中，我提到自己开发了一个名为<code>cuckoo</code>的工具，用来代替macOS的提醒事项、日历，以及由crontab调用的shell脚本。这个目标在19年得以实现，<code>cuckoo</code>已经完全取代了它们。</p><p><code>cuckoo</code>实现了以下功能：</p><ol><li>创建一次性和周期性的提醒。<code>cuckoo</code>甚至可以在正确的二月最后一天弹出提醒——不管是平年还是闰年；</li><li>利用<a href="https://github.com/vjeantet/alerter" target="_blank" rel="noopener"><code>alerter</code></a>，<code>cuckoo</code>可以在提醒弹出后推迟它（5分钟、10分钟），或推迟到指定的时刻；</li><li>利用<a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">Server酱</a>，<code>cuckoo</code>可以把提醒以微信消息推给手机；</li><li>利用<a href="https://www.controlplaneapp.com/" target="_blank" rel="noopener"><code>ControlPlane</code></a>，实现按场景提醒——比如10点钟若在公司就提醒自己开晨会，若在家则绝不弹出。</li></ol><p>我还提供了给Emacs用的minor mode和Alfred Workflow，以提高易用性：</p><ol><li>在Emacs的org-mode中启用这个minor mode后，只需要按下<code>C-c r</code>便可为光标所在的条目创建提醒；</li><li>一个条目切换至<code>DONE</code>或<code>CANCELLED</code>状态时，也会自动更改<code>cuckoo</code>中任务的状态（感兴趣的读者可以移步<a href="http://liutos.github.io/2019/02/05/%E6%8B%BFEmacs%E5%AF%B9%E6%8E%A5%E6%88%91%E7%9A%84cuckoo/">之前的文章</a>）；</li><li>Alfred Workflow便于创建一次性提醒——比如提醒自己在25分钟后打开支付宝的蚂蚁庄园看看有没有鸡贼。</li></ol><h2 id="wa——Alfred-Workflow脚本"><a href="#wa——Alfred-Workflow脚本" class="headerlink" title="wa——Alfred Workflow脚本"></a>wa——Alfred Workflow脚本</h2><p>在18年入手MBP后不久，我便入手了<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>，并购买了<a href="https://www.alfredapp.com/powerpack/" target="_blank" rel="noopener">Powerpack</a>。平均每天使用Alfred 110次，大多是Snippets（auto expansion真香）、Clipboard（临时存储文字和图片的绝佳位置）、Workflow。常用的Workflow都是我自己开发的：</p><ol><li><code>unit</code>用于快速输入不同时间长度的秒数的，例如输入6天的秒数<code>6 * 24 * 60 * 60 * 1000</code>；</li><li><code>upload</code>用于上传图片到GitHub，把GitHub当图床用（感兴趣的读者可以移步这篇<a href="https://liutos.github.io/2018/12/07/%E6%8A%8AGitHub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/">文章</a>）；</li><li><code>gt</code>用于获取指定日期的UNIX时间戳、<code>int</code>用于获取一些预设的时间戳（例如“昨天0点”）；</li><li><code>yl</code>用于精确设定macOS的音量；</li><li><code>bqb</code>用于斗图（感兴趣的读者可以移步<a href="https://liutos.github.io/2019/12/16/%E8%AE%A9%E6%96%97%E5%9B%BE%E8%B5%A2%E5%9C%A8%E8%B5%B7%E8%B7%91%E7%BA%BF%E4%B8%8A/">这里</a>）。</li></ol><p>这些脚本都收集在名为wa的私有仓库中。由于需求比较稳定，这个仓库的迭代不多。</p><h2 id="jjcc——将LISP语言编译为x64汇编"><a href="#jjcc——将LISP语言编译为x64汇编" class="headerlink" title="jjcc——将LISP语言编译为x64汇编"></a>jjcc——将LISP语言编译为x64汇编</h2><p>不害臊地说，<code>jjcc</code>是一个用Common Lisp写就的编译器，运行在<a href="https://common-lisp.net/project/slime/" target="_blank" rel="noopener">SLIME</a>中，如果投喂它某种LISP方言代码，就可以编译出跑在macOS上的x64汇编代码。这是我的第一款生成汇编指令的编译器，为此还恶补了不少汇编语言知识，尤其是x64的calling convention。这款编译器的开发过程写成了文章发表在博客和知乎上，感兴趣的读者可以移步这个<a href="https://zhuanlan.zhihu.com/lessmore" target="_blank" rel="noopener">专栏</a>。</p><p>在完成了蹩脚的自定义函数特性后，我读了《An Incremental Approach to Compiler Construction》这篇论文，它循序渐进地开发一个Scheme语言到x86汇编的编译器，并且阶段划分得更好，后来我也按照论文的思路重新实现了一遍。</p><h2 id="savemoney——未完待续的RescueTime代替品"><a href="#savemoney——未完待续的RescueTime代替品" class="headerlink" title="savemoney——未完待续的RescueTime代替品"></a>savemoney——未完待续的RescueTime代替品</h2><p>19年10月份时RescueTime Premium到期，由于太鸡肋了便不再续费。我仍然有time-tracking的需求，于是打算自己动手写一个代替品。皇天不负有心人，我找到了<a href="https://www.npmjs.com/package/active-win" target="_blank" rel="noopener"><code>active-win</code></a>这个库，它可以获取当前有焦点的窗口的元信息。基于这个库我写了两个脚本：</p><ol><li><code>savemoney.js</code>，每隔一秒调用<code>active-win</code>获取当前激活窗口的元信息，然后写入到Redis中；</li><li><code>accounting.js</code>，不停地从Redis中取出数据，运算后写入到MySQL中。</li></ol><p>目前仅仅是将数据记录在了MySQL中，没有做报表和统计。这两个脚本通过Launchd在每次登录后自动运行。</p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>19年在GitHub博客一共发表了28篇博文，数量差强人意，质量亟待提高。在读了<a href="https://maxoxo.me/pyramid-theory/" target="_blank" rel="noopener">利用金字塔原理写出好文章</a>后，我逐渐改进自己的写作方法，以期写得更有条理。</p><p>除了GitHub博客和SegmentFault，我还在知乎上发表了一些文章，大多是关于jjcc编译器的。刚才我说文章的质量亟待提高，如果你看过jjcc编译器系列的文章的话，一定会很同意我的观点。</p><p>博客和SegmentFault的受众很小，于是我又开通了微信订阅号，希望可以在技术圈子里更多的展示自己——有没有值得展示的内容另说。在订阅号上发表文章多了一种无形的压力，毕竟这些内容更容易被同学、同事、同行看到（前提是人家乐意看）。万一写的很糟糕，可就糗大了。目前订阅号关注者寥寥，有兴趣的可以微信搜索“小打小闹写点bug”关注。</p><h1 id="学习、进修"><a href="#学习、进修" class="headerlink" title="学习、进修"></a>学习、进修</h1><p>19年读完的书不多：</p><ol><li>《MongoDB in Action》，没什么太大的收获；</li><li>《High Performance MySQL》，看过后确实有些帮助，切实根据书中的指导调优过生产环境的MySQL；</li><li>《Algorithms》，光看没练手；</li><li>《Linux Shell Scripting Cookbook》，看着看着幡然醒悟这东西只要用到的时候查阅就足够了，遂弃之。</li></ol><p>还有许多在读经典书籍，如《Clean Architecture》、《重构》。刚开始我会在上下班搭地铁时读这些书，后来将看书时间固定在了每天下午一点至一点半。这些在读的书像一条队列，我每天会读队头的书，然后放到队尾。这样一来，每天都在涉猎不同领域的内容。</p><p>在18年9月，我闭门造车地整理了一份Web后端软件工程师的技能树，再据此来寻找要读的书。例如，上述的《MongoDB in Action》是依据“后端知识/文档数据库/MongoDB”找的，《Linux Shell Scripting Cookbook》是依据“后端知识/命令行操作”找的。技能树整理得好不好暂且按下不表，但渐渐地我忘记了看书的初衷，成了“为看而看”。看似每天中午都在学习，实际上由于目的性不强，收获不大。由于每天读不同类型的书，同一个主题的学习过程也变得支离破碎。这个学习方法已经到了迫切需要优化的地步。</p><h1 id="macOS更新换代——AppleScript来袭、Chrome上位"><a href="#macOS更新换代——AppleScript来袭、Chrome上位" class="headerlink" title="macOS更新换代——AppleScript来袭、Chrome上位"></a>macOS更新换代——AppleScript来袭、Chrome上位</h1><p>19年10月升级到macOS Catalina，然后问题便接踵而至。首当其冲的是<code>alerter</code>和<code>terminal-notifier</code>没法用了，无法在右上角弹出提醒。一番折腾后不见起色，只好先用AppleScript代替，让<code>cuckoo</code>可以弹出提醒。AppleScript的<code>display notification</code>功能远不及<code>alerter</code>那么丰富，聊胜于无吧。</p><p>Firefox也开始闹别扭。只要打开Firefox稍微用两下，就会有一个名为FirefoxWebCP Extension的进程疯狂地使用CPU，Firefox内的各标签页也纷纷失灵转圈，几天下来都是如此。没办法，只好起用Chrome。稍微磨合后发现Chrome其实挺不错，各方面都今非昔比。以前之所以一直坚守在Firefox的阵营，主要是因为：</p><ol><li>Firefox的Pocket插件更好用——早年间不需要打开Pocket的网站即可查看自己的列表，不过自从Firefox集成Pocket后，这个优势已经荡然无存；</li><li>Firefox的Vimperator更好用——这也一样，Vimperator逝者已逝，继承者Vim vixen和Chrome的Vimium大同小异；</li><li>Firefox的地址栏搜索浏览历史更好用，这一点迄今未被Chrome超越——Chrome的地址栏要么搜不到，要么必须输入更多关键词，然后还是搜不到。</li></ol><p>希望Mozilla在2020年可以修复这个问题，让我重回Firefox的怀抱。</p><h1 id="CL虐我千万遍，我待CL如初见"><a href="#CL虐我千万遍，我待CL如初见" class="headerlink" title="CL虐我千万遍，我待CL如初见"></a>CL虐我千万遍，我待CL如初见</h1><p>2019年的Common Lisp依然让人哀其不幸怒其不争，我也依然痴迷于这门古怪的语言。但痴迷不能当饭吃，要将CL投入到实际应用实在太难。且不说<a href="https://www.quicklisp.org/beta/" target="_blank" rel="noopener">Quicklisp</a>上库的数量远不及PyPI和NPM，质量也令人抓狂。这不，都9102年了，访问一个返回JSON数据的HTTP接口，还得先用<a href="https://edicl.github.io/drakma/" target="_blank" rel="noopener"><code>drakma</code></a>发出请求（也许不支持HTTP/2），再用<code>flexi-streams</code>将字节数组转换为UTF-8编码的字符串，再用<code>cl-json</code>解析一番。拿到一个列表对象后，再用<code>car</code>、<code>cdr</code>、<code>assoc</code>一顿操作猛如虎，才能拿到需要的数据。</p><p>2020年，MAKE CL GREAT AGAIN！</p><h1 id="记账"><a href="#记账" class="headerlink" title="记账"></a>记账</h1><p>在年中的时候，萌生了换记账软件的想法，因为挖财用起来越来越不爽了，而且整天记流水账也没什么收获。一番摸索后，我决定尝试一下复式记账法，并选择了GNU Cash——早年间用过一次，但没看入门手册就开始用，根本玩不转。这一次倒是读了<a href="https://www.gnucash.org/viewdoc.phtml?rev=3&amp;lang=C&amp;doc=guide" target="_blank" rel="noopener">手册</a>，但GNU Cash的UI和操作方式还是无法让我心动；之后知道了<a href="http://furius.ca/beancount/" target="_blank" rel="noopener">beancount</a>，却无法在我的系统中顺利运行；最终我选择了<a href="https://www.ledger-cli.org/" target="_blank" rel="noopener">ledger</a>，它是一个命令行程序，不负责记录，只负责读取手打显诚意的交易明细，然后产出报表。Emacs有一个<a href="https://github.com/ledger/ledger-mode" target="_blank" rel="noopener">ledger-mode</a>插件，两者配合用来记账超痛快。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>在2020年我希望至少能完成：</p><ol><li>发布<code>cuckoo</code>；</li><li>发布<code>wa</code>；</li><li>开发一个<code>alerter</code>的代替品；</li><li>写更多的博文，让微信订阅号的粉丝涨到130；</li><li>给CL写一些库解决一些常见的需求</li></ol><p>最后</p><p><img src="/images/loading.png" data-original="https://raw.githubusercontent.com/Liutos/riverbed/master/pictures/2020%E5%B9%B4%E4%BC%9A%E5%92%8C2019%E5%B9%B4%E4%B8%80%E6%A0%B7%E7%83%82.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="总结" scheme="https://liutos.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2019" scheme="https://liutos.github.io/tags/2019/"/>
    
  </entry>
  
</feed>
