<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>实用 Prolog 编程 :: 小打小闹写点bug</title><link>https://liutos.github.io/posts/index.html</link><description>This is a new chapter.</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 29 Mar 2025 14:54:37 +0800</lastBuildDate><atom:link href="https://liutos.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>用 Prolog 开发 Hello World 程序</title><link>https://liutos.github.io/posts/hello_world/index.html</link><pubDate>Sun, 23 Feb 2025 11:16:37 +0800</pubDate><guid>https://liutos.github.io/posts/hello_world/index.html</guid><description>序言 本文演示如何用 Prolog 来实现经典的 Hello World 程序。
搭建开发环境 为了可以运行 Prolog 程序，需要先安装一个 Prolog 语言的实现。这里我选择的是 SWI-Prolog，到这里下载对应平台的安装包，安装完毕后，运行命令swipl --version可以看到相应的输出
➜ /tmp swipl --version SWI-Prolog version 9.0.4 for x86_64-darwin 接着再打开这个链接，给 VSCode 安装相应的插件，实现语法高亮，效果如下图所示
运行 Prolog 程序 使用 VSCode 将下列代码保存到名为hello_world.pl的文件中
:- initialization(main, main). main(_) :- writeln("Hello, world!"). 然后运行命令swipl ./hello_world.pl即可输出Hello, world!到屏幕上，如下图所示
展开说说 接下来对上述源文件hello_world.pl做一番讲解。
源文件命名 Prolog 源文件的后缀名通常为.pl，因此上文中的文件名为hello_world.pl。
程序入口 与 C 语言不同，Prolog 并没有规定程序启动的时候要调用哪一个函数，而是由开发者使用命令（Prolog 的术语为directive）:- initialization来指定的。可以将initialization视为一个两个参数的函数：</description></item><item><title>用 Prolog 提供 HTTP 服务_server</title><link>https://liutos.github.io/posts/http_server/index.html</link><pubDate>Sat, 29 Mar 2025 14:41:36 +0800</pubDate><guid>https://liutos.github.io/posts/http_server/index.html</guid><description>序言 书接上回，在上一篇文章中，我们通过尝试用 Prolog 编写 Hello World 程序，了解了 Prolog 程序的基本结构和运行方式。本篇将会在hello_world.pl的基础上，实现一个简单的 HTTP 服务器。
启动 HTTP 服务器 利用 SWI-Prolog 内置的库，很容易就可以启动一个 HTTP 服务器。只需要调用函数http_server即可
:- initialization(main, main). :- use_module(library(http/http_server), [http_server/1]). main(_) :- http_server([port(8082)]), sleep(100000000). 将上述代码保存到文件http_server.pl中并运行便可以启动 HTTP 服务器
由于在源文件中没有定义任何接口，因此任何请求都只会返回 404 的响应
使用模块 在上文中出现的use_module也是一种命令（directive），它用于从模块中导入函数。例如，:- use_module(library(http/http_server), [http_server/1]).的意思，就是从模块http/http_server中导入一个参数个数为 1 的函数http_server到当前模块中，如此一来，就可以直接调用它。
提供接口 正如前文所述，由于当前应用没有注册任何的路由规则，因此无论如何请求都只会返回 404 的响应。接下来我将给这个 HTTP 服务器添加一个非常简单的接口，来固定返回文本Hello, world!。要注册一个接口，需要用到来自于模块http/http_dispatch的函数http_handler，从它的文档可以看到，它需要三个参数：
接口路径Path，如用一个原子来表示的路径/api/shorten； 负责实现接口业务逻辑的函数对象Closure； 描述接口属性的列表Options，如描述该接口的请求方法。 这样一个固定返回 Hello World 字符串的接口可能是下面这样子的</description></item><item><title>用 Prolog 提供短链服务</title><link>https://liutos.github.io/posts/shorten_url/index.html</link><pubDate>Sat, 29 Mar 2025 14:44:39 +0800</pubDate><guid>https://liutos.github.io/posts/shorten_url/index.html</guid><description>序言 在前一篇文章中，HTTP 服务提供了唯一一个接口/api/shorten，但它并非真的会生成短链，而是返回固定的字符串。本文将会对这个接口进行升级，使其可以接收原始 URL 作为参数，并返回一个与其对应的短链的 ID。
提取参数 要想生成短链，首先必须能够接收到用户输入的原始 URL，而这可以使用函数http_parameters/2实现。假设现在要给接口/api/shorten支持一个参数url，要求其以表单的形式输入，并将该输入回显回去，那么代码可以是下面这样的
:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). echo(Request) :- http_parameters(Request, [ url(Url, []) ]), format('Content-Type: text/html~n~n'), format('url is ~s', [Url]). main(_) :- http_handler('/api/shorten', echo, [methods([post])]), http_server([port(8082)]), sleep(100000000). 可以使用下列命令来测试它
curl -X POST -d 'url=https://example.com' -v 'http://localhost:8082/api/shorten' 存储 URL 若是在主流的编程语言中，想要在程序的运行过程暂时维护一些键值关系，通常会使用哈希表，如 JavaScript 中的对象，或 Python 中的字典。在 Prolog 中，有着与之类似的东西，那边是动态谓词。
:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). echo(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: text/html~n~n'), format('bind url ~s to id ~d', [Url, Id]). main(_) :- http_handler('/api/shorten', echo, [methods([post])]), http_server([port(8082)]), sleep(100000000). 这里出现了一个新的指令dynamic，它的作用是声明一个谓词是动态的。这样一来，在程序运行的过程中，就可以使用函数asserta来定义新的“事实”——就像是在往一个关系型数据库的表中不停地插入新的行一样。</description></item><item><title>提供短链访问能力</title><link>https://liutos.github.io/posts/lengthen_url/index.html</link><pubDate>Sat, 29 Mar 2025 14:47:47 +0800</pubDate><guid>https://liutos.github.io/posts/lengthen_url/index.html</guid><description>序言 在上一篇文章中，HTTP 服务已经可以将入参中的原始 URL 存储起来，并将其与一个唯一的 ID 绑定在一起。在本文中，将会新增一个接口，实现将数值 ID 转换为原始 URL，并通过重定向返回给调用者。
重定向到原始 URL 现有的接口/api/shorten的返回值并不利于使用，为此接下来会修改为返回Content-Type: application/json类型的数据。此外，还会有一个新接口/api/lengthen，它接受一个参数id，从内存中找出与这个 ID 绑定的原始 URL，并通过 302 的状态码返回。
:- dynamic url_to_id/2. % 声明一个“动态谓词”。 :- initialization(main, main). :- use_module(library(http/http_dispatch), [http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), url_to_id(Url, Id), http_redirect(moved, Url, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, []) ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), asserta(url_to_id(Url, Id)), % 定义这个动态谓词的一组值。 format('Content-Type: application/json~n~n'), format('{"id": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 启动 HTTP 服务后，先请求接口/api/shorten，获得一个短链的 ID，再访问新接口即可重定向到原始 URL。</description></item><item><title>存储 URL 到文件</title><link>https://liutos.github.io/posts/file_storage/index.html</link><pubDate>Sat, 29 Mar 2025 14:50:11 +0800</pubDate><guid>https://liutos.github.io/posts/file_storage/index.html</guid><description>序言 在前两篇文章中，URL 以及短链的 ID 都是存储在内存中的，程序重启后，已经绑定好的 URL 和 ID 就都丢失了。本章介绍如何将短链的信息存储到文件中，并在程序启动时加载进内存中。
写入文件 在之前的文章中，url_to_id是一个动态谓词，可以将其简单地理解为一个既可以根据Url查询出Id、也可以根据Id查询出Url的双向哈希表。为了可以实现将短链信息存储到文件中，将会把url_to_id修改为一个预先定义好的谓词。
url_to_id仍然接受Url和Id两个参数，但这两个参数在实际使用时，不会同时都有值、总有一个是变量：
如果Url是字符串、Id是整数，那么实现的是将新的 URL 存储起来的功能； 如果Url是变量、Id是整数，那么它会实例化Url，这样实现的是根据 ID 查找原始 URL 的功能。 用于存储短链信息的文件格式为 CSV，第一列为 ID，第二列为原始 URL，而两者之间通过逗号分隔。这样的一个短链服务的代码可能是下面这样子的
:- initialization(main, main). :- use_module(library(http/http_dispatch), [http_404/2, http_handler/3, http_redirect/3]). :- use_module(library(http/http_parameters), [http_parameters/2]). :- use_module(library(http/http_server), [http_server/1]). :- use_module(library(lists), [nth0/3]). :- use_module(library(readutil), [read_file_to_string/3]). find_url_by_id(_, [], _) :- fail. find_url_by_id(Id, [Line|Lines], Url) :- split_string(Line, ",", "", SubStrings), % 将一行内容按照逗号切割，放到 SubStrings 中。 nth0(0, SubStrings, IdString), % 取出第一列的数据，放到 IdString 中。 ( format(string(IdString), "~d", [Id]) % 检查将 Id 转换为字符串的话，是否与 IdString 相同。 -> nth0(1, SubStrings, Url) % 如果相同，说明第二列的数据就是所需要的链接，放入变量 Url。 ; find_url_by_id(Id, Lines, Url)). % 否则，递归处理 Lines，直至为空、查询失败。 % 读写文件来管理短链。 url_to_id(Url, Id) :- string(Url), integer(Id), open("/tmp/url.csv", append, Stream), format(string(Line), '~d,~s~n', [Id, Url]), write(Stream, Line), close(Stream). url_to_id(Url, Id) :- read_file_to_string("/tmp/url.csv", String, []), split_string(String, "\n", "", Lines), find_url_by_id(Id, Lines, Url). % 辅助函数。 reply_by_id(Id, Request) :- ( url_to_id(Url, Id) -> http_redirect(moved, Url, Request) ; http_404([], Request)). lengthen_url(Request) :- http_parameters(Request, [ id(Id, [integer]) ]), reply_by_id(Id, Request). shorten_url(Request) :- http_parameters(Request, [ url(Url, [string]) % 因为 url_to_id 中有类型要求。 ]), % 姑且用当前时间戳来作为 ID。 get_time(TimeStamp), Id is truncate(TimeStamp), url_to_id(Url, Id), format('Content-Type: application/json~n~n'), format('{"id": ~d}', [Id]). main(_) :- http_handler('/api/lengthen', lengthen_url, [methods([get])]), http_handler('/api/shorten', shorten_url, [methods([post])]), http_server([port(8082)]), sleep(100000000). 确保文件流关闭 在url_to_id的定义中，并没有机制可以确保close一定会被调用来关闭文件流。要实现类似 Python 中的with open、或者 Common Lisp 中的with-open-file的效果的话，可以用setup_call_cleanup。因此，url_to_id的第一个分支可以修改为</description></item><item><title>存储 URL 到 MySQL</title><link>https://liutos.github.io/posts/mysql_storage/index.html</link><pubDate>Sat, 29 Mar 2025 14:52:16 +0800</pubDate><guid>https://liutos.github.io/posts/mysql_storage/index.html</guid><description>序言 如果无法读写数据库，那么一门编程语言的实用性将会大打折扣。好在，SWI-Prolog 对这方面也提供了支持，接下来就这方面进行讲解。
连接 MySQL 查阅 SWI-Prolog 的文档可以看到，如果要读取 MySQL，可以使用这几个谓词：
odbc_driver_connect，用来连接数据库； odbc_query，执行查询的 SQL，获取结果； odbc_disconnect，断开数据库连接。 一段查询 MySQL 版本号信息的示例代码如下
:- use_module(library(odbc), [odbc_disconnect/1, odbc_driver_connect/3, odbc_query/3]). :- initialization(main, main). main(_) :- Dsn = "DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten", odbc_driver_connect(Dsn, Connection, []), Sql = "SELECT VERSION()", odbc_query(Connection, Sql, row(Version)), odbc_disconnect(Connection), format("Version is ~s~n", [Version]). 效果如下图所示
MySQL ODBC 驱动 MySQL 的 ODBC 驱动文件需要自己安装。先到这里下载
安装完毕后，通过iODBC Administrator64可以看到驱动的具体文件路径</description></item><item><title>读取 JSON 配置文件</title><link>https://liutos.github.io/posts/json_config/index.html</link><pubDate>Sat, 29 Mar 2025 14:54:37 +0800</pubDate><guid>https://liutos.github.io/posts/json_config/index.html</guid><description>序言 在前一篇文章中，连接数据库的配置是写在代码中的，在谓词url_to_id中重复出现了两次。在本文中，会将配置从源文件中剥离出来，改为在程序启动的时候从 JSON 格式的配置文件中读取。
配置文件及其解析 新增一个配置文件config.json，其内容如下：
{ "mysql": { "dsn": "DRIVER={/usr/local/mysql-connector-odbc-8.0.33-macos13-x86-64bit/lib/libmyodbc8a.so};String Types=Unicode;password=1234567;port=3306;server=localhost;user=shorten" } } 接着新增一个源文件config.pl，它负责实现一个用于解析 JSON 文件的模块
:- module(config, [current_dsn/1, parse/1]). :- dynamic current_dsn/1. % 声明一个动态谓词，用于存储解析好的 ODBC DSN 字符串。 :- use_module(library(http/json), [atom_json_dict/3]). :- use_module(library(readutil), [read_file_to_string/3]). parse(ConfigPath) :- read_file_to_string(ConfigPath, String, []), % 按照 JSON 格式反序列化为字典类型的数据。 atom_json_dict(String, JSONDict, []), % 将 DSN 字符串存储在谓词中，这样外部就可以通过 current_dsn/1 获取。 asserta(current_dsn(JSONDict.mysql.dsn)). 使用效果如下图所示
现在可以改写源文件http_server.pl和url_to_id.pl了，前者在谓词main中调用parse/1来解析配置文件，后者调用current_dsn/1来获取 DSN 以连接数据库。
字典类型 在parse中调用atom_json_dict得到的JSONDict是一个字典类型的对象，可以用write来查看它的内容</description></item></channel></rss>